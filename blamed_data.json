[
    {
        "blob_id": "9b6b1ec168b70a357f4e47169b73b0f2e0538b9b",
        "directory_id": "6565182c28637e21087007f09d480a70b387382e",
        "path": "/code/901.\u80a1\u7968\u4ef7\u683c\u8de8\u5ea6.cpp",
        "content_id": "61b63105d48efcafe008368d50a272d85d3e8c15",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "liu-jianhao/leetcode",
        "snapshot_id": "08c070f0f140b2dd56cffbbaf25868364addfe53",
        "revision_id": "7cbbe0585778517c88aa6ac1d2f2f8478cc931e5",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-07-17 05:54:58",
        "revision_date": "2020-08-17 07:03:52",
        "committer_date": "2020-08-17 07:03:52",
        "github_id": 188854718,
        "star_events_count": 1,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 792,
        "extension": "cpp",
        "content": "/*\n * @lc app=leetcode.cn id=901 lang=cpp\n *\n * [901] \u80a1\u7968\u4ef7\u683c\u8de8\u5ea6\n */\nclass StockSpanner {\npublic:\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        if(_i == 0 || price < _prices.back())\n        {\n            _dp.push_back(1);\n        }\n        else\n        {\n            int j = _i - 1;\n            while(j >= 0 && price >= _prices[j])\n            {\n                j -= _dp[j];\n            }\n            _dp.push_back(_i - j);\n        }\n        ++_i;\n        _prices.push_back(price);        \n        return _dp.back();\n    }\n\nprivate:\n    vector<int> _dp;\n    vector<int> _prices;\n    int _i = 0;\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */\n\n",
        "blame_info": {
            "jianhaoliu17@gmail.com": [
                [
                    1,
                    42
                ]
            ]
        }
    },
    {
        "blob_id": "0f14955c67c8ded4e0b25301b31b8648ae16b52f",
        "directory_id": "4985aad8ecfceca8027709cf488bc2c601443385",
        "path": "/build/Android/Debug/app/src/main/include/Fuse.Resources.Resour-7da5075.h",
        "content_id": "bb740adfa48c8d9b5e34d9b3bf2a2c23882e8030",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "pacol85/Test1",
        "snapshot_id": "a9fd874711af67cb6b9559d9a4a0e10037944d89",
        "revision_id": "c7bb59a1b961bfb40fe320ee44ca67e068f0a827",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-25 11:39:32",
        "revision_date": "2017-06-12 21:48:37",
        "committer_date": "2017-06-12 21:48:37",
        "github_id": 93937614,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 883,
        "extension": "h",
        "content": "// This file was generated based on '../../AppData/Local/Fusetools/Packages/Fuse.Nodes/1.0.2/$.uno'.\n// WARNING: Changes might be lost if you edit this file directly.\n\n#pragma once\n#include <Uno.h>\nnamespace g{namespace Fuse{namespace Resources{struct ResourceConverters;}}}\nnamespace g{namespace Uno{namespace Collections{struct Dictionary;}}}\n\nnamespace g{\nnamespace Fuse{\nnamespace Resources{\n\n// internal static class ResourceConverters :3538\n// {\nuClassType* ResourceConverters_typeof();\nvoid ResourceConverters__Get_fn(uType* __type, uObject** __retval);\n\nstruct ResourceConverters : uObject\n{\n    static uSStrong< ::g::Uno::Collections::Dictionary*> _converters_;\n    static uSStrong< ::g::Uno::Collections::Dictionary*>& _converters() { return ResourceConverters_typeof()->Init(), _converters_; }\n\n    static uObject* Get(uType* __type);\n};\n// }\n\n}}} // ::g::Fuse::Resources\n",
        "blame_info": {
            "newreality64@gmail.com": [
                [
                    1,
                    27
                ]
            ]
        }
    },
    {
        "blob_id": "376f659de9de4170c19135d4e5e6f4fa7d95e938",
        "directory_id": "bc33abf80f11c4df023d6b1f0882bff1e30617cf",
        "path": "/CPP/other/\u674e\u6cc9\u5f70/hhh.cpp",
        "content_id": "0e114bad33f893d5b9c3e166e74c22c9172ffe76",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "pkuzhd/ALL",
        "snapshot_id": "0fad250c710b4804dfd6f701d8f45381ee1a5d11",
        "revision_id": "c18525decdfa70346ec32ca2f47683951f4c39e0",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-07-11 18:20:26",
        "revision_date": "2019-11-20 13:25:24",
        "committer_date": "2019-11-20 13:25:24",
        "github_id": 119031607,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": "2022-06-21 21:10:42",
        "gha_created_at": "2018-01-26 09:19:23",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 6060,
        "extension": "cpp",
        "content": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\nint qipan[15][15] = { 0 };\nint times = 0;\n\nint print();\nbool is_win(int x, int y, int flag);\nbool is_near(int x, int y);\nbool AI_set(int flag);\nint calc_value(int x, int y, int flag, int depth, int _max_value);\nint qixing(int x, int y);\n\nint main(int argc, char **argv)\n{\n\tint flag = 1;\n\twhile (true)\n\t{\n\t\t++times;\n\t\tprint();\n\t\tint x, y;\n\t\tif (flag == 1)\n\t\t{\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tif (!qipan[x][y] || x < 0 || x >= 15 || y < 0 || y >= 15)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqipan[x][y] = flag;\n\t\t\tif (is_win(x, y, flag))\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (AI_set(flag))\n\t\t\t\tbreak;\n\t\t}\n\t\tflag *= -1;\n\t}\n\tif (flag == 1)\n\t{\n\t\tprintf(\"black\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"white\\n\");\n\t}\n \tsystem(\"pause\");\n\treturn 0;\n}\n\nint print()\n{\n\tfor (int i = 0; i < 15; ++i)\n\t{\n\t\tfor (int j = 0; j < 15; ++j)\n\t\t\tcout << (qipan[i][j] ? (qipan[i][j] == 1 ? \"*\" : \"#\") : \"0\");\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\nbool is_win(int x, int y, int flag)\n{\n\tint number = 1;\n\tfor (int i = x + 1; i < 15; ++i)\n\t{\n\t\tif (qipan[i][y] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (int i = x - 1; i >= 0; --i)\n\t{\n\t\tif (qipan[i][y] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (number >= 5)\n\t\treturn true;\n\tnumber = 1;\n\tfor (int i = y + 1; i < 15; ++i)\n\t{\n\t\tif (qipan[x][i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (int i = y - 1; i >= 0; --i)\n\t{\n\t\tif (qipan[x][i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (number >= 5)\n\t\treturn true;\n\tnumber = 1;\n\tfor (int j = 1; x + j < 15 && y + j < 15; ++j)\n\t{\n\t\tif (qipan[x + j][y + j] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (int j = 1; x - j >= 0 && y - j >= 0; ++j)\n\t{\n\t\tif (qipan[x - j][y - j] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (number >= 5)\n\t\treturn true;\n\tnumber = 1;\n\tfor (int j = 1; x + j < 15 && y - j >= 0; ++j)\n\t{\n\t\tif (qipan[x + j][y - j] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (int j = 1; x - j >= 0 && y + j < 15; ++j)\n\t{\n\t\tif (qipan[x - j][y + j] == flag)\n\t\t\t++number;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (number >= 5)\n\t\treturn true;\n\treturn false;\n}\n\nbool is_near(int x, int y)\n{\n\t// cout << x << \" \" << y << endl;\n\tint _near = 2;\n\tfor (int i = (x - _near >= 0 ? x - _near : 0); i <= (x + _near < 15 ? x + _near : 14); ++i)\n\t{\n\t\tfor (int j = (y - _near >= 0 ? y - _near : 0); j <= (y + _near < 15 ? y + _near : 14); ++j)\n\t\t{\n\t\t\tif (qipan[i][j])\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool AI_set(int flag)\n{\n\tint max_value = -10000000;\n\tint x = 7, y = 7;\n\tfor (int i = 0; i < 15; ++i)\n\t{\n\t\tfor (int j = 0; j < 15; ++j)\n\t\t{\n\t\t\tif (qipan[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (!is_near(i, j))\n\t\t\t\tcontinue;\n\t\t\tint t_value = calc_value(i, j, flag, 0, max_value);\n\t\t\tif (is_win(i, j, flag))\n\t\t\t{\n\t\t\t\tqipan[i][j] = flag;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (t_value > max_value)\n\t\t\t{\n\t\t\t\tmax_value = t_value;\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t}\n\tqipan[x][y] = flag;\n\tcout << x << \" \" << y <<  \" \" << flag  << \" \" << is_win(x, y, flag)<< endl;\n\n\treturn false;\n}\n\nint calc_value(int x, int y, int flag, int depth, int _max_value)\n{\n\tint _value = 0;\n\tqipan[x][y] = flag;\n\n\tif (depth < 4)\n\t{\n\t\tint max_value = -10000000;\n\t\tfor (int i = 0; i < 15; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; ++j)\n\t\t\t{\n\t\t\t\tif (qipan[i][j] || !is_near(i, j))\n\t\t\t\t\tcontinue;\n\t\t\t\tint t_value = calc_value(i, j, -flag, depth + 1, max_value);\n\t\t\t\tif (t_value > -_max_value)\n\t\t\t\t{\n\t\t\t\t\tqipan[x][y] = 0;\n\t\t\t\t\treturn t_value;\n\t\t\t\t}\n\t\t\t\tif (is_win(i, j, -flag))\n\t\t\t\t{\n\t\t\t\t\tqipan[x][y] = 0;\n\t\t\t\t\treturn -10000000;\n\t\t\t\t}\n\t\t\t\tif (t_value > max_value)\n\t\t\t\t{\n\t\t\t\t\tmax_value = t_value;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_value -= max_value;\n\t}\n\telse\n\t\t_value += qixing(x, y);\n\tqipan[x][y] = 0;\n\treturn _value;\n}\n\nint qixing(int x, int y)\n{\n\tint flag = qipan[x][y];\n\tbool dead = false;\n\tint number = 1;\n\tint _value = 0;\n\tint sz_qixing[2][6] = { 0 };\n\n\t// x \u65b9\u5411\n\tnumber = 1;\n\tdead = false;\n\tfor (int i = x + 1; ; ++i)\n\t{\n\t\tif (i < 15 && qipan[i][y] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif (i >= 15 || qipan[i][y])\n\t\t\t\tdead = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = x - 1; i >= 0; --i)\n\t{\n\t\tif (i >= 0 && qipan[i][y] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif ((i < 0 || qipan[i][y]) && dead)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dead || qipan[i][y])\n\t\t\t\t\tdead = true;\n\t\t\t\t++sz_qixing[dead][number];\n\t\t\t}\n\t\t}\n\t}\n\n\t// y\u65b9\u5411\n\tnumber = 1;\n\tdead = false;\n\tfor (int i = y + 1; ; ++i)\n\t{\n\t\tif (i < 15 && qipan[x][i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif (i >= 15 || qipan[x][i])\n\t\t\t\tdead = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y - 1; i >= 0; --i)\n\t{\n\t\tif (i >= 0 && qipan[x][i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif ((i < 0 || qipan[x][i]) && dead)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dead || qipan[x][i])\n\t\t\t\t\tdead = true;\n\t\t\t\t++sz_qixing[dead][number];\n\t\t\t}\n\t\t}\n\t}\n\n\t// x y \u65b9\u5411\n\tnumber = 1;\n\tdead = false;\n\tfor (int i = 1; ; ++i)\n\t{\n\t\tif (x + i < 15 && y + i < 15 && qipan[x + i][y + i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif (x + i >= 15 || y + i >= 15 || qipan[x + i][y + i])\n\t\t\t\tdead = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; ; ++i)\n\t{\n\t\tif (x - i >= 0 && y - i >= 0 && qipan[x - i][y - i] == flag)\n\t\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif ((x - i < 0 || y - i < 0 || qipan[x - i][y - i]) && dead)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dead || qipan[x - i][y - i])\n\t\t\t\t\tdead = true;\n\t\t\t\t++sz_qixing[dead][number];\n\t\t\t}\n\t\t}\n\t}\n\n\t// x -y \u65b9\u5411\n\tnumber = 1;\n\tdead = false;\n\tfor (int i = 1; ; ++i)\n\t{\n\t\tif (x + i < 15 && y - i >= 0 && qipan[x + i][y - i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif (x + i >= 15 || y - i < 0 || qipan[x + i][y - i])\n\t\t\t\tdead = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; ; ++i)\n\t{\n\t\tif (x - i >= 0 && y + i < 15 && qipan[x - i][y + i] == flag)\n\t\t\t++number;\n\t\telse\n\t\t{\n\t\t\tif ((x - i < 0 || y + i >= 15 || qipan[x - i][y + i]) && dead)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dead || qipan[x - i][y + i])\n\t\t\t\t\tdead = true;\n\t\t\t\t++sz_qixing[dead][number];\n\t\t\t}\n\t\t}\n\t}\n\tif (sz_qixing[false][4] || (sz_qixing[true][4] + sz_qixing[false][3]) >= 2)\n\t\t_value += 1000000;\n\t_value += sz_qixing[false][3] * 10000;\n\t_value += sz_qixing[true][3] * 1000;\n\t_value += sz_qixing[false][2] * 100;\n\t_value += sz_qixing[true][2] * 10;\n\treturn _value;\n}\n",
        "blame_info": {
            "pkuzhd@pku.edu.cn": [
                [
                    1,
                    365
                ]
            ]
        }
    },
    {
        "blob_id": "2700f3690854eaf5a2187d2d57c0ce1df9fa0f9f",
        "directory_id": "29288023bde7829066f810540963a7b35573fa31",
        "path": "/BstUsingSet.cpp",
        "content_id": "4f984176f775caa7499cc3e20cab43944733c536",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "Sohail-khan786/Competitve-Programming",
        "snapshot_id": "6e56bdd8fb7b3660edec50c72f680b6ed2c41a0f",
        "revision_id": "e90dcf557778a4c0310e03539e4f3c1c939bb3a1",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-10-08 06:55:46",
        "revision_date": "2020-06-07 18:39:20",
        "committer_date": "2020-06-07 18:39:20",
        "github_id": 254899456,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 718,
        "extension": "cpp",
        "content": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int flag=1;\n    set<int> s;\n    set<int>::iterator it;\n    int x;\n\n    while(flag!=3)\n    {\n        cout<<\"1.Insert 2.Delete 3.Exit\"<<endl;\n        cin>>flag;\n\n        cout<<\"value\\t\";\n        cin>>x;\n\n      if(flag==1)\n      {\n        s.insert(x);\n      }\n      else if(flag==2)\n      {\n      s.erase(x);\n      }\n\n    cout<<\"Extracting max n min from a set\"<<cout<<endl;\n    //s.end has iterator to last element of the set which is the size of the set and hence decrement it by one to get the maximum element present in the set;\n      it = s.end();\n      it--;\n\n      cout<<\"maxx = \"<<*(it)<<\"  minn =\"<<*s.begin();\n      cout<<endl;\n    }\n return 0;\n}\n",
        "blame_info": {
            "Khansohail0540@gmail.com": [
                [
                    1,
                    38
                ]
            ]
        }
    },
    {
        "blob_id": "f974d4af50705dd6f63c51d6d7a1ee1c85bf7cd3",
        "directory_id": "414c6adb394c3c7ef4b80ab9b62cfc238ff726e2",
        "path": "/tutorial/spinny/main.cc",
        "content_id": "39f9f8736922a4b8a41c9e0c1c9d1bf851f0a4b6",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "akeley98/vkme",
        "snapshot_id": "68ca6db6c246fe8b4a25a3fb0982ff2552d8ef9b",
        "revision_id": "1b8e7df2a8290a0cc7bd97bf82c88a6eeff40be1",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-12-23 19:53:47",
        "revision_date": "2020-09-29 05:34:32",
        "committer_date": "2020-09-29 05:34:32",
        "github_id": 291925536,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 11670,
        "extension": "cc",
        "content": "#include \"window.hh\"\n#include \"render.hh\"\n#include \"util.hh\"\n\nusing namespace myricube;\n\n// Absolute path of the executable, minus the -bin or .exe, plus -data/\n// This is where shaders and stuff are stored.\nstd::string data_directory;\n\nstd::string expand_filename(const std::string& in)\n{\n    if (data_directory.size() == 0) {\n        throw std::logic_error(\"Cannot call expand_filename before main\");\n    }\n    return in[0] == '/' ? in : data_directory + in;\n}\n\nbool ends_with_bin_or_exe(const std::string& in)\n{\n    auto sz = in.size();\n    if (sz < 4) return false;\n    const char* suffix = &in[sz - 4];\n    return strcmp(suffix, \"-bin\") == 0 or strcmp(suffix, \".exe\") == 0;\n}\n\nbool paused = false;\nint target_fragments = 0;\n\nvoid add_key_targets(Window& window, Camera& camera)\n{\n    static float speed = 8.0f;\n    static float sprint_mod = 1.0f;\n\n    struct Position\n    {\n        glm::dvec3 eye = glm::dvec3(0);\n        float theta = 1.5707f;\n        float phi = 1.5707f;\n    };\n    static Position old_positions_ring_buffer[256];\n    static Position future_positions_ring_buffer[256];\n    static uint8_t old_idx = 0;\n    static uint8_t future_idx = 0;\n\n    static auto get_camera_position = [&camera] () -> Position\n    {\n        Position p;\n        p.eye = camera.get_eye();\n        p.theta = camera.get_theta();\n        p.phi = camera.get_phi();\n        return p;\n    };\n\n    static auto push_camera_position = [&]\n    {\n        old_positions_ring_buffer[--old_idx] = get_camera_position();\n    };\n\n    static auto push_camera_position_callback = [&] (KeyArg arg)\n    {\n        if (arg.repeat) return false;\n        push_camera_position();\n        return true;\n    };\n\n    KeyTarget pop_old_camera, pop_future_camera;\n    pop_old_camera.down = [&] (KeyArg) -> bool\n    {\n        future_positions_ring_buffer[--future_idx] =\n            get_camera_position();\n        Position p = old_positions_ring_buffer[old_idx++];\n        camera.set_eye(p.eye);\n        camera.set_theta(p.theta);\n        camera.set_phi(p.phi);\n        return true;\n    };\n    pop_future_camera.down = [&] (KeyArg) -> bool\n    {\n        old_positions_ring_buffer[--old_idx] =\n            get_camera_position();\n        Position p = future_positions_ring_buffer[future_idx++];\n        camera.set_eye(p.eye);\n        camera.set_theta(p.theta);\n        camera.set_phi(p.phi);\n        return true;\n    };\n    window.add_key_target(\"pop_old_camera\", pop_old_camera);\n    window.add_key_target(\"pop_future_camera\", pop_future_camera);\n\n    KeyTarget forward, backward, leftward, rightward, upward, downward;\n    forward.down = push_camera_position_callback;\n    forward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(0, 0, +arg.dt * speed * sprint_mod);\n        return true;\n    };\n    backward.down = push_camera_position_callback;\n    backward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(0, 0, -arg.dt * speed * sprint_mod);\n        return true;\n    };\n    leftward.down = push_camera_position_callback;\n    leftward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(-arg.dt * speed * sprint_mod, 0, 0);\n        return true;\n    };\n    rightward.down = push_camera_position_callback;\n    rightward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(+arg.dt * speed * sprint_mod, 0, 0);\n        return true;\n    };\n    upward.down = push_camera_position_callback;\n    upward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(0, +arg.dt * speed * sprint_mod, 0);\n        return true;\n    };\n    downward.down = push_camera_position_callback;\n    downward.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.frenet_move(0, -arg.dt * speed * sprint_mod, 0);\n        return true;\n    };\n    window.add_key_target(\"forward\", forward);\n    window.add_key_target(\"backward\", backward);\n    window.add_key_target(\"leftward\", leftward);\n    window.add_key_target(\"rightward\", rightward);\n    window.add_key_target(\"upward\", upward);\n    window.add_key_target(\"downward\", downward);\n\n    KeyTarget sprint, speed_up, slow_down;\n    sprint.down = [&] (KeyArg) -> bool\n    {\n        sprint_mod = 7.0f;\n        return true;\n    };\n    sprint.up = [&] (KeyArg) -> bool\n    {\n        sprint_mod = 1.0f;\n        return true;\n    };\n    speed_up.down = [&] (KeyArg arg) -> bool\n    {\n        if (!arg.repeat) speed *= 2.0f;\n        return !arg.repeat;\n    };\n    slow_down.down = [&] (KeyArg arg) -> bool\n    {\n        if (!arg.repeat) speed *= 0.5f;\n        return !arg.repeat;\n    };\n    window.add_key_target(\"sprint\", sprint);\n    window.add_key_target(\"speed_up\", speed_up);\n    window.add_key_target(\"slow_down\", slow_down);\n\n    KeyTarget vertical_scroll, horizontal_scroll, look_around;\n    look_around.down = push_camera_position_callback;\n    look_around.per_frame = [&] (KeyArg arg) -> bool\n    {\n        camera.inc_theta(arg.mouse_rel_x * arg.dt * 0.01f);\n        camera.inc_phi(arg.mouse_rel_y * arg.dt * 0.01f);\n        return true;\n    };\n    vertical_scroll.down = [&] (KeyArg arg) -> bool\n    {\n        camera.inc_phi(arg.amount * -0.05f);\n        return true;\n    };\n    horizontal_scroll.down = [&] (KeyArg arg) -> bool\n    {\n        camera.inc_theta(arg.amount * -0.05f);\n        return true;\n    };\n    window.add_key_target(\"look_around\", look_around);\n    window.add_key_target(\"vertical_scroll\", vertical_scroll);\n    window.add_key_target(\"horizontal_scroll\", horizontal_scroll);\n}\n\n// Given the full path of a key binds file, parse it for key bindings\n// and add it to the window's database of key bindings (physical\n// key/mouse button to KeyTarget name associations).\n//\n// Syntax: the file should consist of lines of pairs of key names and\n// KeyTarget names. Blank (all whitespace) lines are allowed as well\n// as comments, which go from a # character to the end of the line.\n//\n// Returns true iff successful (check errno on false).\nbool add_key_binds_from_file(Window& window, std::string filename) noexcept\n{\n    FILE* file = fopen(filename.c_str(), \"r\");\n    if (file == nullptr) {\n        fprintf(stderr, \"Could not open %s\\n\", filename.c_str());\n        return false;\n    }\n\n    int line_number = 0;\n\n    auto skip_whitespace = [file]\n    {\n        int c;\n        while (1) {\n            c = fgetc(file);\n            if (c == EOF) return;\n            if (c == '\\n' or !isspace(c)) {\n                ungetc(c, file);\n                return;\n            }\n        }\n    };\n    errno = 0;\n\n    bool eof = false;\n    while (!eof) {\n        std::string key_name;\n        std::string target_name;\n        ++line_number;\n\n        int c;\n        skip_whitespace();\n\n        // Parse key name (not case sensitive -- converted to lower case)\n        while (1) {\n            c = fgetc(file);\n\n            if (c == EOF) {\n                if (errno != 0 and errno != EAGAIN) goto bad_eof;\n                eof = true;\n                goto end_line;\n            }\n            if (c == '\\n') goto end_line;\n            if (isspace(c)) break;\n            if (c == '#') goto comment;\n            key_name.push_back(c);\n        }\n\n        skip_whitespace();\n\n        // Parse target name (case sensitive)\n        while (1) {\n            c = fgetc(file);\n\n            if (c == EOF) {\n                if (errno != 0 and errno != EAGAIN) goto bad_eof;\n                eof = true;\n                goto end_line;\n            }\n            if (c == '\\n') goto end_line;\n            if (isspace(c)) break;\n            if (c == '#') goto comment;\n            target_name.push_back(c);\n        }\n\n        skip_whitespace();\n\n        // Check for unexpected cruft at end of line.\n        c = fgetc(file);\n        if (c == EOF) {\n            if (errno != 0 and errno != EAGAIN) goto bad_eof;\n            eof = true;\n            goto end_line;\n        }\n        else if (c == '#') {\n            goto comment;\n        }\n        else if (c == '\\n') {\n            goto end_line;\n        }\n        else {\n            fprintf(stderr, \"%s:%i unexpected third token\"\n                \" starting with '%c'\\n\",\n                filename.c_str(), line_number, c);\n            errno = EINVAL;\n            goto bad_eof;\n        }\n\n        // Skip over comment characters from # to \\n\n      comment:\n        while (1) {\n            c = fgetc(file);\n            if (c == EOF) {\n                if (errno != 0 and errno != EAGAIN) goto bad_eof;\n                eof = true;\n                goto end_line;\n            }\n            if (c == '\\n') {\n                break;\n            }\n        }\n      end_line:\n        // skip blank lines silently.\n        if (key_name.size() == 0) continue;\n\n        // Complain if only one token is provided on a line.\n        if (target_name.size() == 0) {\n            fprintf(stderr, \"%s:%i key name without target name.\\n\",\n                filename.c_str(), line_number);\n            errno = EINVAL;\n            goto bad_eof;\n        }\n\n        auto keycode = keycode_from_name(key_name);\n        if (keycode == 0) {\n            fprintf(stderr, \"%s:%i unknown key name %s.\\n\",\n                filename.c_str(), line_number, key_name.c_str());\n            errno = EINVAL;\n            goto bad_eof;\n        }\n\n        fprintf(stderr, \"Binding %s (%i) to %s\\n\",\n            key_name.c_str(), keycode, target_name.c_str());\n        window.bind_keycode(keycode, target_name);\n    }\n\n    if (fclose(file) != 0) {\n        fprintf(stderr, \"Error closing %s\\n\", filename.c_str());\n        return false;\n    }\n    return true;\n  bad_eof:\n    fprintf(stderr, \"Warning: unexpected end of parsing.\\n\");\n    int eof_errno = errno;\n    fclose(file);\n    errno = eof_errno;\n    return true; // I'm getting bogus EOF fails all the time so fake success :/\n}\n\nvoid bind_keys(Window& window)\n{\n    auto default_file = expand_filename(\"default-keybinds.txt\");\n    auto user_file = expand_filename(\"keybinds.txt\");\n\n    bool default_okay = add_key_binds_from_file(window, default_file);\n    if (!default_okay) {\n        fprintf(stderr, \"Failed to parse %s\\n\", default_file.c_str());\n        fprintf(stderr, \"%s (%i)\\n\", strerror(errno), errno);\n        exit(2);\n    }\n\n    bool user_okay = add_key_binds_from_file(window, user_file);\n    if (!user_okay) {\n        if (errno == ENOENT) {\n            fprintf(stderr, \"Custom keybinds file %s not found.\\n\",\n                user_file.c_str());\n        }\n        else {\n            fprintf(stderr, \"Failed to parse %s\\n\", user_file.c_str());\n            fprintf(stderr, \"%s (%i)\\n\", strerror(errno), errno);\n            exit(2);\n        }\n    }\n}\n\nint main(int argc, char** argv)\n{\n    // Data directory (where shaders are stored) is the path of this\n    // executable, with the -bin or .exe file extension replaced with\n    // -data. Construct that directory name here.\n    data_directory = argv[0];\n    if (!ends_with_bin_or_exe(data_directory)) {\n        fprintf(stderr, \"%s should end with '-bin' or '.exe'\\n\",\n            data_directory.c_str());\n        return 1;\n    }\n    for (int i = 0; i < 4; ++i) data_directory.pop_back();\n    data_directory += \"-data/\";\n\n    // Instantiate the camera.\n    Camera camera;\n\n    // Create a window; callback ensures these window dimensions stay accurate.\n    int screen_x = 0, screen_y = 0;\n    auto on_window_resize = [&camera, &screen_x, &screen_y] (int x, int y)\n    {\n        camera.set_window_size(x, y);\n        screen_x = x;\n        screen_y = y;\n    };\n    Window window(on_window_resize);\n    Renderer* renderer = new_renderer(window);\n\n    add_key_targets(window, camera);\n    bind_keys(window);\n\n    while (window.frame_update()) draw_frame(renderer, camera);\n\n    delete_renderer(renderer);\n}\n",
        "blame_info": {
            "dza724@gmail.com": [
                [
                    1,
                    391
                ]
            ]
        }
    },
    {
        "blob_id": "c72b126db59c6cb052c34231c126266a1ceaac6e",
        "directory_id": "e61a235b8468b03aee0120bf26ec615c045005d2",
        "path": "/src/library/util.cpp",
        "content_id": "32cc91df3304b7f4be7bc7b7fb4b1b710fdfed49",
        "detected_licenses": [
            "Apache-2.0"
        ],
        "license_type": "permissive",
        "repo_name": "SCKelemen/lean4",
        "snapshot_id": "140dc63a80539f7c61c8e43e1c174d8500ec3230",
        "revision_id": "e10507e6615ddbef73d67b0b6c7f1e4cecdd82bc",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-08-20 05:33:15",
        "revision_date": "2020-05-23 23:53:53",
        "committer_date": "2020-05-23 23:53:53",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 33823,
        "extension": "cpp",
        "content": "/*\nCopyright (c) 2014 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n\nAuthor: Leonardo de Moura\n*/\n#include <algorithm>\n#include <string>\n#include \"util/fresh_name.h\"\n#include \"kernel/find_fn.h\"\n#include \"kernel/instantiate.h\"\n#include \"kernel/type_checker.h\"\n#include \"kernel/abstract.h\"\n#include \"kernel/inductive.h\"\n#include \"library/abstract_type_context.h\"\n#include \"library/error_msgs.h\"\n#include \"library/locals.h\"\n#include \"library/util.h\"\n#include \"library/suffixes.h\"\n#include \"library/annotation.h\"\n#include \"library/constants.h\"\n#include \"library/pp_options.h\"\n#include \"library/projection.h\"\n#include \"library/replace_visitor.h\"\n#include \"library/type_context.h\"\n#include \"library/string.h\"\n#include \"library/num.h\"\n#include \"version.h\"\n#include \"githash.h\" // NOLINT\n\nnamespace lean {\nname mk_unused_name(environment const & env, name const & n, unsigned & idx) {\n    name curr = n;\n    while (true) {\n        if (!env.find(curr))\n            return curr;\n        curr = n.append_after(idx);\n        idx++;\n    }\n}\n\nname mk_unused_name(environment const & env, name const & n) {\n    unsigned idx = 1;\n    return mk_unused_name(env, n, idx);\n}\n\n/** \\brief Return the \"arity\" of the given type. The arity is the number of nested pi-expressions. */\nunsigned get_arity(expr type) {\n    unsigned r = 0;\n    while (is_pi(type)) {\n        type = binding_body(type);\n        r++;\n    }\n    return r;\n}\n\noptional<expr> is_optional_param(expr const & e) {\n    if (is_app_of(e, get_opt_param_name(), 2)) {\n        return some_expr(app_arg(e));\n    } else {\n        return none_expr();\n    }\n}\n\noptional<expr_pair> is_auto_param(expr const & e) {\n    if (is_app_of(e, get_auto_param_name(), 2)) {\n        return optional<expr_pair>(app_arg(app_fn(e)), app_arg(e));\n    } else {\n        return optional<expr_pair>();\n    }\n}\n\nlevel get_level(abstract_type_context & ctx, expr const & A) {\n    expr S = ctx.relaxed_whnf(ctx.infer(A));\n    if (!is_sort(S))\n        throw exception(\"invalid expression, sort expected\");\n    return sort_level(S);\n}\n\nname mk_fresh_lp_name(names const & lp_names) {\n    name l(\"l\");\n    int i = 1;\n    while (std::find(lp_names.begin(), lp_names.end(), l) != lp_names.end()) {\n        l = name(\"l\").append_after(i);\n        i++;\n    }\n    return l;\n}\n\nbool occurs(expr const & n, expr const & m) {\n    return static_cast<bool>(find(m, [&](expr const & e, unsigned) { return n == e; }));\n}\n\nbool occurs(name const & n, expr const & m) {\n    return static_cast<bool>(find(m, [&](expr const & e, unsigned) { return is_constant(e) && const_name(e) == n; }));\n}\n\nbool is_app_of(expr const & t, name const & f_name) {\n    expr const & fn = get_app_fn(t);\n    return is_constant(fn) && const_name(fn) == f_name;\n}\n\nbool is_app_of(expr const & t, name const & f_name, unsigned nargs) {\n    expr const & fn = get_app_fn(t);\n    return is_constant(fn) && const_name(fn) == f_name && get_app_num_args(t) == nargs;\n}\n\nexpr consume_auto_opt_param(expr const & type) {\n    if (is_app_of(type, get_auto_param_name(), 2) || is_app_of(type, get_opt_param_name(), 2)) {\n        return app_arg(app_fn(type));\n    } else {\n        return type;\n    }\n}\n\noptional<expr> unfold_term(environment const & env, expr const & e) {\n    expr const & f = get_app_fn(e);\n    if (!is_constant(f))\n        return none_expr();\n    auto decl = env.find(const_name(f));\n    if (!decl || !decl->has_value())\n        return none_expr();\n    expr d = instantiate_value_lparams(*decl, const_levels(f));\n    buffer<expr> args;\n    get_app_rev_args(e, args);\n    return some_expr(apply_beta(d, args.size(), args.data()));\n}\n\noptional<expr> unfold_app(environment const & env, expr const & e) {\n    if (!is_app(e))\n        return none_expr();\n    return unfold_term(env, e);\n}\n\noptional<level> dec_level(level const & l) {\n    switch (kind(l)) {\n    case level_kind::Zero: case level_kind::Param: case level_kind::MVar:\n        return none_level();\n    case level_kind::Succ:\n        return some_level(succ_of(l));\n    case level_kind::Max:\n        if (auto lhs = dec_level(max_lhs(l))) {\n        if (auto rhs = dec_level(max_rhs(l))) {\n            return some_level(mk_max(*lhs, *rhs));\n        }}\n        return none_level();\n    case level_kind::IMax:\n        // Remark: the following mk_max is not a typo. The following\n        // assertion justifies it.\n        if (auto lhs = dec_level(imax_lhs(l))) {\n        if (auto rhs = dec_level(imax_rhs(l))) {\n            return some_level(mk_max(*lhs, *rhs));\n        }}\n        return none_level();\n    }\n    lean_unreachable(); // LCOV_EXCL_LINE\n}\n\n/** \\brief Return true if environment has a constructor named \\c c that returns\n    an element of the inductive datatype named \\c I, and \\c c must have \\c nparams parameters. */\nbool has_constructor(environment const & env, name const & c, name const & I, unsigned nparams) {\n    auto d = env.find(c);\n    if (!d || d->has_value())\n        return false;\n    expr type = d->get_type();\n    unsigned i = 0;\n    while (is_pi(type)) {\n        i++;\n        type = binding_body(type);\n    }\n    if (i != nparams)\n        return false;\n    type = get_app_fn(type);\n    return is_constant(type) && const_name(type) == I;\n}\n\nbool has_punit_decls(environment const & env) {\n    return has_constructor(env, get_punit_unit_name(), get_punit_name(), 0);\n}\n\nbool has_eq_decls(environment const & env) {\n    return has_constructor(env, get_eq_refl_name(), get_eq_name(), 2);\n}\n\nbool has_heq_decls(environment const & env) {\n    return has_constructor(env, get_heq_refl_name(), get_heq_name(), 2);\n}\n\nbool has_pprod_decls(environment const & env) {\n    return has_constructor(env, get_pprod_mk_name(), get_pprod_name(), 4);\n}\n\nbool has_and_decls(environment const & env) {\n    return has_constructor(env, get_and_intro_name(), get_and_name(), 4);\n}\n\n/* n is considered to be recursive if it is an inductive datatype and\n   1) It has a constructor that takes n as an argument\n   2) It is part of a mutually recursive declaration, and some constructor\n      of an inductive datatype takes another inductive datatype from the\n      same declaration as an argument. */\nbool is_recursive_datatype(environment const & env, name const & n) {\n    constant_info info = env.get(n);\n    return info.is_inductive() && info.to_inductive_val().is_rec();\n}\n\nlevel get_datatype_level(expr const & ind_type) {\n    expr it = ind_type;\n    while (is_pi(it))\n        it = binding_body(it);\n    if (is_sort(it)) {\n        return sort_level(it);\n    } else {\n        throw exception(\"invalid inductive datatype type\");\n    }\n}\n\nexpr update_result_sort(expr t, level const & l) {\n    if (is_pi(t)) {\n        return update_binding(t, binding_domain(t), update_result_sort(binding_body(t), l));\n    } else if (is_sort(t)) {\n        return update_sort(t, l);\n    } else {\n        lean_unreachable();\n    }\n}\n\nbool is_inductive_predicate(environment const & env, name const & n) {\n    constant_info info = env.get(n);\n    if (!info.is_inductive())\n        return false;\n    return is_zero(get_datatype_level(env.get(n).get_type()));\n}\n\nbool can_elim_to_type(environment const & env, name const & n) {\n    constant_info ind_info = env.get(n);\n    if (!ind_info.is_inductive()) return false;\n    constant_info rec_info = env.get(mk_rec_name(n));\n    return rec_info.get_num_lparams() > ind_info.get_num_lparams();\n}\n\nvoid get_constructor_names(environment const & env, name const & n, buffer<name> & result) {\n    constant_info info = env.get(n);\n    if (!info.is_inductive()) return;\n    to_buffer(info.to_inductive_val().get_cnstrs(), result);\n}\n\noptional<name> is_constructor_app(environment const & env, expr const & e) {\n    expr const & fn = get_app_fn(e);\n    if (is_constant(fn)) {\n        if (is_constructor(env, const_name(fn)))\n            return optional<name>(const_name(fn));\n    }\n    return optional<name>();\n}\n\noptional<name> is_constructor_app_ext(environment const & env, expr const & e) {\n    if (auto r = is_constructor_app(env, e))\n        return r;\n    expr const & f = get_app_fn(e);\n    if (!is_constant(f))\n        return optional<name>();\n    optional<constant_info> info = env.find(const_name(f));\n    if (!info || !info->has_value())\n        return optional<name>();\n    expr val = info->get_value();\n    expr const * it = &val;\n    while (is_lambda(*it))\n        it = &binding_body(*it);\n    return is_constructor_app_ext(env, *it);\n}\n\nstatic name * g_util_fresh = nullptr;\n\nvoid get_constructor_relevant_fields(environment const & env, name const & n, buffer<bool> & result) {\n    constant_info info  = env.get(n);\n    lean_assert(info.is_constructor());\n    constructor_val val = info.to_constructor_val();\n    expr type           = info.get_type();\n    name I_name         = val.get_induct();\n    unsigned nparams    = val.get_nparams();\n    local_ctx lctx;\n    name_generator ngen(*g_util_fresh);\n    buffer<expr> telescope;\n    to_telescope(env, lctx, ngen, type, telescope);\n    lean_assert(telescope.size() >= nparams);\n    for (unsigned i = nparams; i < telescope.size(); i++) {\n        expr ftype = lctx.get_type(telescope[i]);\n        if (type_checker(env, lctx).is_prop(ftype)) {\n            result.push_back(false);\n        } else {\n            buffer<expr> tmp;\n            expr n_ftype = to_telescope(env, lctx, ngen, ftype, tmp);\n            result.push_back(!is_sort(n_ftype) && !type_checker(env, lctx).is_prop(n_ftype));\n        }\n    }\n}\n\nunsigned get_num_constructors(environment const & env, name const & n) {\n    constant_info info = env.get(n);\n    lean_assert(info.is_inductive());\n    return length(info.to_inductive_val().get_cnstrs());\n}\n\nunsigned get_constructor_idx(environment const & env, name const & n) {\n    constant_info info  = env.get(n);\n    lean_assert(info.is_constructor());\n    constructor_val val = info.to_constructor_val();\n    name I_name         = val.get_induct();\n    buffer<name> cnames;\n    get_constructor_names(env, I_name, cnames);\n    unsigned r  = 0;\n    for (name const & cname : cnames) {\n        if (cname == n)\n            return r;\n        r++;\n    }\n    lean_unreachable();\n}\n\nexpr instantiate_lparam(expr const & e, name const & p, level const & l) {\n    return instantiate_lparams(e, names(p), levels(l));\n}\n\nunsigned get_expect_num_args(abstract_type_context & ctx, expr e) {\n    push_local_fn push_local(ctx);\n    unsigned r = 0;\n    while (true) {\n        e = ctx.whnf(e);\n        if (!is_pi(e))\n            return r;\n        // TODO(Leo): try to avoid the following instantiate.\n        expr local = push_local(binding_name(e), binding_domain(e), binding_info(e));\n        e = instantiate(binding_body(e), local);\n        r++;\n    }\n}\n\nexpr to_telescope(bool pi, local_ctx & lctx, name_generator & ngen, expr e, buffer<expr> & telescope, optional<binder_info> const & binfo) {\n    while ((pi && is_pi(e)) || (!pi && is_lambda(e))) {\n        expr local;\n        if (binfo)\n            local = lctx.mk_local_decl(ngen, binding_name(e), binding_domain(e), *binfo);\n        else\n            local = lctx.mk_local_decl(ngen, binding_name(e), binding_domain(e), binding_info(e));\n        telescope.push_back(local);\n        e = instantiate(binding_body(e), local);\n    }\n    return e;\n}\n\nexpr to_telescope(local_ctx & lctx, name_generator & ngen, expr const & type, buffer<expr> & telescope, optional<binder_info> const & binfo) {\n    return to_telescope(true, lctx, ngen, type, telescope, binfo);\n}\n\nexpr to_telescope(environment const & env, local_ctx & lctx, name_generator & ngen, expr type, buffer<expr> & telescope, optional<binder_info> const & binfo) {\n    expr new_type = type_checker(env, lctx).whnf(type);\n    while (is_pi(new_type)) {\n        type = new_type;\n        expr local;\n        if (binfo)\n            local = lctx.mk_local_decl(ngen, binding_name(type), binding_domain(type), *binfo);\n        else\n            local = lctx.mk_local_decl(ngen, binding_name(type), binding_domain(type), binding_info(type));\n        telescope.push_back(local);\n        type     = instantiate(binding_body(type), local);\n        new_type = type_checker(env, lctx).whnf(type);\n    }\n    return type;\n}\n\n/* ----------------------------------------------\n\n   Helper functions for creating basic operations\n\n   ---------------------------------------------- */\nstatic expr * g_true = nullptr;\nstatic expr * g_true_intro = nullptr;\nstatic expr * g_and = nullptr;\nstatic expr * g_and_intro = nullptr;\nstatic expr * g_and_left = nullptr;\nstatic expr * g_and_right = nullptr;\n\nexpr mk_true() {\n    return *g_true;\n}\n\nbool is_true(expr const & e) {\n    return e == *g_true;\n}\n\nexpr mk_true_intro() {\n    return *g_true_intro;\n}\n\nbool is_and(expr const & e) {\n    return is_app_of(e, get_and_name(), 2);\n}\n\nbool is_and(expr const & e, expr & arg1, expr & arg2) {\n    if (is_and(e)) {\n        arg1 = app_arg(app_fn(e));\n        arg2 = app_arg(e);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexpr mk_and(expr const & a, expr const & b) {\n    return mk_app(*g_and, a, b);\n}\n\nexpr mk_and_intro(abstract_type_context & ctx, expr const & Ha, expr const & Hb) {\n    return mk_app(*g_and_intro, ctx.infer(Ha), ctx.infer(Hb), Ha, Hb);\n}\n\nexpr mk_and_left(abstract_type_context & ctx, expr const & H) {\n    expr a_and_b = ctx.whnf(ctx.infer(H));\n    return mk_app(*g_and_left, app_arg(app_fn(a_and_b)), app_arg(a_and_b), H);\n}\n\nexpr mk_and_right(abstract_type_context & ctx, expr const & H) {\n    expr a_and_b = ctx.whnf(ctx.infer(H));\n    return mk_app(*g_and_right, app_arg(app_fn(a_and_b)), app_arg(a_and_b), H);\n}\n\nexpr mk_unit(level const & l) {\n    return mk_constant(get_punit_name(), {l});\n}\n\nexpr mk_unit_mk(level const & l) {\n    return mk_constant(get_punit_unit_name(), {l});\n}\n\nstatic expr * g_unit = nullptr;\nstatic expr * g_unit_mk = nullptr;\n\nexpr mk_unit() {\n    return *g_unit;\n}\n\nexpr mk_unit_mk() {\n    return *g_unit_mk;\n}\n\nexpr mk_pprod(abstract_type_context & ctx, expr const & A, expr const & B) {\n    level l1 = get_level(ctx, A);\n    level l2 = get_level(ctx, B);\n    return mk_app(mk_constant(get_pprod_name(), {l1, l2}), A, B);\n}\n\nexpr mk_pprod_mk(abstract_type_context & ctx, expr const & a, expr const & b) {\n    expr A = ctx.infer(a);\n    expr B = ctx.infer(b);\n    level l1 = get_level(ctx, A);\n    level l2 = get_level(ctx, B);\n    return mk_app(mk_constant(get_pprod_mk_name(), {l1, l2}), A, B, a, b);\n}\n\nexpr mk_pprod_fst(abstract_type_context & ctx, expr const & p) {\n    expr AxB = ctx.whnf(ctx.infer(p));\n    expr const & A = app_arg(app_fn(AxB));\n    expr const & B = app_arg(AxB);\n    return mk_app(mk_constant(get_pprod_fst_name(), const_levels(get_app_fn(AxB))), A, B, p);\n}\n\nexpr mk_pprod_snd(abstract_type_context & ctx, expr const & p) {\n    expr AxB = ctx.whnf(ctx.infer(p));\n    expr const & A = app_arg(app_fn(AxB));\n    expr const & B = app_arg(AxB);\n    return mk_app(mk_constant(get_pprod_snd_name(), const_levels(get_app_fn(AxB))), A, B, p);\n}\n\nstatic expr * g_nat         = nullptr;\nstatic expr * g_nat_zero    = nullptr;\nstatic expr * g_nat_one     = nullptr;\nstatic expr * g_nat_bit0_fn = nullptr;\nstatic expr * g_nat_bit1_fn = nullptr;\nstatic expr * g_nat_add_fn  = nullptr;\n\nstatic void initialize_nat() {\n    g_nat            = new expr(mk_constant(get_nat_name()));\n    g_nat_zero       = new expr(mk_app(mk_constant(get_has_zero_zero_name(), {mk_level_zero()}), {*g_nat, mk_constant(get_nat_has_zero_name())}));\n    g_nat_one        = new expr(mk_app(mk_constant(get_has_one_one_name(), {mk_level_zero()}), {*g_nat, mk_constant(get_nat_has_one_name())}));\n    g_nat_bit0_fn    = new expr(mk_app(mk_constant(get_bit0_name(), {mk_level_zero()}), {*g_nat, mk_constant(get_nat_has_add_name())}));\n    g_nat_bit1_fn    = new expr(mk_app(mk_constant(get_bit1_name(), {mk_level_zero()}), {*g_nat, mk_constant(get_nat_has_one_name()), mk_constant(get_nat_has_add_name())}));\n    g_nat_add_fn     = new expr(mk_app(mk_constant(get_has_add_add_name(), {mk_level_zero()}), {*g_nat, mk_constant(get_nat_has_add_name())}));\n}\n\nstatic void finalize_nat() {\n    delete g_nat;\n    delete g_nat_zero;\n    delete g_nat_one;\n    delete g_nat_bit0_fn;\n    delete g_nat_bit1_fn;\n    delete g_nat_add_fn;\n}\n\nexpr mk_nat_type() { return *g_nat; }\nbool is_nat_type(expr const & e) { return e == *g_nat; }\nexpr mk_nat_zero() { return *g_nat_zero; }\nexpr mk_nat_one() { return *g_nat_one; }\nexpr mk_nat_bit0(expr const & e) { return mk_app(*g_nat_bit0_fn, e); }\nexpr mk_nat_bit1(expr const & e) { return mk_app(*g_nat_bit1_fn, e); }\nexpr mk_nat_add(expr const & e1, expr const & e2) { return mk_app(*g_nat_add_fn, e1, e2); }\n\nstatic expr * g_int = nullptr;\n\nstatic void initialize_int() {\n    g_int = new expr(mk_constant(get_int_name()));\n}\n\nstatic void finalize_int() {\n    delete g_int;\n}\n\nexpr mk_int_type() { return *g_int; }\nbool is_int_type(expr const & e) { return e == *g_int; }\n\nstatic expr * g_char = nullptr;\n\nexpr mk_char_type() { return *g_char; }\n\nstatic void initialize_char() {\n    g_char = new expr(mk_constant(get_char_name()));\n}\n\nstatic void finalize_char() {\n    delete g_char;\n}\n\nexpr mk_unit(level const & l, bool prop) { return prop ? mk_true() : mk_unit(l); }\nexpr mk_unit_mk(level const & l, bool prop) { return prop ? mk_true_intro() : mk_unit_mk(l); }\n\nexpr mk_pprod(abstract_type_context & ctx, expr const & a, expr const & b, bool prop) {\n    return prop ? mk_and(a, b) : mk_pprod(ctx, a, b);\n}\nexpr mk_pprod_mk(abstract_type_context & ctx, expr const & a, expr const & b, bool prop) {\n    return prop ? mk_and_intro(ctx, a, b) : mk_pprod_mk(ctx, a, b);\n}\nexpr mk_pprod_fst(abstract_type_context & ctx, expr const & p, bool prop) {\n    return prop ? mk_and_left(ctx, p) : mk_pprod_fst(ctx, p);\n}\nexpr mk_pprod_snd(abstract_type_context & ctx, expr const & p, bool prop) {\n    return prop ? mk_and_right(ctx, p) : mk_pprod_snd(ctx, p);\n}\n\nbool is_ite(expr const & e) {\n    return is_app_of(e, get_ite_name(), 5);\n}\n\nbool is_ite(expr const & e, expr & c, expr & H, expr & A, expr & t, expr & f) {\n    if (is_ite(e)) {\n        buffer<expr> args;\n        get_app_args(e, args);\n        lean_assert(args.size() == 5);\n        c = args[0]; H = args[1]; A = args[2]; t = args[3]; f = args[4];\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool is_iff(expr const & e) {\n    return is_app_of(e, get_iff_name(), 2);\n}\n\nbool is_iff(expr const & e, expr & lhs, expr & rhs) {\n    if (!is_iff(e))\n        return false;\n    lhs = app_arg(app_fn(e));\n    rhs = app_arg(e);\n    return true;\n}\nexpr mk_iff(expr const & lhs, expr const & rhs) {\n    return mk_app(mk_constant(get_iff_name()), lhs, rhs);\n}\nexpr mk_iff_refl(expr const & a) {\n    return mk_app(mk_constant(get_iff_refl_name()), a);\n}\nexpr mk_propext(expr const & lhs, expr const & rhs, expr const & iff_pr) {\n    return mk_app(mk_constant(get_propext_name()), lhs, rhs, iff_pr);\n}\n\nexpr mk_eq(abstract_type_context & ctx, expr const & lhs, expr const & rhs) {\n    expr A    = ctx.whnf(ctx.infer(lhs));\n    level lvl = get_level(ctx, A);\n    return mk_app(mk_constant(get_eq_name(), {lvl}), A, lhs, rhs);\n}\n\nexpr mk_eq_refl(abstract_type_context & ctx, expr const & a) {\n    expr A    = ctx.whnf(ctx.infer(a));\n    level lvl = get_level(ctx, A);\n    return mk_app(mk_constant(get_eq_refl_name(), {lvl}), A, a);\n}\n\nexpr mk_eq_symm(abstract_type_context & ctx, expr const & H) {\n    if (is_app_of(H, get_eq_refl_name()))\n        return H;\n    expr p    = ctx.whnf(ctx.infer(H));\n    lean_assert(is_eq(p));\n    expr lhs  = app_arg(app_fn(p));\n    expr rhs  = app_arg(p);\n    expr A    = ctx.infer(lhs);\n    level lvl = get_level(ctx, A);\n    return mk_app(mk_constant(get_eq_symm_name(), {lvl}), A, lhs, rhs, H);\n}\n\nexpr mk_eq_trans(abstract_type_context & ctx, expr const & H1, expr const & H2) {\n    if (is_app_of(H1, get_eq_refl_name()))\n        return H2;\n    if (is_app_of(H2, get_eq_refl_name()))\n        return H1;\n    expr p1    = ctx.whnf(ctx.infer(H1));\n    expr p2    = ctx.whnf(ctx.infer(H2));\n    lean_assert(is_eq(p1) && is_eq(p2));\n    expr lhs1  = app_arg(app_fn(p1));\n    expr rhs1  = app_arg(p1);\n    expr rhs2  = app_arg(p2);\n    expr A     = ctx.infer(lhs1);\n    level lvl  = get_level(ctx, A);\n    return mk_app({mk_constant(get_eq_trans_name(), {lvl}), A, lhs1, rhs1, rhs2, H1, H2});\n}\n\nexpr mk_eq_subst(abstract_type_context & ctx, expr const & motive,\n                 expr const & x, expr const & y, expr const & xeqy, expr const & h) {\n    expr A    = ctx.infer(x);\n    level l1  = get_level(ctx, A);\n    expr r    = mk_constant(get_eq_subst_name(), {l1});\n    return mk_app({r, A, x, y, motive, xeqy, h});\n}\n\nexpr mk_eq_subst(abstract_type_context & ctx, expr const & motive, expr const & xeqy, expr const & h) {\n    expr xeqy_type = ctx.whnf(ctx.infer(xeqy));\n    return mk_eq_subst(ctx, motive, app_arg(app_fn(xeqy_type)), app_arg(xeqy_type), xeqy, h);\n}\n\nexpr mk_congr_arg(abstract_type_context & ctx, expr const & f, expr const & H) {\n    expr eq = ctx.relaxed_whnf(ctx.infer(H));\n    expr pi = ctx.relaxed_whnf(ctx.infer(f));\n    expr A, B, lhs, rhs;\n    lean_verify(is_eq(eq, A, lhs, rhs));\n    lean_assert(is_arrow(pi));\n    B = binding_body(pi);\n    level lvl_1  = get_level(ctx, A);\n    level lvl_2  = get_level(ctx, B);\n    return ::lean::mk_app({mk_constant(get_congr_arg_name(), {lvl_1, lvl_2}), A, B, lhs, rhs, f, H});\n}\n\nexpr mk_subsingleton_elim(abstract_type_context & ctx, expr const & h, expr const & x, expr const & y) {\n    expr A  = ctx.infer(x);\n    level l = get_level(ctx, A);\n    expr r  = mk_constant(get_subsingleton_elim_name(), {l});\n    return mk_app({r, A, h, x, y});\n}\n\nexpr mk_heq(abstract_type_context & ctx, expr const & lhs, expr const & rhs) {\n    expr A    = ctx.whnf(ctx.infer(lhs));\n    expr B    = ctx.whnf(ctx.infer(rhs));\n    level lvl = get_level(ctx, A);\n    return mk_app(mk_constant(get_heq_name(), {lvl}), A, lhs, B, rhs);\n}\n\nbool is_eq_ndrec_core(expr const & e) {\n    expr const & fn = get_app_fn(e);\n    return is_constant(fn) && const_name(fn) == get_eq_ndrec_name();\n}\n\nbool is_eq_ndrec(expr const & e) {\n    expr const & fn = get_app_fn(e);\n    if (!is_constant(fn))\n        return false;\n    return const_name(fn) == get_eq_ndrec_name();\n}\n\nbool is_eq_rec(expr const & e) {\n    expr const & fn = get_app_fn(e);\n    if (!is_constant(fn))\n        return false;\n    return const_name(fn) == get_eq_rec_name();\n}\n\nbool is_eq(expr const & e) {\n    return is_app_of(e, get_eq_name(), 3);\n}\n\nbool is_eq(expr const & e, expr & lhs, expr & rhs) {\n    if (!is_eq(e))\n        return false;\n    lhs = app_arg(app_fn(e));\n    rhs = app_arg(e);\n    return true;\n}\n\nbool is_eq(expr const & e, expr & A, expr & lhs, expr & rhs) {\n    if (!is_eq(e))\n        return false;\n    A   = app_arg(app_fn(app_fn(e)));\n    lhs = app_arg(app_fn(e));\n    rhs = app_arg(e);\n    return true;\n}\n\nbool is_eq_a_a(expr const & e) {\n    if (!is_eq(e))\n        return false;\n    expr lhs = app_arg(app_fn(e));\n    expr rhs = app_arg(e);\n    return lhs == rhs;\n}\n\nbool is_eq_a_a(abstract_type_context & ctx, expr const & e) {\n    if (!is_eq(e))\n        return false;\n    expr lhs = app_arg(app_fn(e));\n    expr rhs = app_arg(e);\n    return ctx.is_def_eq(lhs, rhs);\n}\n\nbool is_heq(expr const & e) {\n    return is_app_of(e, get_heq_name(), 4);\n}\n\nbool is_heq(expr const & e, expr & A, expr & lhs, expr & B, expr & rhs) {\n    if (is_heq(e)) {\n        buffer<expr> args;\n        get_app_args(e, args);\n        lean_assert(args.size() == 4);\n        A = args[0]; lhs = args[1]; B = args[2]; rhs = args[3];\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool is_heq(expr const & e, expr & lhs, expr & rhs) {\n    expr A, B;\n    return is_heq(e, A, lhs, B, rhs);\n}\n\nexpr mk_cast(abstract_type_context & ctx, expr const & H, expr const & e) {\n    expr type = ctx.relaxed_whnf(ctx.infer(H));\n    expr A, B;\n    if (!is_eq(type, A, B))\n        throw exception(\"cast failed, equality proof expected\");\n    level lvl = get_level(ctx, A);\n    return mk_app(mk_constant(get_cast_name(), {lvl}), A, B, H, e);\n}\n\nexpr mk_false() {\n    return mk_constant(get_false_name());\n}\n\nexpr mk_empty() {\n    return mk_constant(get_empty_name());\n}\n\nbool is_false(expr const & e) {\n    return is_constant(e) && const_name(e) == get_false_name();\n}\n\nbool is_empty(expr const & e) {\n    return is_constant(e) && const_name(e) == get_empty_name();\n}\n\nexpr mk_false_rec(abstract_type_context & ctx, expr const & f, expr const & t) {\n    level t_lvl = get_level(ctx, t);\n    return mk_app(mk_constant(get_false_rec_name(), {t_lvl}), t, f);\n}\n\nbool is_or(expr const & e) {\n    return is_app_of(e, get_or_name(), 2);\n}\n\nbool is_or(expr const & e, expr & A, expr & B) {\n    if (is_or(e)) {\n        A = app_arg(app_fn(e));\n        B = app_arg(e);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool is_not(expr const & e, expr & a) {\n    if (is_app_of(e, get_not_name(), 1)) {\n        a = app_arg(e);\n        return true;\n    } else if (is_pi(e) && is_false(binding_body(e))) {\n        a = binding_domain(e);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool is_not_or_ne(expr const & e, expr & a) {\n    if (is_not(e, a)) {\n        return true;\n    } else if (is_app_of(e, get_ne_name(), 3)) {\n        buffer<expr> args;\n        expr const & fn = get_app_args(e, args);\n        expr new_fn     = mk_constant(get_eq_name(), const_levels(fn));\n        a               = mk_app(new_fn, args);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexpr mk_not(expr const & e) {\n    return mk_app(mk_constant(get_not_name()), e);\n}\n\nexpr mk_absurd(abstract_type_context & ctx, expr const & t, expr const & e, expr const & not_e) {\n    level t_lvl  = get_level(ctx, t);\n    expr  e_type = ctx.infer(e);\n    return mk_app(mk_constant(get_absurd_name(), {t_lvl}), e_type, t, e, not_e);\n}\n\nbool is_exists(expr const & e, expr & A, expr & p) {\n    if (is_app_of(e, get_exists_name(), 2)) {\n        A = app_arg(app_fn(e));\n        p = app_arg(e);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool is_exists(expr const & e) {\n    return is_app_of(e, get_exists_name(), 2);\n}\n\noptional<expr> get_binary_op(expr const & e) {\n    if (!is_app(e) || !is_app(app_fn(e)))\n        return none_expr();\n    return some_expr(app_fn(app_fn(e)));\n}\n\noptional<expr> get_binary_op(expr const & e, expr & arg1, expr & arg2) {\n    if (auto op = get_binary_op(e)) {\n        arg1 = app_arg(app_fn(e));\n        arg2 = app_arg(e);\n        return some_expr(*op);\n    } else {\n        return none_expr();\n    }\n}\n\nexpr mk_nary_app(expr const & op, buffer<expr> const & nary_args) {\n    return mk_nary_app(op, nary_args.size(), nary_args.data());\n}\n\nexpr mk_nary_app(expr const & op, unsigned num_nary_args, expr const * nary_args) {\n    lean_assert(num_nary_args >= 2);\n    // f x1 x2 x3 ==> f x1 (f x2 x3)\n    expr e = mk_app(op, nary_args[num_nary_args - 2], nary_args[num_nary_args - 1]);\n    for (int i = num_nary_args - 3; i >= 0; --i) {\n        e = mk_app(op, nary_args[i], e);\n    }\n    return e;\n}\n\nbool is_annotated_lamba(expr const & e) {\n    return\n        is_lambda(e) ||\n        (is_annotation(e) && is_lambda(get_nested_annotation_arg(e)));\n}\n\nbool is_annotated_head_beta(expr const & t) {\n    return is_app(t) && is_annotated_lamba(get_app_fn(t));\n}\n\nexpr annotated_head_beta_reduce(expr const & t) {\n    if (!is_annotated_head_beta(t)) {\n        return t;\n    } else {\n        buffer<expr> args;\n        expr f = get_app_rev_args(t, args);\n        if (is_annotation(f))\n            f = get_nested_annotation_arg(f);\n        lean_assert(is_lambda(f));\n        return annotated_head_beta_reduce(apply_beta(f, args.size(), args.data()));\n    }\n}\n\nexpr try_eta(expr const & e) {\n    if (is_lambda(e)) {\n        expr const & b = binding_body(e);\n        if (is_lambda(b)) {\n            expr new_b = try_eta(b);\n            if (is_eqp(b, new_b)) {\n                return e;\n            } else if (is_app(new_b) && is_var(app_arg(new_b), 0) && !has_loose_bvar(app_fn(new_b), 0)) {\n                return lower_loose_bvars(app_fn(new_b), 1);\n            } else {\n                return update_binding(e, binding_domain(e), new_b);\n            }\n        } else if (is_app(b) && is_var(app_arg(b), 0) && !has_loose_bvar(app_fn(b), 0)) {\n            return lower_loose_bvars(app_fn(b), 1);\n        } else {\n            return e;\n        }\n    } else {\n        return e;\n    }\n}\n\ntemplate<bool Eta, bool Beta>\nclass eta_beta_reduce_fn : public replace_visitor {\npublic:\n    virtual expr visit_app(expr const & e) override {\n        expr e1 = replace_visitor::visit_app(e);\n        if (Beta && is_head_beta(e1)) {\n            return visit(head_beta_reduce(e1));\n        } else {\n            return e1;\n        }\n    }\n\n    virtual expr visit_lambda(expr const & e) override {\n        expr e1 = replace_visitor::visit_lambda(e);\n        if (Eta) {\n            while (true) {\n                expr e2 = try_eta(e1);\n                if (is_eqp(e1, e2))\n                    return e1;\n                else\n                    e1 = e2;\n            }\n        } else {\n            return e1;\n        }\n    }\n};\n\nexpr beta_reduce(expr t) {\n    return eta_beta_reduce_fn<false, true>()(t);\n}\n\nexpr eta_reduce(expr t) {\n    return eta_beta_reduce_fn<true, false>()(t);\n}\n\nexpr beta_eta_reduce(expr t) {\n    return eta_beta_reduce_fn<true, true>()(t);\n}\n\nexpr infer_implicit_params(expr const & type, unsigned nparams, implicit_infer_kind k) {\n    switch (k) {\n    case implicit_infer_kind::Implicit: {\n        bool strict = true;\n        return infer_implicit(type, nparams, strict);\n    }\n    case implicit_infer_kind::RelaxedImplicit: {\n        bool strict = false;\n        return infer_implicit(type, nparams, strict);\n    }\n    }\n    lean_unreachable(); // LCOV_EXCL_LINE\n}\n\nstatic expr * g_bool = nullptr;\nstatic expr * g_bool_true = nullptr;\nstatic expr * g_bool_false = nullptr;\n\nvoid initialize_bool() {\n    g_bool = new expr(mk_constant(get_bool_name()));\n    g_bool_false = new expr(mk_constant(get_bool_false_name()));\n    g_bool_true = new expr(mk_constant(get_bool_true_name()));\n}\n\nvoid finalize_bool() {\n    delete g_bool;\n    delete g_bool_false;\n    delete g_bool_true;\n}\n\nexpr mk_bool() { return *g_bool; }\nexpr mk_bool_true() { return *g_bool_true; }\nexpr mk_bool_false() { return *g_bool_false; }\nexpr to_bool_expr(bool b) { return b ? mk_bool_true() : mk_bool_false(); }\n\nname get_dep_recursor(environment const &, name const & n) {\n    return name(n, g_rec);\n}\n\nname get_dep_cases_on(environment const &, name const & n) {\n    return name(n, g_cases_on);\n}\n\nstatic char const * g_unsafe_rec_prefix = \"_unsafe_rec\";\n\nname mk_unsafe_rec_name(name const & n) {\n    return name(n, g_unsafe_rec_prefix);\n}\n\noptional<name> is_unsafe_rec_name(name const & n) {\n    if (!n.is_atomic() && n.is_string() && n.get_string() == g_unsafe_rec_prefix) {\n        return optional<name>(n.get_prefix());\n    } else {\n        return optional<name>();\n    }\n}\n\noptional<name> name_lit_to_name(expr const & name_lit) {\n    if (is_constant(name_lit, get_lean_name_anonymous_name()))\n        return optional<name>(name());\n    if (is_app_of(name_lit, get_lean_name_str_name(), 2)) {\n        if (auto p   = name_lit_to_name(app_arg(app_fn(name_lit))))\n        if (auto str = to_string(app_arg(name_lit)))\n            return optional<name>(name(*p, str->c_str()));\n    }\n    if (is_app_of(name_lit, get_lean_name_num_name(), 2)) {\n        if (auto p = name_lit_to_name(app_arg(app_fn(name_lit))))\n        if (auto n = to_num(app_arg(name_lit)))\n            return optional<name>(name(*p, n->get_unsigned_int()));\n    }\n    return optional<name>();\n}\n\nstatic std::string * g_version_string = nullptr;\nstd::string const & get_version_string() { return *g_version_string; }\n\nexpr const & extract_mdata(expr const & e) {\n    if (is_mdata(e)) {\n        return extract_mdata(mdata_expr(e));\n    } else {\n        return e;\n    }\n}\n\noptional<expr> to_optional_expr(obj_arg o) {\n    if (is_scalar(o)) return none_expr();\n    optional<expr> r = some_expr(expr(cnstr_get(o, 0), true));\n    dec(o);\n    return r;\n}\n\nvoid initialize_library_util() {\n    g_unit           = new expr(mk_constant(get_unit_name()));\n    g_unit_mk        = new expr(mk_constant(get_unit_unit_name()));\n    g_true           = new expr(mk_constant(get_true_name()));\n    g_true_intro     = new expr(mk_constant(get_true_intro_name()));\n    g_and            = new expr(mk_constant(get_and_name()));\n    g_and_intro      = new expr(mk_constant(get_and_intro_name()));\n    g_and_left  = new expr(mk_constant(get_and_left_name()));\n    g_and_right = new expr(mk_constant(get_and_right_name()));\n    initialize_nat();\n    initialize_int();\n    initialize_char();\n    initialize_bool();\n\n    sstream out;\n\n    out << LEAN_VERSION_MAJOR << \".\"\n        << LEAN_VERSION_MINOR << \".\" << LEAN_VERSION_PATCH;\n    if (std::strlen(LEAN_SPECIAL_VERSION_DESC) > 0) {\n        out << \", \" << LEAN_SPECIAL_VERSION_DESC;\n    }\n    if (std::strcmp(LEAN_GITHASH, \"GITDIR-NOTFOUND\") == 0) {\n        if (std::strcmp(LEAN_PACKAGE_VERSION, \"NOT-FOUND\") != 0) {\n            out << \", package \" << LEAN_PACKAGE_VERSION;\n        }\n    } else {\n        out << \", commit \" << std::string(LEAN_GITHASH).substr(0, 12);\n    }\n    g_version_string = new std::string(out.str());\n\n    g_util_fresh = new name(\"_util_fresh\");\n    register_name_generator_prefix(*g_util_fresh);\n}\n\nvoid finalize_library_util() {\n    delete g_util_fresh;\n    delete g_version_string;\n    finalize_bool();\n    finalize_int();\n    finalize_nat();\n    finalize_char();\n    delete g_true;\n    delete g_true_intro;\n    delete g_and;\n    delete g_and_intro;\n    delete g_and_left;\n    delete g_and_right;\n    delete g_unit_mk;\n    delete g_unit;\n}\n}\n",
        "blame_info": {
            "leonardo@microsoft.com": [
                [
                    1,
                    24
                ],
                [
                    26,
                    107
                ],
                [
                    110,
                    1061
                ],
                [
                    1064,
                    1092
                ]
            ],
            "gebner@gebner.org": [
                [
                    25,
                    25
                ]
            ],
            "sebasti@nullri.ch": [
                [
                    108,
                    109
                ],
                [
                    1062,
                    1063
                ]
            ]
        }
    },
    {
        "blob_id": "694381b4055f06ae7dad5f6a5f7b6abd76cc1bb2",
        "directory_id": "4ca2b9af703d0a9066fdbf7ac45fd7c5f25a72ea",
        "path": "/proton-c/bindings/cpp/include/proton/codec/decoder.hpp",
        "content_id": "3dc6d570d2c4b11fdffda5c5c32b4e67cdd0ed71",
        "detected_licenses": [
            "Apache-2.0",
            "BSD-3-Clause"
        ],
        "license_type": "permissive",
        "repo_name": "gberginc/qpid-proton",
        "snapshot_id": "23847cc2a6b7014f021baff27089ea727bfa28e0",
        "revision_id": "9eaca615c5f5aa97d89d1b87471d81bff7237df0",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-16 17:58:30",
        "revision_date": "2017-08-10 12:27:43",
        "committer_date": "2017-08-10 12:27:43",
        "github_id": 100028035,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": "2017-08-11 12:13:02",
        "gha_created_at": "2017-08-11 12:13:02",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 7621,
        "extension": "hpp",
        "content": "#ifndef PROTON_CODEC_DECODER_HPP\n#define PROTON_CODEC_DECODER_HPP\n\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\n#include \"../internal/data.hpp\"\n#include \"../internal/type_traits.hpp\"\n#include \"../types_fwd.hpp\"\n#include \"./common.hpp\"\n\n#include <proton/type_compat.h>\n\n#include <utility>\n\nnamespace proton {\n\nclass annotation_key;\nclass message_id;\nclass scalar;\nclass value;\n\nnamespace internal {\nclass value_base;\n}\n\nnamespace codec {\n\n/// **Experimental** - Stream-like decoder from AMQP bytes to C++\n/// values.\n///\n/// For internal use only.\n///\n/// @see @ref types_page for the recommended ways to manage AMQP data\nclass decoder : public internal::data {\n  public:\n    /// Wrap a Proton C data object.  The exact flag if set means\n    /// decode only when there is an exact match between the AMQP and\n    /// C++ type. If not set then perform automatic conversions.\n    explicit decoder(const data& d, bool exact=false) : data(d), exact_(exact) {}\n\n    /// Attach decoder to a proton::value. The decoder is rewound to\n    /// the start of the data.\n    PN_CPP_EXTERN explicit decoder(const internal::value_base&, bool exact=false);\n\n    /// Decode AMQP data from a buffer and add it to the end of the\n    /// decoders stream.\n    PN_CPP_EXTERN void decode(const char* buffer, size_t size);\n\n    /// Decode AMQP data from a std::string and add it to the end of\n    /// the decoders stream.\n    PN_CPP_EXTERN void decode(const std::string&);\n\n    /// Return true if there are more value to extract at the current level.\n    PN_CPP_EXTERN bool more();\n\n    /// Get the type of the next value that will be read by\n    /// operator>>.\n    ///\n    /// @throw conversion_error if no more values. @see\n    /// decoder::more().\n    PN_CPP_EXTERN type_id next_type();\n\n    /// @name Extract built-in types\n    ///\n    /// @throw conversion_error if the decoder is empty or has an\n    /// incompatible type.\n    ///\n    /// @{\n    PN_CPP_EXTERN decoder& operator>>(bool&);\n    PN_CPP_EXTERN decoder& operator>>(uint8_t&);\n    PN_CPP_EXTERN decoder& operator>>(int8_t&);\n    PN_CPP_EXTERN decoder& operator>>(uint16_t&);\n    PN_CPP_EXTERN decoder& operator>>(int16_t&);\n    PN_CPP_EXTERN decoder& operator>>(uint32_t&);\n    PN_CPP_EXTERN decoder& operator>>(int32_t&);\n    PN_CPP_EXTERN decoder& operator>>(wchar_t&);\n    PN_CPP_EXTERN decoder& operator>>(uint64_t&);\n    PN_CPP_EXTERN decoder& operator>>(int64_t&);\n    PN_CPP_EXTERN decoder& operator>>(timestamp&);\n    PN_CPP_EXTERN decoder& operator>>(float&);\n    PN_CPP_EXTERN decoder& operator>>(double&);\n    PN_CPP_EXTERN decoder& operator>>(decimal32&);\n    PN_CPP_EXTERN decoder& operator>>(decimal64&);\n    PN_CPP_EXTERN decoder& operator>>(decimal128&);\n    PN_CPP_EXTERN decoder& operator>>(uuid&);\n    PN_CPP_EXTERN decoder& operator>>(std::string&);\n    PN_CPP_EXTERN decoder& operator>>(symbol&);\n    PN_CPP_EXTERN decoder& operator>>(binary&);\n    PN_CPP_EXTERN decoder& operator>>(message_id&);\n    PN_CPP_EXTERN decoder& operator>>(annotation_key&);\n    PN_CPP_EXTERN decoder& operator>>(scalar&);\n    PN_CPP_EXTERN decoder& operator>>(internal::value_base&);\n    PN_CPP_EXTERN decoder& operator>>(null&);\n    ///@}\n\n    /// Start decoding a container type, such as an ARRAY, LIST or\n    /// MAP.  This \"enters\" the container, more() will return false at\n    /// the end of the container.  Call finish() to \"exit\" the\n    /// container and move on to the next value.\n    PN_CPP_EXTERN decoder& operator>>(start&);\n\n    /// Finish decoding a container type, and move on to the next\n    /// value in the stream.\n    PN_CPP_EXTERN decoder& operator>>(const finish&);\n\n    /// @cond INTERNAL\n    template <class T> struct sequence_ref { T& ref; sequence_ref(T& r) : ref(r) {} };\n    template <class T> struct associative_ref { T& ref; associative_ref(T& r) : ref(r) {} };\n    template <class T> struct pair_sequence_ref { T& ref;  pair_sequence_ref(T& r) : ref(r) {} };\n\n    template <class T> static sequence_ref<T> sequence(T& x) { return sequence_ref<T>(x); }\n    template <class T> static associative_ref<T> associative(T& x) { return associative_ref<T>(x); }\n    template <class T> static pair_sequence_ref<T> pair_sequence(T& x) { return pair_sequence_ref<T>(x); }\n    /// @endcond\n\n    /// Extract any AMQP sequence (ARRAY, LIST or MAP) to a C++\n    /// sequence container of T if the elements types are convertible\n    /// to T. A MAP is extracted as `[key1, value1, key2, value2...]`.\n    template <class T> decoder& operator>>(sequence_ref<T> r)  {\n        start s;\n        *this >> s;\n        if (s.is_described) next();\n        r.ref.resize(s.size);\n        for (typename T::iterator i = r.ref.begin(); i != r.ref.end(); ++i)\n            *this >> *i;\n        return *this;\n    }\n\n    /// Extract an AMQP MAP to a C++ associative container\n    template <class T> decoder& operator>>(associative_ref<T> r)  {\n        using namespace internal;\n        start s;\n        *this >> s;\n        assert_type_equal(MAP, s.type);\n        r.ref.clear();\n        for (size_t i = 0; i < s.size/2; ++i) {\n            typename remove_const<typename T::key_type>::type k;\n            typename remove_const<typename T::mapped_type>::type v;\n            *this >> k >> v;\n            r.ref[k] = v;\n        }\n        return *this;\n    }\n\n    /// Extract an AMQP MAP to a C++ push_back sequence of pairs\n    /// preserving encoded order.\n    template <class T> decoder& operator>>(pair_sequence_ref<T> r)  {\n        using namespace internal;\n        start s;\n        *this >> s;\n        assert_type_equal(MAP, s.type);\n        r.ref.clear();\n        for (size_t i = 0; i < s.size/2; ++i) {\n            typedef typename T::value_type value_type;\n            typename remove_const<typename value_type::first_type>::type k;\n            typename remove_const<typename value_type::second_type>::type v;\n            *this >> k >> v;\n            r.ref.push_back(value_type(k, v));\n        }\n        return *this;\n    }\n\n  private:\n    type_id pre_get();\n    template <class T, class U> decoder& extract(T& x, U (*get)(pn_data_t*));\n    bool exact_;\n\n  friend class message;\n};\n\n/// @cond INTERNAL\n/// XXX Document this\ntemplate<class T> T get(decoder& d) {\n    assert_type_equal(internal::type_id_of<T>::value, d.next_type());\n    T x;\n    d >> x;\n    return x;\n}\n/// @endcond\n\n/// operator>> for integer types that are not covered by the standard\n/// overrides.\ntemplate <class T> typename internal::enable_if<internal::is_unknown_integer<T>::value, decoder&>::type\noperator>>(decoder& d, T& i)  {\n    using namespace internal;\n    typename integer_type<sizeof(T), is_signed<T>::value>::type v;\n    d >> v;                     // Extract as a known integer type\n    i = v;                      // C++ conversion to the target type.\n    return d;\n}\n\n} // codec\n} // proton\n\n#endif // PROTON_CODEC_DECODER_HPP\n",
        "blame_info": {
            "jross@apache.org": [
                [
                    1,
                    3
                ],
                [
                    5,
                    5
                ],
                [
                    22,
                    22
                ],
                [
                    47,
                    48
                ],
                [
                    50,
                    52
                ],
                [
                    55,
                    57
                ],
                [
                    60,
                    61
                ],
                [
                    64,
                    65
                ],
                [
                    68,
                    69
                ],
                [
                    75,
                    79
                ],
                [
                    83,
                    86
                ],
                [
                    115,
                    118
                ],
                [
                    121,
                    122
                ],
                [
                    125,
                    125
                ],
                [
                    133,
                    133
                ],
                [
                    135,
                    137
                ],
                [
                    148,
                    148
                ],
                [
                    190,
                    191
                ],
                [
                    198,
                    198
                ],
                [
                    200,
                    201
                ],
                [
                    213,
                    214
                ]
            ],
            "aconway@redhat.com": [
                [
                    4,
                    4
                ],
                [
                    6,
                    21
                ],
                [
                    23,
                    24
                ],
                [
                    29,
                    29
                ],
                [
                    32,
                    39
                ],
                [
                    42,
                    42
                ],
                [
                    44,
                    46
                ],
                [
                    49,
                    49
                ],
                [
                    54,
                    54
                ],
                [
                    58,
                    59
                ],
                [
                    63,
                    63
                ],
                [
                    66,
                    67
                ],
                [
                    70,
                    74
                ],
                [
                    80,
                    82
                ],
                [
                    87,
                    110
                ],
                [
                    112,
                    114
                ],
                [
                    119,
                    120
                ],
                [
                    123,
                    124
                ],
                [
                    126,
                    132
                ],
                [
                    134,
                    134
                ],
                [
                    138,
                    147
                ],
                [
                    149,
                    187
                ],
                [
                    189,
                    189
                ],
                [
                    192,
                    197
                ],
                [
                    199,
                    199
                ],
                [
                    202,
                    212
                ]
            ],
            "astitcher@apache.org": [
                [
                    25,
                    28
                ],
                [
                    30,
                    31
                ],
                [
                    53,
                    53
                ],
                [
                    188,
                    188
                ]
            ],
            "cliffjansen@apache.org": [
                [
                    40,
                    41
                ],
                [
                    43,
                    43
                ],
                [
                    62,
                    62
                ],
                [
                    111,
                    111
                ]
            ]
        }
    },
    {
        "blob_id": "e58b6df0e5b4c66f0d095c33c45ddcbea6ffceae",
        "directory_id": "9929f9f832b21f641f41fc91cbf604643f9770dd",
        "path": "/src/txt/mainRegressionP.cpp",
        "content_id": "16ad10a2e0e2cf8996b46a19dd9d38b275156452",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "JeanSar/rogue",
        "snapshot_id": "1cd4d8d18fe8ae6ba7d32f3af556259f5a65b2fc",
        "revision_id": "a4c8945a8ae09984a4b417a3bac5ffd029e46fa7",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-03-01 01:24:12",
        "revision_date": "2021-01-28 19:53:17",
        "committer_date": "2021-01-28 19:53:17",
        "github_id": 331929934,
        "star_events_count": 2,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1062,
        "extension": "cpp",
        "content": "#include \"Personnages.h\"\n\nusing namespace std;\n\nint main(){\n  srand(time(NULL));\n  int ok = 0;\n  Hero* h = new Hero(\"Player\");\n  Ennemi* e = new Ennemi(4);\n  cout << \"Hero : \" << h->getName() << endl\n    << \"x : \" << h->getX() << endl\n    << \"y : \" << h->getY() << endl\n    << \"pv : \" << h->getPv() << endl\n    << \"lv : \" << h->getLv() << endl\n    << \"atk : \" << h->getAtk() << endl\n    << \"def : \" << h->getDef() << \"\\n\\n\"\n    << \"Ennemi :\" << endl\n    << \"x : \" << e->getX() << endl\n    << \"y : \" << e->getY() << endl\n    << \"pv : \" << e->getPv() << endl\n    << \"lv : \" << e->getLv() << endl\n    << \"atk : \" << e->getAtk() << endl\n    << \"def : \" << e->getDef() << \"\\n\\n\";\n  assert(ok == h->lvUp());\n  cout << \"lv : \"  << h->getLv() << endl\n    << \"atk : \" << h->getAtk() << endl\n    << \"def : \" << h->getDef() << endl;\n  assert(ok == h->combat(e));\n  cout << \"Ennemie - pv : \" << e->getPv() << endl;\n  assert(ok == h->setName(\"Terrine\"));\n  assert(ok == e->combat(h));\n  cout << h->getName() << \" - pv : \" << h->getPv();\n  delete e;\n  delete h;\n  return 0;\n}\n",
        "blame_info": {
            "=": [
                [
                    1,
                    36
                ]
            ]
        }
    },
    {
        "blob_id": "bc04402f98f0dfbab1312618df94c4703378e069",
        "directory_id": "41c46297d9303f54fb390050f550379649313979",
        "path": "/\uce74\ub4dc\ub193\uae30.cpp",
        "content_id": "aa02d0885de65c301b7c8a79689e95c3c4acf687",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "SketchAlgorithm/17_Jo-Wonbin",
        "snapshot_id": "f48d6c51026d08bd4eeb13448e35d8566660ad40",
        "revision_id": "75231bf4a0fb62518f687c62c752f5efb7c49478",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-04-23 00:30:30",
        "revision_date": "2020-02-18 09:02:46",
        "committer_date": "2020-02-18 09:02:46",
        "github_id": 170782242,
        "star_events_count": 1,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 692,
        "extension": "cpp",
        "content": "#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nbool cache[10000000];\r\nint arr[11];\r\nint n, k;\r\n\r\nint travel(int depth, int num, int use) {\r\n\tif (depth > k) {\r\n\t\treturn false;\r\n\t}\r\n\tint ret = cache[num] == false;\r\n\tcache[num] = true;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tif (!(use ^ (1 << i))) continue;\r\n\t\tif (arr[i] >= 10) ret += travel(depth + 1, num * 100 + arr[i], use | (1 << i));\r\n\t\telse ret += travel(depth + 1, num * 10 + arr[i], use | (1 << i));\r\n\t}\r\n\treturn ret;\r\n\t\r\n}\r\n\r\nint main() {\r\n\tcin >> n >> k;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tcin >> arr[i];\r\n\t}\r\n\tcout << travel(0, 0, 0) << endl;\r\n\t/*for (int i = 0; i < 100000000; i++) {\r\n\t\tif (cache[i] == true) cout << i << endl;\r\n\t}*/\r\n}",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    33
                ]
            ]
        }
    },
    {
        "blob_id": "aad85aa770183929d8ccd9df0aacf59df35f147f",
        "directory_id": "465a87bdead9aee133a7b36b0c2e826ece517cbb",
        "path": "/ARStudy(Image processing)/ARStudy/main.cpp",
        "content_id": "5ebb0f7ee747397046be8ca1b609d9d04b460e5c",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "kshy9598/ARStudy",
        "snapshot_id": "a5b55f3808d1e64cc96ee3e9266e4f4c23c3d611",
        "revision_id": "c55ce51cb595f677eb07549203d0032430a90aef",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-06-29 05:20:21",
        "revision_date": "2016-12-08 16:22:03",
        "committer_date": "2016-12-08 16:22:03",
        "github_id": 74446922,
        "star_events_count": 0,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UHC",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 4927,
        "extension": "cpp",
        "content": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include \"opencv2\\highgui\\highgui.hpp\"\n#include \"opencv2\\opencv.hpp\"\n\n#pragma comment(lib, \"opencv_world300d.lib\")\n\nconst double PI = 3.14159265;\n\nusing namespace std;\nusing namespace cv;\n\nbool bLBDown = false; // \ub9c8\uc6b0\uc2a4 \ubc84\ud2bc \ub20c\ub800\ub294\uc9c0 \uccb4\ud06c\nbool checkDrag; // \ub4dc\ub798\uadf8\uac00 \uc774\ub8e8\uc5b4\uc84c\ub294\uc9c0 \uccb4\ud06c\nCvRect box; // \ub4dc\ub798\uadf8\ub85c \uadf8\ub9b0 \ubc15\uc2a4\n\n// \uc0ac\uac01\ud615 \uadf8\ub9ac\uae30\nvoid draw_box(IplImage* img, CvRect rect)\n{\n\tcvRectangle(img, cvPoint(rect.x, rect.y),\n\t\tcvPoint(rect.x + rect.width, rect.y + rect.height),\n\t\tcvScalar(0xff, 0x00, 0x00));\n}\n\n// \ub9c8\uc6b0\uc2a4 \ub4dc\ub798\uadf8\nvoid on_mouse(int event, int x, int y, int flag, void* params)\n{\n\tIplImage* image = (IplImage*)params;\n\n\tif (event == CV_EVENT_LBUTTONDOWN){ // \uc67c\ucabd \ubc84\ud2bc \ub20c\ub800\uc744 \uc2dc, \ubc15\uc2a4 \ucd08\uae30\ud654\n\t\tbLBDown = true;\n\t\tbox = cvRect(x, y, 0, 0);\n\t}\n\telse if (event == CV_EVENT_LBUTTONUP){ // \uc67c\ucabd \ubc84\ud2bc \ub20c\ub800\ub2e4\uac00 \ub5d0\uc744 \ub54c, \ubc15\uc2a4\uc758 \ub113\uc774, \ub192\uc774\ub97c \uc124\uc815\ud55c\ub2e4.\n\t\tbLBDown = false;\n\t\tcheckDrag = true;\n\t\tif (box.width < 0)\n\t\t{\n\t\t\tbox.x += box.width;\n\t\t\tbox.width *= -1;\n\t\t}\n\t\tif (box.height < 0)\n\t\t{\n\t\t\tbox.y += box.height;\n\t\t\tbox.height *= -1;\n\t\t}\n\t\tdraw_box(image, box);\n\t} \n\telse if (event == CV_EVENT_MOUSEMOVE && bLBDown){ // \ub4dc\ub798\uadf8 \uc911\uc5d0\ub294 \ubc15\uc2a4\uc758 \ub113\uc774, \ub192\uc774\ub97c \uac31\uc2e0\ud55c\ub2e4.\n\t\tbox.width = x - box.x;\n\t\tbox.height = y - box.y;\n\t}\n}\n\n// \uc774\ubbf8\uc9c0 \ubcf5\uc0ac\nMat copyMat(Mat source)\n{\n\t// source\uc758 Mat\uc744 result\ub85c \ubcf5\uc0ac\ud558\ub294 \uc791\uc5c5\n\t// opencv\uc5d0 \uc774\ubbf8 \uad6c\ud604\uc774 \ub418\uc5b4\uc788\ub294 \uc791\uc5c5\uc774\ub2e4.\n\t// source.copyTo(result);\n\tMat result = Mat::zeros(source.size(), source.type());\n\tfor (int i = 0; i < source.cols; i++){\n\t\tfor (int j = 0; j < source.rows; j++){\n\t\t\tresult.at<Vec3b>(j, i) = source.at<Vec3b>(j, i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// \ubc15\uc2a4\ub0b4 \uc774\ubbf8\uc9c0 \ubcf5\uc0ac\nMat copyBoxMat(Mat source)\n{\n\treturn source(box);\n}\n\n// y\ucd95\ubc18\uc804\nMat yReflecting(Mat source)\n{\n\tMat result = copyMat(source);\n\n\tfor (int i = 0; i < box.width; i++){\n\t\tfor (int j = 0; j < box.height; j++){\n\t\t\tresult.at<Vec3b>((box.y + j), (box.x + i)) = source.at<Vec3b>(box.y + j, (box.width + box.x - 1) - i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// x\ucd95\ubc18\uc804\nMat xReflecting(Mat source)\n{\n\tMat result = copyMat(source);\n\n\tfor (int i = 0; i < box.width; i++){\n\t\tfor (int j = 0; j < box.height; j++){\n\t\t\tresult.at<Vec3b>((box.y + j), (box.x + i)) = source.at<Vec3b>((box.height + box.y - 1) - j, (box.x + i));\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// \ud68c\uc804\nMat rotating(Mat source, double degree)\n{\n\tMat result = copyMat(source);\n\n\tint x0 = box.x + (box.width / 2);\n\tint y0 = box.y + (box.height / 2);\n\tdouble cosd = cos(degree*PI / 180);\n\tdouble sind = sin(degree*PI / 180);\n\t\n\t// \uc6d0\ubcf8\uc5d0 \ub36e\uc5b4\uc50c\uc6b0\ub294 \ubd80\ubd84\uc73c\ub85c \uc778\ud574 \uc67c\ucabd 90\ub3c4, \uc624\ub978\ucabd 90\ub3c4\ub9cc \uac00\ub2a5\n\tfor (int i = 0; i < box.width; i++){\n\t\tfor (int j = 0; j < box.height; j++){\n\t\t\tint x1 = (box.x + i);\n\t\t\tint y1 = (box.y + j);\n\t\t\tint x = ((cosd * (x1 - x0)) - (sind * (y1 - y0)) + x0);\n\t\t\tint y = ((sind * (x1 - x0)) - (cosd * (y1 - y0)) + y0);\n\t\t\tresult.at<Vec3b>(y, x) = source.at<Vec3b>((box.y + j), (box.x + i));\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// \ud655\ub300\nMat scaling(Mat source, Mat boxMat, double scale)\n{\n\tMat result = copyMat(source);\n\tMat scaleBoxMat;\n\n\t// \uc0ac\uac01\ud615 \uc548\uc758 Mat\uc758 \ud06c\uae30\ub97c scale\ubc30 \ub298\ub9b0\ub2e4.\n\tint boxWidth = (int)(boxMat.size().width * scale);\n\tint boxHeight = (int)(boxMat.size().height * scale);\n\tcv::resize(boxMat, scaleBoxMat, Size(boxWidth, boxHeight));\n\n\t// \ubd99\uc5ec\ub123\uc744 \ub54c \uc2dc\uc791 \uc704\uce58 \uc815\ubcf4\ub97c \uac31\uc2e0\ud55c\ub2e4.\n\tint x = box.x - (box.width / 2);\n\tint y = box.y - (box.height / 2);\n\n\tfor (int i = 0; i < boxWidth; i++){\n\t\tfor (int j = 0; j < boxHeight; j++){\n\t\t\tresult.at<Vec3b>((y + j), (x + i)) = scaleBoxMat.at<Vec3b>(j, i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint main()\n{\n\tIplImage copy;\n\tIplImage * resultImage;\n\tMat resultMat, xReflectMat, yReflectMat, leftRotateMat, scaleMat, boxMat;\n\n\t// \uc774\ubbf8\uc9c0 \ubd88\ub7ec\uc624\uae30\n    Mat gMatImage = imread(\"./picture/pic.jpg\", 1);\n\n\t// Mat \uc774\ubbf8\uc9c0\ub97c IplImage \ub85c \ubcf5\uc0ac\ud55c\ub2e4.\n\tcopy = gMatImage;\n\tresultImage = &copy;\n\n\n\tcheckDrag = false;\n\tnamedWindow(\"image\");\n\tsetMouseCallback(\"image\", on_mouse, resultImage);\n\tcvShowImage(\"image\", resultImage);\n\n\t//\ub4dc\ub798\uadf8 \ub300\uae30\n\twhile (!checkDrag){\n\t\twaitKey(100);\n\t}\n\tcvShowImage(\"image\", resultImage);\n\n\t//\uc0ac\uac01\ud615 \ucd94\uac00\ub41c \uc0ac\uc9c4 \uc800\uc7a5\n\tresultMat = cvarrToMat(resultImage);\n\tboxMat = copyBoxMat(resultMat);\n\n\tcout << box.x << ' ' << box.y << ' ' << box.width << ' ' << box.height << endl;\n\n\tyReflectMat = yReflecting(resultMat); // y\ucd95 \ubc18\uc804\n\txReflectMat = xReflecting(resultMat); // x\ucd95 \ubc18\uc804\n\tscaleMat = scaling(resultMat, boxMat, 1.5); // \ud06c\uae30 \ubcc0\uacbd\n\tleftRotateMat = rotating(resultMat, -90.0); // 90\ub3c4 \ud68c\uc804\n\n\twaitKey(2000);\n\timshow(\"y\ubc18\uc804 \uc774\ubbf8\uc9c0\", yReflectMat);\n\timshow(\"x\ubc18\uc804 \uc774\ubbf8\uc9c0\", xReflectMat);\n\timshow(\"\uc67c\ucabd 90\ub3c4 \ud68c\uc804 \uc774\ubbf8\uc9c0\", leftRotateMat);\n\timshow(\"1.5\ubc30 \ud655\ub300 \uc774\ubbf8\uc9c0\", scaleMat);\n\n\twaitKey(0);\n\n\treturn 0;\n}",
        "blame_info": {
            "kshy9598@naver.com": [
                [
                    1,
                    200
                ]
            ]
        }
    },
    {
        "blob_id": "ec7e8136fddc2e555eaec77bf3b6ebf38fe22ba3",
        "directory_id": "55cda2ebcfd995b9cf0c2eb4bb17b695bd24a6d1",
        "path": "/examples/Noise/Noise.ino",
        "content_id": "796a0b76fdc7b14e30b0309a436bd0acaa283c35",
        "detected_licenses": [
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "FastLED/FastLED",
        "snapshot_id": "744ae7eda80a8d4ab83ff87b42f3a65279535569",
        "revision_id": "2874c7c8eb13d99ec4ad9a3201054c387d2d8aaa",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-09-05 12:37:27",
        "revision_date": "2023-09-03 16:23:51",
        "committer_date": "2023-09-03 16:23:51",
        "github_id": 14268809,
        "star_events_count": 5936,
        "fork_events_count": 1779,
        "gha_license_id": "MIT",
        "gha_event_created_at": "2023-09-09 22:52:09",
        "gha_created_at": "2013-11-10 01:41:14",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 3390,
        "extension": "ino",
        "content": "/// @file    Noise.ino\n/// @brief   Demonstrates how to use noise generation on a 2D LED matrix\n/// @example Noise.ino\n\n#include <FastLED.h>\n\n//\n// Mark's xy coordinate mapping code.  See the XYMatrix for more information on it.\n//\n\n// Params for width and height\nconst uint8_t kMatrixWidth = 16;\nconst uint8_t kMatrixHeight = 16;\n\n#define MAX_DIMENSION ((kMatrixWidth>kMatrixHeight) ? kMatrixWidth : kMatrixHeight)\n#define NUM_LEDS (kMatrixWidth * kMatrixHeight)\n\n// Param for different pixel layouts\nconst bool    kMatrixSerpentineLayout = true;\n\n\nuint16_t XY( uint8_t x, uint8_t y)\n{\n  uint16_t i;\n\n  if( kMatrixSerpentineLayout == false) {\n    i = (y * kMatrixWidth) + x;\n  }\n\n  if( kMatrixSerpentineLayout == true) {\n    if( y & 0x01) {\n      // Odd rows run backwards\n      uint8_t reverseX = (kMatrixWidth - 1) - x;\n      i = (y * kMatrixWidth) + reverseX;\n    } else {\n      // Even rows run forwards\n      i = (y * kMatrixWidth) + x;\n    }\n  }\n\n  return i;\n}\n\n// The leds\nCRGB leds[kMatrixWidth * kMatrixHeight];\n\n// The 32bit version of our coordinates\nstatic uint16_t x;\nstatic uint16_t y;\nstatic uint16_t z;\n\n// We're using the x/y dimensions to map to the x/y pixels on the matrix.  We'll\n// use the z-axis for \"time\".  speed determines how fast time moves forward.  Try\n// 1 for a very slow moving effect, or 60 for something that ends up looking like\n// water.\n// uint16_t speed = 1; // almost looks like a painting, moves very slowly\nuint16_t speed = 20; // a nice starting speed, mixes well with a scale of 100\n// uint16_t speed = 33;\n// uint16_t speed = 100; // wicked fast!\n\n// Scale determines how far apart the pixels in our noise matrix are.  Try\n// changing these values around to see how it affects the motion of the display.  The\n// higher the value of scale, the more \"zoomed out\" the noise iwll be.  A value\n// of 1 will be so zoomed in, you'll mostly see solid colors.\n\n// uint16_t scale = 1; // mostly just solid colors\n// uint16_t scale = 4011; // very zoomed out and shimmery\nuint16_t scale = 311;\n\n// This is the array that we keep our computed noise values in\nuint16_t noise[MAX_DIMENSION][MAX_DIMENSION];\n\nvoid setup() {\n  // uncomment the following lines if you want to see FPS count information\n  // Serial.begin(38400);\n  // Serial.println(\"resetting!\");\n  delay(3000);\n  FastLED.addLeds<WS2811,2,RGB>(leds,NUM_LEDS);\n  FastLED.setBrightness(96);\n\n  // Initialize our coordinates to some random values\n  x = random16();\n  y = random16();\n  z = random16();\n}\n\n// Fill the x/y array of 8-bit noise values using the inoise8 function.\nvoid fillnoise8() {\n  for(int i = 0; i < MAX_DIMENSION; i++) {\n    int ioffset = scale * i;\n    for(int j = 0; j < MAX_DIMENSION; j++) {\n      int joffset = scale * j;\n      noise[i][j] = inoise8(x + ioffset,y + joffset,z);\n    }\n  }\n  z += speed;\n}\n\n\nvoid loop() {\n  static uint8_t ihue=0;\n  fillnoise8();\n  for(int i = 0; i < kMatrixWidth; i++) {\n    for(int j = 0; j < kMatrixHeight; j++) {\n      // We use the value at the (i,j) coordinate in the noise\n      // array for our brightness, and the flipped value from (j,i)\n      // for our pixel's hue.\n      leds[XY(i,j)] = CHSV(noise[j][i],255,noise[i][j]);\n\n      // You can also explore other ways to constrain the hue used, like below\n      // leds[XY(i,j)] = CHSV(ihue + (noise[j][i]>>2),255,noise[i][j]);\n    }\n  }\n  ihue+=1;\n\n  FastLED.show();\n  // delay(10);\n}\n",
        "blame_info": {
            "dmadison@users.noreply.github.com": [
                [
                    1,
                    4
                ]
            ],
            "danielgarcia@gmail.com": [
                [
                    5,
                    11
                ],
                [
                    21,
                    22
                ],
                [
                    24,
                    27
                ],
                [
                    29,
                    38
                ],
                [
                    40,
                    76
                ],
                [
                    78,
                    83
                ],
                [
                    86,
                    121
                ],
                [
                    123,
                    124
                ]
            ],
            "z@zackees.com": [
                [
                    12,
                    16
                ],
                [
                    19,
                    19
                ]
            ],
            "marmilicious@users.noreply.github.com": [
                [
                    17,
                    18
                ],
                [
                    20,
                    20
                ],
                [
                    23,
                    23
                ],
                [
                    28,
                    28
                ],
                [
                    39,
                    39
                ],
                [
                    77,
                    77
                ],
                [
                    84,
                    85
                ],
                [
                    122,
                    122
                ]
            ]
        }
    },
    {
        "blob_id": "b8319da5f12cfbbbd8ce6c9a50bab4c69b92531e",
        "directory_id": "c4a320a9519cd63bad9be9bcfc022a4fcab5267b",
        "path": "/TETRIS_VS/TETRIS_VS/LobbyBoard.cpp",
        "content_id": "4e7ef9e1f59c43158f02345d8f894a183007f43e",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "shield1203/TETRIS_VS",
        "snapshot_id": "79dc3d8db0a1107352e46e69a96482a49490a290",
        "revision_id": "3f67f0436674a10f9d37a98286a1f3531e6f7730",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-12-22 00:11:37",
        "revision_date": "2020-03-05 15:28:32",
        "committer_date": "2020-03-05 15:28:32",
        "github_id": 236593352,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 401,
        "extension": "cpp",
        "content": "#include \"stdafx.h\"\n#include \"LobbyBoard.h\"\n\n#include \"InputSystem.h\"\n#include \"PacketManager.h\"\n\nLobbyBoard::LobbyBoard()\n{\n\tm_packetManager = PacketManager::getInstance();\n\tm_inputSystem = new InputSystem();\n}\n\nLobbyBoard::~LobbyBoard()\n{\n\tSafeDelete(m_inputSystem);\n}\n\nvoid LobbyBoard::Update()\n{\n\tm_inputSystem->CheckKeyboardPressed();\n\n\tif (m_inputSystem->IsEnterPressed())\n\t{\n\t\tm_on = true;\n\t}\n}",
        "blame_info": {
            "57628185+shield1203@users.noreply.github.com": [
                [
                    1,
                    26
                ]
            ]
        }
    },
    {
        "blob_id": "6121382505592535a09b239e90ed50ff680fc2e6",
        "directory_id": "91fcb836ee5af301a2125624ddb96cf49b19494d",
        "path": "/queue/restoreQueue.cpp",
        "content_id": "2e49fc23784e34f26b2deade801fe414d1b21cb1",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "hellozxs/C",
        "snapshot_id": "fe11911222595ffcdc425218407711bbe59a3b10",
        "revision_id": "1f3815966a8d5668f149ff9957672819a2d2b57d",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-04-06 07:03:14",
        "revision_date": "2016-09-18 10:25:27",
        "committer_date": "2016-09-18 10:25:27",
        "github_id": 65121708,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1272,
        "extension": "cpp",
        "content": "//\u5bf9\u4e00\u4e2a\u961f\u5217\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\u540e\uff0c\u53d1\u73b0\u8f93\u51fa\u4e3a 1\uff0c2\uff0c3\uff0c4\uff0c\u2026\u2026,n\r\n//    \u64cd\u4f5c\uff1a\uff08\u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff09\r\n//    1\uff1a\u53d6\u961f\u5934\u5143\u7d20\uff0c\u653e\u5165\u961f\u5c3e\uff0c\u5c06\u961f\u5934pop\r\n//    2\uff1b\u8f93\u51fa\u961f\u5934\uff0c\u5c06\u961f\u5934pop\r\n//  \u8f93\u5165n\uff0c\u6c42\u539f\u59cb\u961f\u5217\uff1f\r\n//\r\n//\u8f93\u5165\uff1az -> \u8868\u793a\u5c06\u8981\u8f93\u5165\u7684\u6570\u636e\u7684\u4e2a\u6570\r\n//\u8f93\u5165z\u4e2an\u7684\u5177\u4f53\u503c\r\n\r\n\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n\r\ntypedef struct MyData\r\n{\r\n\tint _data;\r\n\tbool _flag;\r\n\r\n}MyData;\r\n\r\n\r\nint main()\r\n{\r\n\tint z;\r\n\tcin >> z;\r\n\tvector<int> arr(z);\r\n\tfor (int i = 0; i < z; i++)\r\n\t{\r\n\t\tcin >> arr[i];\r\n\t}\r\n\r\n\tint i = 0;\r\n\tfor (i = 0; i< z; i++)\r\n\t{\r\n\t\tif (arr[i] == 1)\r\n\t\t\tcout << 1 << endl;\r\n\t\telse\r\n\t\t{\r\n\t\t\tvector<MyData> a(arr[i]);\r\n\t\t\tint j = 0;\r\n\t\t\tint count = arr[i];\r\n\t\t\tint tmp = 1;\r\n\t\t\tfor (; count--; j ++)\r\n\t\t\t{\r\n\t\t\t\tint flag = 1;\r\n\t\t\t\twhile (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (j == arr[i])\r\n\t\t\t\t\t\tj = 0;\r\n\t\t\t\t\tif (a[j]._flag == false)\r\n\t\t\t\t\t\tflag--;\r\n\t\t\t\t\tj++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (j == arr[i])\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\twhile (a[j]._flag == true)\r\n\t\t\t\t{\r\n\t\t\t\t\tj++;\r\n\t\t\t\t\tif (j == arr[i])\r\n\t\t\t\t\t\tj = 0;\r\n\r\n\t\t\t\t}\r\n\t\t\t\ta[j]._data =tmp++;\r\n\t\t\t\ta[j]._flag = true;\r\n\t\t\t}\r\n\r\n\t\t\tint k = 0;\r\n\t\t\tfor (; k < arr[i]; k++)\r\n\t\t\t\tcout << a[k]._data << \" \";\r\n\t\t\tcout << endl;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn 0;\r\n}\r\n",
        "blame_info": {
            "526591420@qq.com": [
                [
                    1,
                    81
                ]
            ]
        }
    },
    {
        "blob_id": "bba7327fa47b292b7a2a12379dbea888640a0e70",
        "directory_id": "58790459d953a3e4b6722ed3ee939f82d9de8c3e",
        "path": "/my/PDF\u63d2\u4ef6/sdkDC_v1_win/Adobe/Acrobat DC SDK/Version 1/PluginSupport/PIBrokerSDK/simple-ipc-lib/src/pipe_win.h",
        "content_id": "4625bef0dc76752fdcc7b3a4966d087839cbd12f",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "tisn05/VS",
        "snapshot_id": "bb84deb993eb18d43d8edaf81afb753afa3d3188",
        "revision_id": "da56d392a518ba21edcb1a367b4b4378d65506f0",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-09-25 05:49:31",
        "revision_date": "2016-08-22 01:22:16",
        "committer_date": "2016-08-22 01:22:16",
        "github_id": 66229337,
        "star_events_count": 0,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1659,
        "extension": "h",
        "content": "// Copyright (c) 2010 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef SIMPLE_IPC_PIPE_WIN_H_\n#define SIMPLE_IPC_PIPE_WIN_H_\n\n#include \"os_includes.h\"\n#include \"ipc_constants.h\"\n\nclass PipePair {\npublic:\n\tPipePair(bool inherit_fd2 = false);\n\tHANDLE fd1() const { return srv_; }\n\tHANDLE fd2() const { return cln_; }\n\n\tstatic HANDLE OpenPipeServer(const wchar_t* name, bool low_integrity = false);\n\tstatic HANDLE OpenPipeClient(const wchar_t* name, bool inherit, bool impersonate);\n\nprivate:\n\tHANDLE srv_;\n\tHANDLE cln_;\n};\n\nclass PipeWin {\npublic:\n\tPipeWin();\n\t~PipeWin();\n\n\tbool OpenClient(HANDLE pipe);\n\tbool OpenServer(HANDLE pipe, bool connect = false);\n\n\tbool Write(const void* buf, size_t sz);\n\tbool Read(void* buf, size_t* sz);\n\n\tbool IsConnected() const { return INVALID_HANDLE_VALUE != pipe_; }\n\nprivate:\n\tHANDLE pipe_;\n};\n\n\nclass PipeTransport : public PipeWin {\npublic:\n\tstatic const size_t kBufferSz = 4096;\n\n\tsize_t Send(const void* buf, size_t sz) {\n\t\treturn Write(buf, sz) ? ipc::RcOK : ipc::RcErrTransportWrite;\n\t}\n\n\tchar* Receive(size_t* size);\n\nprivate:\n\tIPCCharVector buf_;\n};\n\n#endif  // SIMPLE_IPC_PIPE_WIN_H_\n",
        "blame_info": {
            "tisn05@gmail.com": [
                [
                    1,
                    67
                ]
            ]
        }
    },
    {
        "blob_id": "819eb928fa03acd974c3e18443532022f13c2f05",
        "directory_id": "711b11d08abdb3a7df2574b0b4c86af21c5c6750",
        "path": "/dest.h",
        "content_id": "e06af74e0264187915ab70b86b0e67aa85d2a79f",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "nflath/MSP430Emulator",
        "snapshot_id": "4aee9e093113cc41d9041a1728eedd742fd786b2",
        "revision_id": "a97a1b97b895b3533597bcdb69bec8b75db395df",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-13 01:54:55",
        "revision_date": "2015-08-25 05:10:04",
        "committer_date": "2015-08-25 05:10:04",
        "github_id": 41343926,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 2382,
        "extension": "h",
        "content": "#include <assert.h>\n#ifndef DEST_H\n#define DEST_H\n#include \"error.h\"\n\n// Classes representing 'Destinations' types in MSP430 - See the section\n// 'MSP430 addressing modes' in https://en.wikipedia.org/wiki/TI_MSP430#MSP430_CPU\n\nclass State;\n\nclass Dest {\n  // Virtual base clase.\n public:\n  virtual void set(short value) { notimplemented(); }\n  // Sets the value of this destination\n\n  virtual void setByte(unsigned char value) { notimplemented(); }\n  // Sets the value of this destination (byte addressing mode)\n\n  virtual short value() { notimplemented(); return 0;}\n  // Returns the value of this destination\n\n  virtual unsigned char valueByte() { notimplemented(); return 0;}\n  // Returns the value of this destination(byte addressing mode)\n\n  virtual std::string toString() = 0;\n  // Returns a string representation of this destination\n\n  virtual bool usedExtensionWord() { return false; }\n  // Whether an extension word was used to represent this destination\n\n  virtual unsigned char size() { return usedExtensionWord() ? 2 : 0; }\n  // How many extra bytes this destination took up in the assembly\n};\n\nclass RegisterDest : public Dest {\n  // Destination representing a register (r14)\n public:\n\n  virtual std::string toString();\n\n  virtual void set(short value);\n  virtual void setByte(unsigned char value);\n  virtual short value();\n  virtual unsigned char valueByte();\n\n  RegisterDest(unsigned short reg_) : reg(reg_) {}\n\n  unsigned short reg;\n};\n\nclass RegisterOffsetDest : public RegisterDest {\n  // Destination representing the memory address at a register plus an offset (0x40(r14))\n public:\n  virtual std::string toString();\n  virtual bool usedExtensionWord() { return true; }\n  virtual void set(short value);\n  virtual void setByte(unsigned char value);\n  virtual short value();\n  virtual unsigned char valueByte();\n\n RegisterOffsetDest(unsigned short reg_, short offset_) :\n   RegisterDest(reg_),\n    offset(offset_) {\n }\n\n  short offset;\n};\n\nclass AbsoluteDest : public Dest {\n  // Destination that is just a memory address (&0x4400)\n public:\n  virtual std::string toString();\n  virtual bool usedExtensionWord() { return true; }\n  virtual void set(short value);\n  virtual void setByte(unsigned char value);\n\n  virtual unsigned char valueByte();\n\n AbsoluteDest(unsigned short address_) :\n  address(address_) {\n  }\n\n  unsigned short address;\n};\n\nextern State* s;\n\n#endif\n",
        "blame_info": {
            "flat0103@gmail.com": [
                [
                    1,
                    89
                ]
            ]
        }
    },
    {
        "blob_id": "8a96e354acf08b5427cf3791a514286b61b32365",
        "directory_id": "ddbc8b916e028cf70467928d3be17506713baeff",
        "path": "/src/Setup/unzip.cpp",
        "content_id": "c2b062c3bb714c756f317e2995e1129180774b39",
        "detected_licenses": [
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "Squirrel/Squirrel.Windows",
        "snapshot_id": "e7687f81ae08ebf6f4b6005ed8394f78f6c9c1ad",
        "revision_id": "5e44cb4001a7d48f53ee524a2d90b3f5700a9920",
        "branch_name": "refs/heads/develop",
        "visit_date": "2023-09-03 23:06:14",
        "revision_date": "2023-08-01 17:34:34",
        "committer_date": "2023-08-01 17:34:34",
        "github_id": 22338518,
        "star_events_count": 7243,
        "fork_events_count": 1336,
        "gha_license_id": "MIT",
        "gha_event_created_at": "2023-08-01 17:34:36",
        "gha_created_at": "2014-07-28 10:10:39",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 145049,
        "extension": "cpp",
        "content": "#include \"stdafx.h\"\n#include \"unzip.h\"\n\n\n// THIS FILE is almost entirely based upon code by Jean-loup Gailly\n// and Mark Adler. It has been modified by Lucian Wischik.\n// The modifications were: incorporate the bugfixes of 1.1.4, allow\n// unzipping to/from handles/pipes/files/memory, encryption, unicode,\n// a windowsish api, and putting everything into a single .cpp file.\n// The original code may be found at http://www.gzip.org/zlib/\n// The original copyright text follows.\n//\n//\n//\n// zlib.h -- interface of the 'zlib' general purpose compression library\n//  version 1.1.3, July 9th, 1998\n//\n//  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler\n//\n//  This software is provided 'as-is', without any express or implied\n//  warranty.  In no event will the authors be held liable for any damages\n//  arising from the use of this software.\n//\n//  Permission is granted to anyone to use this software for any purpose,\n//  including commercial applications, and to alter it and redistribute it\n//  freely, subject to the following restrictions:\n//\n//  1. The origin of this software must not be misrepresented; you must not\n//     claim that you wrote the original software. If you use this software\n//     in a product, an acknowledgment in the product documentation would be\n//     appreciated but is not required.\n//  2. Altered source versions must be plainly marked as such, and must not be\n//     misrepresented as being the original software.\n//  3. This notice may not be removed or altered from any source distribution.\n//\n//  Jean-loup Gailly        Mark Adler\n//  jloup@gzip.org          madler@alumni.caltech.edu\n//\n//\n//  The data format used by the zlib library is described by RFCs (Request for\n//  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt\n//  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).\n//\n//\n//     The 'zlib' compression library provides in-memory compression and\n//  decompression functions, including integrity checks of the uncompressed\n//  data.  This version of the library supports only one compression method\n//  (deflation) but other algorithms will be added later and will have the same\n//  stream interface.\n//\n//     Compression can be done in a single step if the buffers are large\n//  enough (for example if an input file is mmap'ed), or can be done by\n//  repeated calls of the compression function.  In the latter case, the\n//  application must provide more input and/or consume the output\n//  (providing more output space) before each call.\n//\n//     The library also supports reading and writing files in gzip (.gz) format\n//  with an interface similar to that of stdio.\n//\n//     The library does not install any signal handler. The decoder checks\n//  the consistency of the compressed data, so the library should never\n//  crash even in case of corrupted input.\n//\n// for more info about .ZIP format, see ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip\n//   PkWare has also a specification at ftp://ftp.pkware.com/probdesc.zip\n\n#define ZIP_HANDLE   1\n#define ZIP_FILENAME 2\n#define ZIP_MEMORY   3\n\n\n#define zmalloc(len) malloc(len)\n\n#define zfree(p) free(p)\n\n/*\nvoid *zmalloc(unsigned int len)\n{ char *buf = new char[len+32];\n  for (int i=0; i<16; i++)\n  { buf[i]=i;\n    buf[len+31-i]=i;\n  }\n  *((unsigned int*)buf) = len;\n  char c[1000]; wsprintf(c,\"malloc 0x%lx  - %lu\",buf+16,len);\n  OutputDebugString(c);\n  return buf+16;\n}\n\nvoid zfree(void *buf)\n{ char c[1000]; wsprintf(c,\"free   0x%lx\",buf);\n  OutputDebugString(c);\n  char *p = ((char*)buf)-16;\n  unsigned int len = *((unsigned int*)p);\n  bool blown=false;\n  for (int i=0; i<16; i++)\n  { char lo = p[i];\n    char hi = p[len+31-i];\n    if (hi!=i || (lo!=i && i>4)) blown=true;\n  }\n  if (blown)\n  { OutputDebugString(\"BLOWN!!!\");\n  }\n  delete[] p;\n}\n*/\n\n\ntypedef struct tm_unz_s\n{ unsigned int tm_sec;            // seconds after the minute - [0,59]\n  unsigned int tm_min;            // minutes after the hour - [0,59]\n  unsigned int tm_hour;           // hours since midnight - [0,23]\n  unsigned int tm_mday;           // day of the month - [1,31]\n  unsigned int tm_mon;            // months since January - [0,11]\n  unsigned int tm_year;           // years - [1980..2044]\n} tm_unz;\n\n\n// unz_global_info structure contain global data about the ZIPfile\ntypedef struct unz_global_info_s\n{ unsigned long number_entry;         // total number of entries in the central dir on this disk\n  unsigned long size_comment;         // size of the global comment of the zipfile\n} unz_global_info;\n\n// unz_file_info contain information about a file in the zipfile\ntypedef struct unz_file_info_s\n{ unsigned long version;              // version made by                 2 bytes\n  unsigned long version_needed;       // version needed to extract       2 bytes\n  unsigned long flag;                 // general purpose bit flag        2 bytes\n  unsigned long compression_method;   // compression method              2 bytes\n  unsigned long dosDate;              // last mod file date in Dos fmt   4 bytes\n  unsigned long crc;                  // crc-32                          4 bytes\n  unsigned long compressed_size;      // compressed size                 4 bytes\n  unsigned long uncompressed_size;    // uncompressed size               4 bytes\n  unsigned long size_filename;        // filename length                 2 bytes\n  unsigned long size_file_extra;      // extra field length              2 bytes\n  unsigned long size_file_comment;    // file comment length             2 bytes\n  unsigned long disk_num_start;       // disk number start               2 bytes\n  unsigned long internal_fa;          // internal file attributes        2 bytes\n  unsigned long external_fa;          // external file attributes        4 bytes\n  tm_unz tmu_date;\n} unz_file_info;\n\n\n#define UNZ_OK                  (0)\n#define UNZ_END_OF_LIST_OF_FILE (-100)\n#define UNZ_ERRNO               (Z_ERRNO)\n#define UNZ_EOF                 (0)\n#define UNZ_PARAMERROR          (-102)\n#define UNZ_BADZIPFILE          (-103)\n#define UNZ_INTERNALERROR       (-104)\n#define UNZ_CRCERROR            (-105)\n#define UNZ_PASSWORD            (-106)\n\n\n\n\n\n\n\n#define ZLIB_VERSION \"1.1.3\"\n\n\n// Allowed flush values; see deflate() for details\n#define Z_NO_FLUSH      0\n#define Z_SYNC_FLUSH    2\n#define Z_FULL_FLUSH    3\n#define Z_FINISH        4\n\n\n// compression levels\n#define Z_NO_COMPRESSION         0\n#define Z_BEST_SPEED             1\n#define Z_BEST_COMPRESSION       9\n#define Z_DEFAULT_COMPRESSION  (-1)\n\n// compression strategy; see deflateInit2() for details\n#define Z_FILTERED            1\n#define Z_HUFFMAN_ONLY        2\n#define Z_DEFAULT_STRATEGY    0\n\n// Possible values of the data_type field\n#define Z_BINARY   0\n#define Z_ASCII    1\n#define Z_UNKNOWN  2\n\n// The deflate compression method (the only one supported in this version)\n#define Z_DEFLATED   8\n\n// for initializing zalloc, zfree, opaque\n#define Z_NULL  0\n\n// case sensitivity when searching for filenames\n#define CASE_SENSITIVE 1\n#define CASE_INSENSITIVE 2\n\n\n// Return codes for the compression/decompression functions. Negative\n// values are errors, positive values are used for special but normal events.\n#define Z_OK            0\n#define Z_STREAM_END    1\n#define Z_NEED_DICT     2\n#define Z_ERRNO        (-1)\n#define Z_STREAM_ERROR (-2)\n#define Z_DATA_ERROR   (-3)\n#define Z_MEM_ERROR    (-4)\n#define Z_BUF_ERROR    (-5)\n#define Z_VERSION_ERROR (-6)\n\n\n\n// Basic data types\ntypedef unsigned char  Byte;  // 8 bits\ntypedef unsigned int   uInt;  // 16 bits or more\ntypedef unsigned long  uLong; // 32 bits or more\ntypedef void *voidpf;\ntypedef void     *voidp;\ntypedef long z_off_t;\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);\ntypedef void   (*free_func)  (voidpf opaque, voidpf address);\n\nstruct internal_state;\n\ntypedef struct z_stream_s {\n    Byte    *next_in;  // next input byte\n    uInt     avail_in;  // number of bytes available at next_in\n    uLong    total_in;  // total nb of input bytes read so far\n\n    Byte    *next_out; // next output byte should be put there\n    uInt     avail_out; // remaining free space at next_out\n    uLong    total_out; // total nb of bytes output so far\n\n    char     *msg;      // last error message, NULL if no error\n    struct internal_state *state; // not visible by applications\n\n    alloc_func zalloc;  // used to allocate the internal state\n    free_func  zfree;   // used to free the internal state\n    voidpf     opaque;  // private data object passed to zalloc and zfree\n\n    int     data_type;  // best guess about the data type: ascii or binary\n    uLong   adler;      // adler32 value of the uncompressed data\n    uLong   reserved;   // reserved for future use\n} z_stream;\n\ntypedef z_stream *z_streamp;\n\n\n//   The application must update next_in and avail_in when avail_in has\n//   dropped to zero. It must update next_out and avail_out when avail_out\n//   has dropped to zero. The application must initialize zalloc, zfree and\n//   opaque before calling the init function. All other fields are set by the\n//   compression library and must not be updated by the application.\n//\n//   The opaque value provided by the application will be passed as the first\n//   parameter for calls of zalloc and zfree. This can be useful for custom\n//   memory management. The compression library attaches no meaning to the\n//   opaque value.\n//\n//   zalloc must return Z_NULL if there is not enough memory for the object.\n//   If zlib is used in a multi-threaded application, zalloc and zfree must be\n//   thread safe.\n//\n//   The fields total_in and total_out can be used for statistics or\n//   progress reports. After compression, total_in holds the total size of\n//   the uncompressed data and may be saved for use in the decompressor\n//   (particularly if the decompressor wants to decompress everything in\n//   a single step).\n//\n\n\n// basic functions\n\nconst char *zlibVersion ();\n// The application can compare zlibVersion and ZLIB_VERSION for consistency.\n// If the first character differs, the library code actually used is\n// not compatible with the zlib.h header file used by the application.\n// This check is automatically made by inflateInit.\n\n\n\n\n\n\nint inflate (z_streamp strm, int flush);\n//\n//    inflate decompresses as much data as possible, and stops when the input\n//  buffer becomes empty or the output buffer becomes full. It may some\n//  introduce some output latency (reading input without producing any output)\n//  except when forced to flush.\n//\n//  The detailed semantics are as follows. inflate performs one or both of the\n//  following actions:\n//\n//  - Decompress more input starting at next_in and update next_in and avail_in\n//    accordingly. If not all input can be processed (because there is not\n//    enough room in the output buffer), next_in is updated and processing\n//    will resume at this point for the next call of inflate().\n//\n//  - Provide more output starting at next_out and update next_out and avail_out\n//    accordingly.  inflate() provides as much output as possible, until there\n//    is no more input data or no more space in the output buffer (see below\n//    about the flush parameter).\n//\n//  Before the call of inflate(), the application should ensure that at least\n//  one of the actions is possible, by providing more input and/or consuming\n//  more output, and updating the next_* and avail_* values accordingly.\n//  The application can consume the uncompressed output when it wants, for\n//  example when the output buffer is full (avail_out == 0), or after each\n//  call of inflate(). If inflate returns Z_OK and with zero avail_out, it\n//  must be called again after making room in the output buffer because there\n//  might be more output pending.\n//\n//    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much\n//  output as possible to the output buffer. The flushing behavior of inflate is\n//  not specified for values of the flush parameter other than Z_SYNC_FLUSH\n//  and Z_FINISH, but the current implementation actually flushes as much output\n//  as possible anyway.\n//\n//    inflate() should normally be called until it returns Z_STREAM_END or an\n//  error. However if all decompression is to be performed in a single step\n//  (a single call of inflate), the parameter flush should be set to\n//  Z_FINISH. In this case all pending input is processed and all pending\n//  output is flushed; avail_out must be large enough to hold all the\n//  uncompressed data. (The size of the uncompressed data may have been saved\n//  by the compressor for this purpose.) The next operation on this stream must\n//  be inflateEnd to deallocate the decompression state. The use of Z_FINISH\n//  is never required, but can be used to inform inflate that a faster routine\n//  may be used for the single inflate() call.\n//\n//     If a preset dictionary is needed at this point (see inflateSetDictionary\n//  below), inflate sets strm-adler to the adler32 checksum of the\n//  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise\n//  it sets strm->adler to the adler32 checksum of all output produced\n//  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or\n//  an error code as described below. At the end of the stream, inflate()\n//  checks that its computed adler32 checksum is equal to that saved by the\n//  compressor and returns Z_STREAM_END only if the checksum is correct.\n//\n//    inflate() returns Z_OK if some progress has been made (more input processed\n//  or more output produced), Z_STREAM_END if the end of the compressed data has\n//  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n//  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n//  corrupted (input stream not conforming to the zlib format or incorrect\n//  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent\n//  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not\n//  enough memory, Z_BUF_ERROR if no progress is possible or if there was not\n//  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR\n//  case, the application may then call inflateSync to look for a good\n//  compression block.\n//\n\n\nint inflateEnd (z_streamp strm);\n//\n//     All dynamically allocated data structures for this stream are freed.\n//   This function discards any unprocessed input and does not flush any\n//   pending output.\n//\n//     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state\n//   was inconsistent. In the error case, msg may be set but then points to a\n//   static string (which must not be deallocated).\n\n                        // Advanced functions\n\n//  The following functions are needed only in some special applications.\n\n\n\n\n\nint inflateSetDictionary (z_streamp strm,\n                                             const Byte *dictionary,\n                                             uInt  dictLength);\n//\n//     Initializes the decompression dictionary from the given uncompressed byte\n//   sequence. This function must be called immediately after a call of inflate\n//   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor\n//   can be determined from the Adler32 value returned by this call of\n//   inflate. The compressor and decompressor must use exactly the same\n//   dictionary.\n//\n//     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n//   parameter is invalid (such as NULL dictionary) or the stream state is\n//   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n//   expected one (incorrect Adler32 value). inflateSetDictionary does not\n//   perform any decompression: this will be done by subsequent calls of\n//   inflate().\n\n\nint inflateSync (z_streamp strm);\n//\n//    Skips invalid compressed data until a full flush point can be found, or until all\n//  available input is skipped. No output is provided.\n//\n//    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR\n//  if no more input was provided, Z_DATA_ERROR if no flush point has been found,\n//  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success\n//  case, the application may save the current current value of total_in which\n//  indicates where valid compressed data was found. In the error case, the\n//  application may repeatedly call inflateSync, providing more input each time,\n//  until success or end of the input data.\n\n\nint inflateReset (z_streamp strm);\n//     This function is equivalent to inflateEnd followed by inflateInit,\n//   but does not free and reallocate all the internal decompression state.\n//   The stream will keep attributes that may have been set by inflateInit2.\n//\n//      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n//   stream state was inconsistent (such as zalloc or state being NULL).\n//\n\n\n\n// checksum functions\n// These functions are not related to compression but are exported\n// anyway because they might be useful in applications using the\n// compression library.\n\nuLong adler32 (uLong adler, const Byte *buf, uInt len);\n//     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n//   return the updated checksum. If buf is NULL, this function returns\n//   the required initial value for the checksum.\n//   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed\n//   much faster. Usage example:\n//\n//     uLong adler = adler32(0L, Z_NULL, 0);\n//\n//     while (read_buffer(buffer, length) != EOF) {\n//       adler = adler32(adler, buffer, length);\n//     }\n//     if (adler != original_adler) error();\n\nuLong ucrc32   (uLong crc, const Byte *buf, uInt len);\n//     Update a running crc with the bytes buf[0..len-1] and return the updated\n//   crc. If buf is NULL, this function returns the required initial value\n//   for the crc. Pre- and post-conditioning (one's complement) is performed\n//   within this function so it shouldn't be done by the application.\n//   Usage example:\n//\n//     uLong crc = crc32(0L, Z_NULL, 0);\n//\n//     while (read_buffer(buffer, length) != EOF) {\n//       crc = crc32(crc, buffer, length);\n//     }\n//     if (crc != original_crc) error();\n\n\n\n\nconst char   *zError           (int err);\nint           inflateSyncPoint (z_streamp z);\nconst uLong *get_crc_table    (void);\n\n\n\ntypedef unsigned char  uch;\ntypedef uch uchf;\ntypedef unsigned short ush;\ntypedef ush ushf;\ntypedef unsigned long  ulg;\n\n\n\nconst char * const z_errmsg[10] = { // indexed by 2-zlib_error\n\"need dictionary\",     // Z_NEED_DICT       2\n\"stream end\",          // Z_STREAM_END      1\n\"\",                    // Z_OK              0\n\"file error\",          // Z_ERRNO         (-1)\n\"stream error\",        // Z_STREAM_ERROR  (-2)\n\"data error\",          // Z_DATA_ERROR    (-3)\n\"insufficient memory\", // Z_MEM_ERROR     (-4)\n\"buffer error\",        // Z_BUF_ERROR     (-5)\n\"incompatible version\",// Z_VERSION_ERROR (-6)\n\"\"};\n\n\n#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]\n\n#define ERR_RETURN(strm,err) \\\n  return (strm->msg = (char*)ERR_MSG(err), (err))\n// To be used only when the state is known to be valid\n\n        // common constants\n\n\n#define STORED_BLOCK 0\n#define STATIC_TREES 1\n#define DYN_TREES    2\n// The three kinds of block type\n\n#define MIN_MATCH  3\n#define MAX_MATCH  258\n// The minimum and maximum match lengths\n\n#define PRESET_DICT 0x20 // preset dictionary flag in zlib header\n\n        // target dependencies\n\n#define OS_CODE  0x0b  // Window 95 & Windows NT\n\n\n\n         // functions\n\n#define zmemzero(dest, len) memset(dest, 0, len)\n\n// Diagnostic functions\n#define LuAssert(cond,msg)\n#define LuTrace(x)\n#define LuTracev(x)\n#define LuTracevv(x)\n#define LuTracec(c,x)\n#define LuTracecv(c,x)\n\n\ntypedef uLong (*check_func) (uLong check, const Byte *buf, uInt len);\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size);\nvoid   zcfree  (voidpf opaque, voidpf ptr);\n\n#define ZALLOC(strm, items, size) \\\n           (*((strm)->zalloc))((strm)->opaque, (items), (size))\n#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))\n\n//void ZFREE(z_streamp strm,voidpf addr)\n//{ *((strm)->zfree))((strm)->opaque, addr);\n//}\n\n#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}\n\n\n\n\n// Huffman code lookup table entry--this entry is four bytes for machines\n// that have 16-bit pointers (e.g. PC's in the small or medium model).\n\n\ntypedef struct inflate_huft_s inflate_huft;\n\nstruct inflate_huft_s {\n  union {\n    struct {\n      Byte Exop;        // number of extra bits or operation\n      Byte Bits;        // number of bits in this code or subcode\n    } what;\n    uInt pad;           // pad structure to a power of 2 (4 bytes for\n  } word;               //  16-bit, 8 bytes for 32-bit int's)\n  uInt base;            // literal, length base, distance base, or table offset\n};\n\n// Maximum size of dynamic tree.  The maximum found in a long but non-\n//   exhaustive search was 1004 huft structures (850 for length/literals\n//   and 154 for distances, the latter actually the result of an\n//   exhaustive search).  The actual maximum is not known, but the\n//   value below is more than safe.\n#define MANY 1440\n\nint inflate_trees_bits (\n    uInt *,                    // 19 code lengths\n    uInt *,                    // bits tree desired/actual depth\n    inflate_huft * *,       // bits tree result\n    inflate_huft *,             // space for trees\n    z_streamp);                // for messages\n\nint inflate_trees_dynamic (\n    uInt,                       // number of literal/length codes\n    uInt,                       // number of distance codes\n    uInt *,                    // that many (total) code lengths\n    uInt *,                    // literal desired/actual bit depth\n    uInt *,                    // distance desired/actual bit depth\n    inflate_huft * *,       // literal/length tree result\n    inflate_huft * *,       // distance tree result\n    inflate_huft *,             // space for trees\n    z_streamp);                // for messages\n\nint inflate_trees_fixed (\n    uInt *,                    // literal desired/actual bit depth\n    uInt *,                    // distance desired/actual bit depth\n    const inflate_huft * *,       // literal/length tree result\n    const inflate_huft * *,       // distance tree result\n    z_streamp);                // for memory allocation\n\n\n\n\n\nstruct inflate_blocks_state;\ntypedef struct inflate_blocks_state inflate_blocks_statef;\n\ninflate_blocks_statef * inflate_blocks_new (\n    z_streamp z,\n    check_func c,               // check function\n    uInt w);                   // window size\n\nint inflate_blocks (\n    inflate_blocks_statef *,\n    z_streamp ,\n    int);                      // initial return code\n\nvoid inflate_blocks_reset (\n    inflate_blocks_statef *,\n    z_streamp ,\n    uLong *);                  // check value on output\n\nint inflate_blocks_free (\n    inflate_blocks_statef *,\n    z_streamp);\n\nvoid inflate_set_dictionary (\n    inflate_blocks_statef *s,\n    const Byte *d,  // dictionary\n    uInt  n);       // dictionary length\n\nint inflate_blocks_sync_point (\n    inflate_blocks_statef *s);\n\n\n\n\nstruct inflate_codes_state;\ntypedef struct inflate_codes_state inflate_codes_statef;\n\ninflate_codes_statef *inflate_codes_new (\n    uInt, uInt,\n    const inflate_huft *, const inflate_huft *,\n    z_streamp );\n\nint inflate_codes (\n    inflate_blocks_statef *,\n    z_streamp ,\n    int);\n\nvoid inflate_codes_free (\n    inflate_codes_statef *,\n    z_streamp );\n\n\n\n\ntypedef enum {\n      IBM_TYPE,     // get type bits (3, including end bit)\n      IBM_LENS,     // get lengths for stored\n      IBM_STORED,   // processing stored block\n      IBM_TABLE,    // get table lengths\n      IBM_BTREE,    // get bit lengths tree for a dynamic block\n      IBM_DTREE,    // get length, distance trees for a dynamic block\n      IBM_CODES,    // processing fixed or dynamic block\n      IBM_DRY,      // output remaining window bytes\n      IBM_DONE,     // finished last block, done\n      IBM_BAD}      // got a data error--stuck here\ninflate_block_mode;\n\n// inflate blocks semi-private state\nstruct inflate_blocks_state {\n\n  // mode\n  inflate_block_mode  mode;     // current inflate_block mode\n\n  // mode dependent information\n  union {\n    uInt left;          // if STORED, bytes left to copy\n    struct {\n      uInt table;               // table lengths (14 bits)\n      uInt index;               // index into blens (or border)\n      uInt *blens;             // bit lengths of codes\n      uInt bb;                  // bit length tree depth\n      inflate_huft *tb;         // bit length decoding tree\n    } trees;            // if DTREE, decoding info for trees\n    struct {\n      inflate_codes_statef\n         *codes;\n    } decode;           // if CODES, current state\n  } sub;                // submode\n  uInt last;            // true if this block is the last block\n\n  // mode independent information\n  uInt bitk;            // bits in bit buffer\n  uLong bitb;           // bit buffer\n  inflate_huft *hufts;  // single malloc for tree space\n  Byte *window;        // sliding window\n  Byte *end;           // one byte after sliding window\n  Byte *read;          // window read pointer\n  Byte *write;         // window write pointer\n  check_func checkfn;   // check function\n  uLong check;          // check on output\n\n};\n\n\n// defines for inflate input/output\n//   update pointers and return\n#define UPDBITS {s->bitb=b;s->bitk=k;}\n#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}\n#define UPDOUT {s->write=q;}\n#define UPDATE {UPDBITS UPDIN UPDOUT}\n#define LEAVE {UPDATE return inflate_flush(s,z,r);}\n//   get bytes and bits\n#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}\n#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}\n#define NEXTBYTE (n--,*p++)\n#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n#define DUMPBITS(j) {b>>=(j);k-=(j);}\n//   output bytes\n#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)\n#define LOADOUT {q=s->write;m=(uInt)WAVAIL;m;}\n#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}\n#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}\n#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}\n#define OUTBYTE(a) {*q++=(Byte)(a);m--;}\n//   load local pointers\n#define LOAD {LOADIN LOADOUT}\n\n// masks for lower bits (size given to avoid silly warnings with Visual C++)\n// And'ing with mask[n] masks the lower n bits\nconst uInt inflate_mask[17] = {\n    0x0000,\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n};\n\n// copy as much as possible from the sliding window to the output area\nint inflate_flush (inflate_blocks_statef *, z_streamp, int);\n\nint inflate_fast (uInt, uInt, const inflate_huft *, const inflate_huft *, inflate_blocks_statef *, z_streamp );\n\n\n\nconst uInt fixed_bl = 9;\nconst uInt fixed_bd = 5;\nconst inflate_huft fixed_tl[] = {\n    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},\n    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},\n    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},\n    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},\n    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},\n    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},\n    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},\n    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},\n    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},\n    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},\n    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},\n    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},\n    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},\n    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},\n    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},\n    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},\n    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},\n    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},\n    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},\n    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},\n    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},\n    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},\n    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},\n    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},\n    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},\n    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},\n    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},\n    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},\n    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},\n    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},\n    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},\n    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},\n    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},\n    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},\n    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},\n    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},\n    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},\n    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},\n    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},\n    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},\n    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},\n    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},\n    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},\n    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},\n    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},\n    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},\n    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},\n    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},\n    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},\n    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},\n    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},\n    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},\n    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},\n    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},\n    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},\n    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},\n    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},\n    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},\n    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},\n    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},\n    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},\n    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},\n    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},\n    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},\n    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},\n    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},\n    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},\n    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},\n    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},\n    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},\n    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},\n    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},\n    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},\n    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},\n    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},\n    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},\n    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},\n    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},\n    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},\n    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},\n    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},\n    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},\n    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},\n    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},\n    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},\n    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},\n    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},\n    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},\n    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},\n    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},\n    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},\n    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},\n    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},\n    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},\n    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},\n    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},\n    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},\n    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},\n    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},\n    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},\n    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},\n    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},\n    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},\n    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},\n    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},\n    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},\n    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},\n    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},\n    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},\n    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},\n    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},\n    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}\n  };\nconst inflate_huft fixed_td[] = {\n    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},\n    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},\n    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},\n    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},\n    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},\n    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},\n    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},\n    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}\n  };\n\n\n\n\n\n\n\n// copy as much as possible from the sliding window to the output area\nint inflate_flush(inflate_blocks_statef *s,z_streamp z,int r)\n{\n  uInt n;\n  Byte *p;\n  Byte *q;\n\n  // local copies of source and destination pointers\n  p = z->next_out;\n  q = s->read;\n\n  // compute number of bytes to copy as far as end of window\n  n = (uInt)((q <= s->write ? s->write : s->end) - q);\n  if (n > z->avail_out) n = z->avail_out;\n  if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n  // update counters\n  z->avail_out -= n;\n  z->total_out += n;\n\n  // update check information\n  if (s->checkfn != Z_NULL)\n    z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n  // copy as far as end of window\n  if (n!=0)          // check for n!=0 to avoid waking up CodeGuard\n  { memcpy(p, q, n);\n    p += n;\n    q += n;\n  }\n\n  // see if more to copy at beginning of window\n  if (q == s->end)\n  {\n    // wrap pointers\n    q = s->window;\n    if (s->write == s->end)\n      s->write = s->window;\n\n    // compute bytes to copy\n    n = (uInt)(s->write - q);\n    if (n > z->avail_out) n = z->avail_out;\n    if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z->avail_out -= n;\n    z->total_out += n;\n\n    // update check information\n    if (s->checkfn != Z_NULL)\n      z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n    // copy\n    if (n!=0) {memcpy(p,q,n); p+=n; q+=n;}\n  }\n\n  // update pointers\n  z->next_out = p;\n  s->read = q;\n\n  // done\n  return r;\n}\n\n\n\n\n\n\n// simplify the use of the inflate_huft type with some defines\n#define exop word.what.Exop\n#define bits word.what.Bits\n\ntypedef enum {        // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      START,    // x: set up for LEN\n      LEN,      // i: get length/literal/eob next\n      LENEXT,   // i: getting length extra (have base)\n      DIST,     // i: get distance next\n      DISTEXT,  // i: getting distance extra\n      COPY,     // o: copying bytes in window, waiting for space\n      LIT,      // o: got literal, waiting for output space\n      WASH,     // o: got eob, possibly still output waiting\n      END,      // x: got eob and all data flushed\n      BADCODE}  // x: got error\ninflate_codes_mode;\n\n// inflate codes private state\nstruct inflate_codes_state {\n\n  // mode\n  inflate_codes_mode mode;      // current inflate_codes mode\n\n  // mode dependent information\n  uInt len;\n  union {\n    struct {\n      const inflate_huft *tree;       // pointer into tree\n      uInt need;                // bits needed\n    } code;             // if LEN or DIST, where in tree\n    uInt lit;           // if LIT, literal\n    struct {\n      uInt get;                 // bits to get for extra\n      uInt dist;                // distance back to copy from\n    } copy;             // if EXT or COPY, where and how much\n  } sub;                // submode\n\n  // mode independent information\n  Byte lbits;           // ltree bits decoded per branch\n  Byte dbits;           // dtree bits decoder per branch\n  const inflate_huft *ltree;          // literal/length/eob tree\n  const inflate_huft *dtree;          // distance tree\n\n};\n\n\ninflate_codes_statef *inflate_codes_new(\nuInt bl, uInt bd,\nconst inflate_huft *tl,\nconst inflate_huft *td, // need separate declaration for Borland C++\nz_streamp z)\n{\n  inflate_codes_statef *c;\n\n  if ((c = (inflate_codes_statef *)\n       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)\n  {\n    c->mode = START;\n    c->lbits = (Byte)bl;\n    c->dbits = (Byte)bd;\n    c->ltree = tl;\n    c->dtree = td;\n    LuTracev((stderr, \"inflate:       codes new\\n\"));\n  }\n  return c;\n}\n\n\nint inflate_codes(inflate_blocks_statef *s, z_streamp z, int r)\n{\n  uInt j;               // temporary storage\n  const inflate_huft *t;      // temporary pointer\n  uInt e;               // extra bits or operation\n  uLong b;              // bit buffer\n  uInt k;               // bits in bit buffer\n  Byte *p;             // input data pointer\n  uInt n;               // bytes available there\n  Byte *q;             // output window write pointer\n  uInt m;               // bytes to end of window or read pointer\n  Byte *f;             // pointer to copy strings from\n  inflate_codes_statef *c = s->sub.decode.codes;  // codes state\n\n  // copy input/output information to locals (UPDATE macro restores)\n  LOAD\n\n  // process input and output based on current state\n  for(;;) switch (c->mode)\n  {             // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n    case START:         // x: set up for LEN\n#ifndef SLOW\n      if (m >= 258 && n >= 10)\n      {\n        UPDATE\n        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);\n        LOAD\n        if (r != Z_OK)\n        {\n          c->mode = r == Z_STREAM_END ? WASH : BADCODE;\n          break;\n        }\n      }\n#endif // !SLOW\n      c->sub.code.need = c->lbits;\n      c->sub.code.tree = c->ltree;\n      c->mode = LEN;\n    case LEN:           // i: get length/literal/eob next\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e == 0)               // literal\n      {\n        c->sub.lit = t->base;\n        LuTracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                 \"inflate:         literal '%c'\\n\" :\n                 \"inflate:         literal 0x%02x\\n\", t->base));\n        c->mode = LIT;\n        break;\n      }\n      if (e & 16)               // length\n      {\n        c->sub.copy.get = e & 15;\n        c->len = t->base;\n        c->mode = LENEXT;\n        break;\n      }\n      if ((e & 64) == 0)        // next table\n      {\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      }\n      if (e & 32)               // end of block\n      {\n        LuTracevv((stderr, \"inflate:         end of block\\n\"));\n        c->mode = WASH;\n        break;\n      }\n      c->mode = BADCODE;        // invalid code\n      z->msg = (char*)\"invalid literal/length code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case LENEXT:        // i: getting length extra (have base)\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->len += (uInt)b & inflate_mask[j];\n      DUMPBITS(j)\n      c->sub.code.need = c->dbits;\n      c->sub.code.tree = c->dtree;\n      LuTracevv((stderr, \"inflate:         length %u\\n\", c->len));\n      c->mode = DIST;\n    case DIST:          // i: get distance next\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e & 16)               // distance\n      {\n        c->sub.copy.get = e & 15;\n        c->sub.copy.dist = t->base;\n        c->mode = DISTEXT;\n        break;\n      }\n      if ((e & 64) == 0)        // next table\n      {\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      }\n      c->mode = BADCODE;        // invalid code\n      z->msg = (char*)\"invalid distance code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case DISTEXT:       // i: getting distance extra\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->sub.copy.dist += (uInt)b & inflate_mask[j];\n      DUMPBITS(j)\n      LuTracevv((stderr, \"inflate:         distance %u\\n\", c->sub.copy.dist));\n      c->mode = COPY;\n    case COPY:          // o: copying bytes in window, waiting for space\n      f = q - c->sub.copy.dist;\n      while (f < s->window)             // modulo window size-\"while\" instead\n        f += s->end - s->window;        // of \"if\" handles invalid distances\n      while (c->len)\n      {\n        NEEDOUT\n        OUTBYTE(*f++)\n        if (f == s->end)\n          f = s->window;\n        c->len--;\n      }\n      c->mode = START;\n      break;\n    case LIT:           // o: got literal, waiting for output space\n      NEEDOUT\n      OUTBYTE(c->sub.lit)\n      c->mode = START;\n      break;\n    case WASH:          // o: got eob, possibly more output\n      if (k > 7)        // return unused byte, if any\n      {\n        //Assert(k < 16, \"inflate_codes grabbed too many bytes\")\n        k -= 8;\n        n++;\n        p--;            // can always return one\n      }\n      FLUSH\n      if (s->read != s->write)\n        LEAVE\n      c->mode = END;\n    case END:\n      r = Z_STREAM_END;\n      LEAVE\n    case BADCODE:       // x: got error\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  }\n}\n\n\nvoid inflate_codes_free(inflate_codes_statef *c,z_streamp z)\n{ ZFREE(z, c);\n  LuTracev((stderr, \"inflate:       codes free\\n\"));\n}\n\n\n\n// infblock.c -- interpret and process block types to last block\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n\n//struct inflate_codes_state {int dummy;}; // for buggy compilers\n\n\n\n// Table for deflate from PKZIP's appnote.txt.\nconst uInt border[] = { // Order of the bit length code lengths\n        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n//\n// Notes beyond the 1.93a appnote.txt:\n//\n// 1. Distance pointers never point before the beginning of the output stream.\n// 2. Distance pointers can point back across blocks, up to 32k away.\n// 3. There is an implied maximum of 7 bits for the bit length table and\n//    15 bits for the actual data.\n// 4. If only one code exists, then it is encoded using one bit.  (Zero\n//    would be more efficient, but perhaps a little confusing.)  If two\n//    codes exist, they are coded using one bit each (0 and 1).\n// 5. There is no way of sending zero distance codes--a dummy must be\n//    sent if there are none.  (History: a pre 2.0 version of PKZIP would\n//    store blocks with no distance codes, but this was discovered to be\n//    too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n//    zero distance codes, which is sent as one code of zero bits in\n//    length.\n// 6. There are up to 286 literal/length codes.  Code 256 represents the\n//    end-of-block.  Note however that the static length tree defines\n//    288 codes just to fill out the Huffman codes.  Codes 286 and 287\n//    cannot be used though, since there is no length base or extra bits\n//    defined for them.  Similarily, there are up to 30 distance codes.\n//    However, static trees define 32 codes (all 5 bits) to fill out the\n//    Huffman codes, but the last two had better not show up in the data.\n// 7. Unzip can check dynamic Huffman blocks for complete code sets.\n//    The exception is that a single code would not be complete (see #4).\n// 8. The five bits following the block type is really the number of\n//    literal codes sent minus 257.\n// 9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n//    (1+6+6).  Therefore, to output three times the length, you output\n//    three codes (1+1+1), whereas to output four times the same length,\n//    you only need two codes (1+3).  Hmm.\n//10. In the tree reconstruction algorithm, Code = Code + Increment\n//    only if BitLength(i) is not zero.  (Pretty obvious.)\n//11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n//12. Note: length code 284 can represent 227-258, but length code 285\n//    really is 258.  The last length deserves its own, short code\n//    since it gets used a lot in very redundant files.  The length\n//    258 is special since 258 - 3 (the min match length) is 255.\n//13. The literal/length and distance code bit lengths are read as a\n//    single stream of lengths.  It is possible (and advantageous) for\n//    a repeat code (16, 17, or 18) to go across the boundary between\n//    the two sets of lengths.\n\n\nvoid inflate_blocks_reset(inflate_blocks_statef *s, z_streamp z, uLong *c)\n{\n  if (c != Z_NULL)\n    *c = s->check;\n  if (s->mode == IBM_BTREE || s->mode == IBM_DTREE)\n    ZFREE(z, s->sub.trees.blens);\n  if (s->mode == IBM_CODES)\n    inflate_codes_free(s->sub.decode.codes, z);\n  s->mode = IBM_TYPE;\n  s->bitk = 0;\n  s->bitb = 0;\n  s->read = s->write = s->window;\n  if (s->checkfn != Z_NULL)\n    z->adler = s->check = (*s->checkfn)(0L, (const Byte *)Z_NULL, 0);\n  LuTracev((stderr, \"inflate:   blocks reset\\n\"));\n}\n\n\ninflate_blocks_statef *inflate_blocks_new(z_streamp z, check_func c, uInt w)\n{\n  inflate_blocks_statef *s;\n\n  if ((s = (inflate_blocks_statef *)ZALLOC\n       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)\n    return s;\n  if ((s->hufts =\n       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)\n  {\n    ZFREE(z, s);\n    return Z_NULL;\n  }\n  if ((s->window = (Byte *)ZALLOC(z, 1, w)) == Z_NULL)\n  {\n    ZFREE(z, s->hufts);\n    ZFREE(z, s);\n    return Z_NULL;\n  }\n  s->end = s->window + w;\n  s->checkfn = c;\n  s->mode = IBM_TYPE;\n  LuTracev((stderr, \"inflate:   blocks allocated\\n\"));\n  inflate_blocks_reset(s, z, Z_NULL);\n  return s;\n}\n\n\nint inflate_blocks(inflate_blocks_statef *s, z_streamp z, int r)\n{\n  uInt t;               // temporary storage\n  uLong b;              // bit buffer\n  uInt k;               // bits in bit buffer\n  Byte *p;             // input data pointer\n  uInt n;               // bytes available there\n  Byte *q;             // output window write pointer\n  uInt m;               // bytes to end of window or read pointer\n\n  // copy input/output information to locals (UPDATE macro restores)\n  LOAD\n\n  // process input based on current state\n  for(;;) switch (s->mode)\n  {\n    case IBM_TYPE:\n      NEEDBITS(3)\n      t = (uInt)b & 7;\n      s->last = t & 1;\n      switch (t >> 1)\n      {\n        case 0:                         // stored\n          LuTracev((stderr, \"inflate:     stored block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          t = k & 7;                    // go to byte boundary\n          DUMPBITS(t)\n          s->mode = IBM_LENS;               // get length of stored block\n          break;\n        case 1:                         // fixed\n          LuTracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          {\n            uInt bl, bd;\n            const inflate_huft *tl, *td;\n\n            inflate_trees_fixed(&bl, &bd, &tl, &td, z);\n            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);\n            if (s->sub.decode.codes == Z_NULL)\n            {\n              r = Z_MEM_ERROR;\n              LEAVE\n            }\n          }\n          DUMPBITS(3)\n          s->mode = IBM_CODES;\n          break;\n        case 2:                         // dynamic\n          LuTracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          s->mode = IBM_TABLE;\n          break;\n        case 3:                         // illegal\n          DUMPBITS(3)\n          s->mode = IBM_BAD;\n          z->msg = (char*)\"invalid block type\";\n          r = Z_DATA_ERROR;\n          LEAVE\n      }\n      break;\n    case IBM_LENS:\n      NEEDBITS(32)\n      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))\n      {\n        s->mode = IBM_BAD;\n        z->msg = (char*)\"invalid stored block lengths\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      }\n      s->sub.left = (uInt)b & 0xffff;\n      b = k = 0;                      // dump bits\n      LuTracev((stderr, \"inflate:       stored length %u\\n\", s->sub.left));\n      s->mode = s->sub.left ? IBM_STORED : (s->last ? IBM_DRY : IBM_TYPE);\n      break;\n    case IBM_STORED:\n      if (n == 0)\n        LEAVE\n      NEEDOUT\n      t = s->sub.left;\n      if (t > n) t = n;\n      if (t > m) t = m;\n      memcpy(q, p, t);\n      p += t;  n -= t;\n      q += t;  m -= t;\n      if ((s->sub.left -= t) != 0)\n        break;\n      LuTracev((stderr, \"inflate:       stored end, %lu total out\\n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      s->mode = s->last ? IBM_DRY : IBM_TYPE;\n      break;\n    case IBM_TABLE:\n      NEEDBITS(14)\n      s->sub.trees.table = t = (uInt)b & 0x3fff;\n      // remove this section to workaround bug in pkzip\n      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n      {\n        s->mode = IBM_BAD;\n        z->msg = (char*)\"too many length or distance symbols\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      }\n      // end remove\n      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n      if ((s->sub.trees.blens = (uInt*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)\n      {\n        r = Z_MEM_ERROR;\n        LEAVE\n      }\n      DUMPBITS(14)\n      s->sub.trees.index = 0;\n      LuTracev((stderr, \"inflate:       table sizes ok\\n\"));\n      s->mode = IBM_BTREE;\n    case IBM_BTREE:\n      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))\n      {\n        NEEDBITS(3)\n        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;\n        DUMPBITS(3)\n      }\n      while (s->sub.trees.index < 19)\n        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;\n      s->sub.trees.bb = 7;\n      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,\n                             &s->sub.trees.tb, s->hufts, z);\n      if (t != Z_OK)\n      {\n        r = t;\n        if (r == Z_DATA_ERROR)\n        {\n          ZFREE(z, s->sub.trees.blens);\n          s->mode = IBM_BAD;\n        }\n        LEAVE\n      }\n      s->sub.trees.index = 0;\n      LuTracev((stderr, \"inflate:       bits tree ok\\n\"));\n      s->mode = IBM_DTREE;\n    case IBM_DTREE:\n      while (t = s->sub.trees.table,\n             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))\n      {\n        inflate_huft *h;\n        uInt i, j, c;\n\n        t = s->sub.trees.bb;\n        NEEDBITS(t)\n        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);\n        t = h->bits;\n        c = h->base;\n        if (c < 16)\n        {\n          DUMPBITS(t)\n          s->sub.trees.blens[s->sub.trees.index++] = c;\n        }\n        else // c == 16..18\n        {\n          i = c == 18 ? 7 : c - 14;\n          j = c == 18 ? 11 : 3;\n          NEEDBITS(t + i)\n          DUMPBITS(t)\n          j += (uInt)b & inflate_mask[i];\n          DUMPBITS(i)\n          i = s->sub.trees.index;\n          t = s->sub.trees.table;\n          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n              (c == 16 && i < 1))\n          {\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = IBM_BAD;\n            z->msg = (char*)\"invalid bit length repeat\";\n            r = Z_DATA_ERROR;\n            LEAVE\n          }\n          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;\n          do {\n            s->sub.trees.blens[i++] = c;\n          } while (--j);\n          s->sub.trees.index = i;\n        }\n      }\n      s->sub.trees.tb = Z_NULL;\n      {\n        uInt bl, bd;\n        inflate_huft *tl, *td;\n        inflate_codes_statef *c;\n\n        bl = 9;         // must be <= 9 for lookahead assumptions\n        bd = 6;         // must be <= 9 for lookahead assumptions\n        t = s->sub.trees.table;\n        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),\n                                  s->sub.trees.blens, &bl, &bd, &tl, &td,\n                                  s->hufts, z);\n        if (t != Z_OK)\n        {\n          if (t == (uInt)Z_DATA_ERROR)\n          {\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = IBM_BAD;\n          }\n          r = t;\n          LEAVE\n        }\n        LuTracev((stderr, \"inflate:       trees ok\\n\"));\n        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)\n        {\n          r = Z_MEM_ERROR;\n          LEAVE\n        }\n        s->sub.decode.codes = c;\n      }\n      ZFREE(z, s->sub.trees.blens);\n      s->mode = IBM_CODES;\n    case IBM_CODES:\n      UPDATE\n      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)\n        return inflate_flush(s, z, r);\n      r = Z_OK;\n      inflate_codes_free(s->sub.decode.codes, z);\n      LOAD\n      LuTracev((stderr, \"inflate:       codes end, %lu total out\\n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      if (!s->last)\n      {\n        s->mode = IBM_TYPE;\n        break;\n      }\n      s->mode = IBM_DRY;\n    case IBM_DRY:\n      FLUSH\n      if (s->read != s->write)\n        LEAVE\n      s->mode = IBM_DONE;\n    case IBM_DONE:\n      r = Z_STREAM_END;\n      LEAVE\n    case IBM_BAD:\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  }\n}\n\n\nint inflate_blocks_free(inflate_blocks_statef *s, z_streamp z)\n{\n  inflate_blocks_reset(s, z, Z_NULL);\n  ZFREE(z, s->window);\n  ZFREE(z, s->hufts);\n  ZFREE(z, s);\n  LuTracev((stderr, \"inflate:   blocks freed\\n\"));\n  return Z_OK;\n}\n\n\n\n// inftrees.c -- generate Huffman trees for efficient decoding\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n//\n\n\n\nextern const char inflate_copyright[] =\n   \" inflate 1.1.3 Copyright 1995-1998 Mark Adler \";\n// If you use the zlib library in a product, an acknowledgment is welcome\n// in the documentation of your product. If for some reason you cannot\n// include such an acknowledgment, I would appreciate that you keep this\n// copyright string in the executable of your product.\n\n\n\nint huft_build (\n    uInt *,            // code lengths in bits\n    uInt,               // number of codes\n    uInt,               // number of \"simple\" codes\n    const uInt *,      // list of base values for non-simple codes\n    const uInt *,      // list of extra bits for non-simple codes\n    inflate_huft **,// result: starting table\n    uInt *,            // maximum lookup bits (returns actual)\n    inflate_huft *,     // space for trees\n    uInt *,             // hufts used in space\n    uInt * );         // space for values\n\n// Tables for deflate from PKZIP's appnote.txt.\nconst uInt cplens[31] = { // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n        // see note #13 above about 258\nconst uInt cplext[31] = { // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; // 112==invalid\nconst uInt cpdist[30] = { // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\nconst uInt cpdext[30] = { // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n//\n//   Huffman code decoding is performed using a multi-level table lookup.\n//   The fastest way to decode is to simply build a lookup table whose\n//   size is determined by the longest code.  However, the time it takes\n//   to build this table can also be a factor if the data being decoded\n//   is not very long.  The most common codes are necessarily the\n//   shortest codes, so those codes dominate the decoding time, and hence\n//   the speed.  The idea is you can have a shorter table that decodes the\n//   shorter, more probable codes, and then point to subsidiary tables for\n//   the longer codes.  The time it costs to decode the longer codes is\n//   then traded against the time it takes to make longer tables.\n//\n//   This results of this trade are in the variables lbits and dbits\n//   below.  lbits is the number of bits the first level table for literal/\n//   length codes can decode in one step, and dbits is the same thing for\n//   the distance codes.  Subsequent tables are also less than or equal to\n//   those sizes.  These values may be adjusted either when all of the\n//   codes are shorter than that, in which case the longest code length in\n//   bits is used, or when the shortest code is *longer* than the requested\n//   table size, in which case the length of the shortest code in bits is\n//   used.\n//\n//   There are two different values for the two tables, since they code a\n//   different number of possibilities each.  The literal/length table\n//   codes 286 possible values, or in a flat code, a little over eight\n//   bits.  The distance table codes 30 possible values, or a little less\n//   than five bits, flat.  The optimum values for speed end up being\n//   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n//   The optimum values may differ though from machine to machine, and\n//   possibly even between compilers.  Your mileage may vary.\n//\n\n\n// If BMAX needs to be larger than 16, then h and x[] should be uLong.\n#define BMAX 15         // maximum bit length of any code\n\nint huft_build(\nuInt *b,               // code lengths in bits (all assumed <= BMAX)\nuInt n,                 // number of codes (assumed <= 288)\nuInt s,                 // number of simple-valued codes (0..s-1)\nconst uInt *d,         // list of base values for non-simple codes\nconst uInt *e,         // list of extra bits for non-simple codes\ninflate_huft * *t,  // result: starting table\nuInt *m,               // maximum lookup bits, returns actual\ninflate_huft *hp,       // space for trees\nuInt *hn,               // hufts used in space\nuInt *v)               // working area: values in order of bit length\n// Given a list of code lengths and a maximum table size, make a set of\n// tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n// if the given code set is incomplete (the tables are still built in this\n// case), or Z_DATA_ERROR if the input is invalid.\n{\n\n  uInt a;                       // counter for codes of length k\n  uInt c[BMAX+1];               // bit length count table\n  uInt f;                       // i repeats in table every f entries\n  int g;                        // maximum code length\n  int h;                        // table level\n  register uInt i;              // counter, current code\n  register uInt j;              // counter\n  register int k;               // number of bits in current code\n  int l;                        // bits per table (returned in m)\n  uInt mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n  register uInt *p;            // pointer into c[], b[], or v[]\n  inflate_huft *q;              // points to current table\n  struct inflate_huft_s r;      // table entry for structure assignment\n  inflate_huft *u[BMAX];        // table stack\n  register int w;               // bits before this table == (l * h)\n  uInt x[BMAX+1];               // bit offsets, then code stack\n  uInt *xp;                    // pointer into x\n  int y;                        // number of dummy codes added\n  uInt z;                       // number of entries in current table\n\n\n  // Generate counts for each bit length\n  p = c;\n#define C0 *p++ = 0;\n#define C2 C0 C0 C0 C0\n#define C4 C2 C2 C2 C2\n  C4; p;                          // clear c[]--assume BMAX+1 is 16\n  p = b;  i = n;\n  do {\n    c[*p++]++;                  // assume all entries <= BMAX\n  } while (--i);\n  if (c[0] == n)                // null input--all zero length codes\n  {\n    *t = (inflate_huft *)Z_NULL;\n    *m = 0;\n    return Z_OK;\n  }\n\n\n  // Find minimum and maximum length, bound *m by those\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                        // minimum code length\n  if ((uInt)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                        // maximum code length\n  if ((uInt)l > i)\n    l = i;\n  *m = l;\n\n\n  // Adjust last length count to fill out codes, if needed\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0)\n      return Z_DATA_ERROR;\n  if ((y -= c[i]) < 0)\n    return Z_DATA_ERROR;\n  c[i] += y;\n\n\n  // Generate starting offsets into the value table for each length\n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 // note that i == g from above\n    *xp++ = (j += *p++);\n  }\n\n\n  // Make a table of values in order of bit lengths\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                     // set n to length of v\n\n\n  // Generate the Huffman codes and for each, make the table entries\n  x[0] = i = 0;                 // first Huffman code is zero\n  p = v;                        // grab values in bit order\n  h = -1;                       // no tables yet--level -1\n  w = -l;                       // bits decoded == (l * h)\n  u[0] = (inflate_huft *)Z_NULL;        // just to keep compilers happy\n  q = (inflate_huft *)Z_NULL;   // ditto\n  z = 0;                        // ditto\n\n  // go through the bit lengths (k already is bits in shortest code)\n  for (; k <= g; k++)\n  {\n    a = c[k];\n    while (a--)\n    {\n      // here i is the Huffman code of length k bits for value *p\n      // make tables up to required level\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 // previous table always l bits\n\n        // compute minimum size table less than or equal to l bits\n        z = g - w;\n        z = z > (uInt)l ? l : z;        // table size upper limit\n        if ((f = 1 << (j = k - w)) > a + 1)     // try a k-w bit table\n        {                       // too few codes for k-w bit table\n          f -= a + 1;           // deduct codes from patterns left\n          xp = c + k;\n          if (j < z)\n            while (++j < z)     // try smaller tables up to z bits\n            {\n              if ((f <<= 1) <= *++xp)\n                break;          // enough codes to use up j bits\n              f -= *xp;         // else deduct codes from patterns\n            }\n        }\n        z = 1 << j;             // table entries for j-bit table\n\n        // allocate new table\n        if (*hn + z > MANY)     // (note: doesn't matter for fixed)\n          return Z_DATA_ERROR;  // overflow of MANY\n        u[h] = q = hp + *hn;\n        *hn += z;\n\n        // connect to last table, if there is one\n        if (h)\n        {\n          x[h] = i;             // save pattern for backing up\n          r.bits = (Byte)l;     // bits to dump before this table\n          r.exop = (Byte)j;     // bits in this table\n          j = i >> (w - l);\n          r.base = (uInt)(q - u[h-1] - j);   // offset to this table\n          u[h-1][j] = r;        // connect to last table\n        }\n        else\n          *t = q;               // first table is returned result\n      }\n\n      // set up table entry in r\n      r.bits = (Byte)(k - w);\n      if (p >= v + n)\n        r.exop = 128 + 64;      // out of values--invalid code\n      else if (*p < s)\n      {\n        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     // 256 is end-of-block\n        r.base = *p++;          // simple code is just the value\n      }\n      else\n      {\n        r.exop = (Byte)(e[*p - s] + 16 + 64);// non-simple--look up in lists\n        r.base = d[*p++ - s];\n      }\n\n      // fill code-like entries with r\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n      // backwards increment the k-bit code i\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n      // backup over finished tables\n      mask = (1 << w) - 1;      // needed on HP, cc -O bug\n      while ((i & mask) != x[h])\n      {\n        h--;                    // don't need to update q\n        w -= l;\n        mask = (1 << w) - 1;\n      }\n    }\n  }\n\n\n  // Return Z_BUF_ERROR if we were given an incomplete table\n  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\n\nint inflate_trees_bits(\nuInt *c,               // 19 code lengths\nuInt *bb,              // bits tree desired/actual depth\ninflate_huft * *tb, // bits tree result\ninflate_huft *hp,       // space for trees\nz_streamp z)            // for messages\n{\n  int r;\n  uInt hn = 0;          // hufts used in space\n  uInt *v;             // work area for huft_build\n\n  if ((v = (uInt*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n  r = huft_build(c, 19, 19, (uInt*)Z_NULL, (uInt*)Z_NULL,\n                 tb, bb, hp, &hn, v);\n  if (r == Z_DATA_ERROR)\n    z->msg = (char*)\"oversubscribed dynamic bit lengths tree\";\n  else if (r == Z_BUF_ERROR || *bb == 0)\n  {\n    z->msg = (char*)\"incomplete dynamic bit lengths tree\";\n    r = Z_DATA_ERROR;\n  }\n  ZFREE(z, v);\n  return r;\n}\n\n\nint inflate_trees_dynamic(\nuInt nl,                // number of literal/length codes\nuInt nd,                // number of distance codes\nuInt *c,               // that many (total) code lengths\nuInt *bl,              // literal desired/actual bit depth\nuInt *bd,              // distance desired/actual bit depth\ninflate_huft * *tl, // literal/length tree result\ninflate_huft * *td, // distance tree result\ninflate_huft *hp,       // space for trees\nz_streamp z)            // for messages\n{\n  int r;\n  uInt hn = 0;          // hufts used in space\n  uInt *v;             // work area for huft_build\n\n  // allocate work area\n  if ((v = (uInt*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n\n  // build literal/length tree\n  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);\n  if (r != Z_OK || *bl == 0)\n  {\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed literal/length tree\";\n    else if (r != Z_MEM_ERROR)\n    {\n      z->msg = (char*)\"incomplete literal/length tree\";\n      r = Z_DATA_ERROR;\n    }\n    ZFREE(z, v);\n    return r;\n  }\n\n  // build distance tree\n  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);\n  if (r != Z_OK || (*bd == 0 && nl > 257))\n  {\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed distance tree\";\n    else if (r == Z_BUF_ERROR) {\n      z->msg = (char*)\"incomplete distance tree\";\n      r = Z_DATA_ERROR;\n    }\n    else if (r != Z_MEM_ERROR)\n    {\n      z->msg = (char*)\"empty distance tree with lengths\";\n      r = Z_DATA_ERROR;\n    }\n    ZFREE(z, v);\n    return r;\n  }\n\n  // done\n  ZFREE(z, v);\n  return Z_OK;\n}\n\n\n\n\n\nint inflate_trees_fixed(\nuInt *bl,               // literal desired/actual bit depth\nuInt *bd,               // distance desired/actual bit depth\nconst inflate_huft * * tl,     // literal/length tree result\nconst inflate_huft * *td,     // distance tree result\nz_streamp )             // for memory allocation\n{\n  *bl = fixed_bl;\n  *bd = fixed_bd;\n  *tl = fixed_tl;\n  *td = fixed_td;\n  return Z_OK;\n}\n\n\n// inffast.c -- process literals and length/distance pairs fast\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n//\n\n\n//struct inflate_codes_state {int dummy;}; // for buggy compilers\n\n\n// macros for bit input with no checking and for returning unused bytes\n#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}\n\n// Called with number of bytes left to write in window at least 258\n// (the maximum string length) and number of input bytes available\n// at least ten.  The ten bytes are six bytes for the longest length/\n// distance pair plus four bytes for overloading the bit buffer.\n\nint inflate_fast(\nuInt bl, uInt bd,\nconst inflate_huft *tl,\nconst inflate_huft *td, // need separate declaration for Borland C++\ninflate_blocks_statef *s,\nz_streamp z)\n{\n  const inflate_huft *t;      // temporary pointer\n  uInt e;               // extra bits or operation\n  uLong b;              // bit buffer\n  uInt k;               // bits in bit buffer\n  Byte *p;             // input data pointer\n  uInt n;               // bytes available there\n  Byte *q;             // output window write pointer\n  uInt m;               // bytes to end of window or read pointer\n  uInt ml;              // mask for literal/length tree\n  uInt md;              // mask for distance tree\n  uInt c;               // bytes to copy\n  uInt d;               // distance back to copy from\n  Byte *r;             // copy source pointer\n\n  // load input, output, bit values\n  LOAD\n\n  // initialize masks\n  ml = inflate_mask[bl];\n  md = inflate_mask[bd];\n\n  // do until not enough input or output space for fast loop\n  do {                          // assume called with m >= 258 && n >= 10\n    // get literal/length code\n    GRABBITS(20)                // max bits for literal/length code\n    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)\n    {\n      DUMPBITS(t->bits)\n      LuTracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                \"inflate:         * literal '%c'\\n\" :\n                \"inflate:         * literal 0x%02x\\n\", t->base));\n      *q++ = (Byte)t->base;\n      m--;\n      continue;\n    }\n    for (;;) {\n      DUMPBITS(t->bits)\n      if (e & 16)\n      {\n        // get extra bits for length\n        e &= 15;\n        c = t->base + ((uInt)b & inflate_mask[e]);\n        DUMPBITS(e)\n        LuTracevv((stderr, \"inflate:         * length %u\\n\", c));\n\n        // decode distance base of block to copy\n        GRABBITS(15);           // max bits for distance code\n        e = (t = td + ((uInt)b & md))->exop;\n        for (;;) {\n          DUMPBITS(t->bits)\n          if (e & 16)\n          {\n            // get extra bits to add to distance base\n            e &= 15;\n            GRABBITS(e)         // get extra bits (up to 13)\n            d = t->base + ((uInt)b & inflate_mask[e]);\n            DUMPBITS(e)\n            LuTracevv((stderr, \"inflate:         * distance %u\\n\", d));\n\n            // do the copy\n            m -= c;\n            r = q - d;\n            if (r < s->window)                  // wrap if needed\n            {\n              do {\n                r += s->end - s->window;        // force pointer in window\n              } while (r < s->window);          // covers invalid distances\n              e = (uInt) (s->end - r);\n              if (c > e)\n              {\n                c -= e;                         // wrapped copy\n                do {\n                    *q++ = *r++;\n                } while (--e);\n                r = s->window;\n                do {\n                    *q++ = *r++;\n                } while (--c);\n              }\n              else                              // normal copy\n              {\n                *q++ = *r++;  c--;\n                *q++ = *r++;  c--;\n                do {\n                    *q++ = *r++;\n                } while (--c);\n              }\n            }\n            else                                /* normal copy */\n            {\n              *q++ = *r++;  c--;\n              *q++ = *r++;  c--;\n              do {\n                *q++ = *r++;\n              } while (--c);\n            }\n            break;\n          }\n          else if ((e & 64) == 0)\n          {\n            t += t->base;\n            e = (t += ((uInt)b & inflate_mask[e]))->exop;\n          }\n          else\n          {\n            z->msg = (char*)\"invalid distance code\";\n            UNGRAB\n            UPDATE\n            return Z_DATA_ERROR;\n          }\n        };\n        break;\n      }\n      if ((e & 64) == 0)\n      {\n        t += t->base;\n        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)\n        {\n          DUMPBITS(t->bits)\n          LuTracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                    \"inflate:         * literal '%c'\\n\" :\n                    \"inflate:         * literal 0x%02x\\n\", t->base));\n          *q++ = (Byte)t->base;\n          m--;\n          break;\n        }\n      }\n      else if (e & 32)\n      {\n        LuTracevv((stderr, \"inflate:         * end of block\\n\"));\n        UNGRAB\n        UPDATE\n        return Z_STREAM_END;\n      }\n      else\n      {\n        z->msg = (char*)\"invalid literal/length code\";\n        UNGRAB\n        UPDATE\n        return Z_DATA_ERROR;\n      }\n    };\n  } while (m >= 258 && n >= 10);\n\n  // not enough input or output--restore pointers and return\n  UNGRAB\n  UPDATE\n  return Z_OK;\n}\n\n\n\n\n\n\n// crc32.c -- compute the CRC-32 of a data stream\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n\n// @(#) $Id$\n\n\n\n\n\n\n// Table of CRC-32's of all single-byte values (made by make_crc_table)\nconst uLong crc_table[256] = {\n  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n  0x2d02ef8dL\n};\n\nconst uLong * get_crc_table()\n{ return (const uLong *)crc_table;\n}\n\n#define CRC_DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);\n#define CRC_DO2(buf)  CRC_DO1(buf); CRC_DO1(buf);\n#define CRC_DO4(buf)  CRC_DO2(buf); CRC_DO2(buf);\n#define CRC_DO8(buf)  CRC_DO4(buf); CRC_DO4(buf);\n\nuLong ucrc32(uLong crc, const Byte *buf, uInt len)\n{ if (buf == Z_NULL) return 0L;\n  crc = crc ^ 0xffffffffL;\n  while (len >= 8)  {CRC_DO8(buf); len -= 8;}\n  if (len) do {CRC_DO1(buf);} while (--len);\n  return crc ^ 0xffffffffL;\n}\n\n\n\n// =============================================================\n// some decryption routines\n#define CRC32(c, b) (crc_table[((int)(c)^(b))&0xff]^((c)>>8))\nvoid Uupdate_keys(unsigned long *keys, char c)\n{ keys[0] = CRC32(keys[0],c);\n  keys[1] += keys[0] & 0xFF;\n  keys[1] = keys[1]*134775813L +1;\n  keys[2] = CRC32(keys[2], keys[1] >> 24);\n}\nchar Udecrypt_byte(unsigned long *keys)\n{ unsigned temp = ((unsigned)keys[2] & 0xffff) | 2;\n  return (char)(((temp * (temp ^ 1)) >> 8) & 0xff);\n}\nchar zdecode(unsigned long *keys, char c)\n{ c^=Udecrypt_byte(keys);\n  Uupdate_keys(keys,c);\n  return c;\n}\n\n\n\n// adler32.c -- compute the Adler-32 checksum of a data stream\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n\n// @(#) $Id$\n\n\n#define BASE 65521L // largest prime smaller than 65536\n#define NMAX 5552\n// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\n\n#define AD_DO1(buf,i)  {s1 += buf[i]; s2 += s1;}\n#define AD_DO2(buf,i)  AD_DO1(buf,i); AD_DO1(buf,i+1);\n#define AD_DO4(buf,i)  AD_DO2(buf,i); AD_DO2(buf,i+2);\n#define AD_DO8(buf,i)  AD_DO4(buf,i); AD_DO4(buf,i+4);\n#define AD_DO16(buf)   AD_DO8(buf,0); AD_DO8(buf,8);\n\n// =========================================================================\nuLong adler32(uLong adler, const Byte *buf, uInt len)\n{\n    unsigned long s1 = adler & 0xffff;\n    unsigned long s2 = (adler >> 16) & 0xffff;\n    int k;\n\n    if (buf == Z_NULL) return 1L;\n\n    while (len > 0) {\n        k = len < NMAX ? len : NMAX;\n        len -= k;\n        while (k >= 16) {\n            AD_DO16(buf);\n\t    buf += 16;\n            k -= 16;\n        }\n        if (k != 0) do {\n            s1 += *buf++;\n\t    s2 += s1;\n        } while (--k);\n        s1 %= BASE;\n        s2 %= BASE;\n    }\n    return (s2 << 16) | s1;\n}\n\n\n\n// zutil.c -- target dependent utility functions for the compression library\n// Copyright (C) 1995-1998 Jean-loup Gailly.\n// For conditions of distribution and use, see copyright notice in zlib.h\n// @(#) $Id$\n\n\n\n\n\n\nconst char * zlibVersion()\n{\n    return ZLIB_VERSION;\n}\n\n// exported to allow conversion of error code to string for compress() and\n// uncompress()\nconst char * zError(int err)\n{ return ERR_MSG(err);\n}\n\n\n\n\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    if (opaque) items += size - size; // make compiler happy\n    return (voidpf)calloc(items, size);\n}\n\nvoid  zcfree (voidpf opaque, voidpf ptr)\n{\n    zfree(ptr);\n    if (opaque) return; // make compiler happy\n}\n\n\n\n// inflate.c -- zlib interface to inflate modules\n// Copyright (C) 1995-1998 Mark Adler\n// For conditions of distribution and use, see copyright notice in zlib.h\n\n//struct inflate_blocks_state {int dummy;}; // for buggy compilers\n\ntypedef enum {\n      IM_METHOD,   // waiting for method byte\n      IM_FLAG,     // waiting for flag byte\n      IM_DICT4,    // four dictionary check bytes to go\n      IM_DICT3,    // three dictionary check bytes to go\n      IM_DICT2,    // two dictionary check bytes to go\n      IM_DICT1,    // one dictionary check byte to go\n      IM_DICT0,    // waiting for inflateSetDictionary\n      IM_BLOCKS,   // decompressing blocks\n      IM_CHECK4,   // four check bytes to go\n      IM_CHECK3,   // three check bytes to go\n      IM_CHECK2,   // two check bytes to go\n      IM_CHECK1,   // one check byte to go\n      IM_DONE,     // finished check, done\n      IM_BAD}      // got an error--stay here\ninflate_mode;\n\n// inflate private state\nstruct internal_state {\n\n  // mode\n  inflate_mode  mode;   // current inflate mode\n\n  // mode dependent information\n  union {\n    uInt method;        // if IM_FLAGS, method byte\n    struct {\n      uLong was;                // computed check value\n      uLong need;               // stream check value\n    } check;            // if CHECK, check values to compare\n    uInt marker;        // if IM_BAD, inflateSync's marker bytes count\n  } sub;        // submode\n\n  // mode independent information\n  int  nowrap;          // flag for no wrapper\n  uInt wbits;           // log2(window size)  (8..15, defaults to 15)\n  inflate_blocks_statef\n    *blocks;            // current inflate_blocks state\n\n};\n\nint inflateReset(z_streamp z)\n{\n  if (z == Z_NULL || z->state == Z_NULL)\n    return Z_STREAM_ERROR;\n  z->total_in = z->total_out = 0;\n  z->msg = Z_NULL;\n  z->state->mode = z->state->nowrap ? IM_BLOCKS : IM_METHOD;\n  inflate_blocks_reset(z->state->blocks, z, Z_NULL);\n  LuTracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nint inflateEnd(z_streamp z)\n{\n  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)\n    return Z_STREAM_ERROR;\n  if (z->state->blocks != Z_NULL)\n    inflate_blocks_free(z->state->blocks, z);\n  ZFREE(z, z->state);\n  z->state = Z_NULL;\n  LuTracev((stderr, \"inflate: end\\n\"));\n  return Z_OK;\n}\n\n\nint inflateInit2(z_streamp z)\n{ const char *version = ZLIB_VERSION; int stream_size = sizeof(z_stream);\n  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] || stream_size != sizeof(z_stream)) return Z_VERSION_ERROR;\n\n  int w = -15; // MAX_WBITS: 32K LZ77 window.\n  // Warning: reducing MAX_WBITS makes minigzip unable to extract .gz files created by gzip.\n  // The memory requirements for deflate are (in bytes):\n  //            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n  // that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n  // plus a few kilobytes for small objects. For example, if you want to reduce\n  // the default memory requirements from 256K to 128K, compile with\n  //     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n  // Of course this will generally degrade compression (there's no free lunch).\n  //\n  //   The memory requirements for inflate are (in bytes) 1 << windowBits\n  // that is, 32K for windowBits=15 (default value) plus a few kilobytes\n  // for small objects.\n\n  // initialize state\n  if (z == Z_NULL) return Z_STREAM_ERROR;\n  z->msg = Z_NULL;\n  if (z->zalloc == Z_NULL)\n  {\n    z->zalloc = zcalloc;\n    z->opaque = (voidpf)0;\n  }\n  if (z->zfree == Z_NULL) z->zfree = zcfree;\n  if ((z->state = (struct internal_state *)\n       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)\n    return Z_MEM_ERROR;\n  z->state->blocks = Z_NULL;\n\n  // handle undocumented nowrap option (no zlib header or check)\n  z->state->nowrap = 0;\n  if (w < 0)\n  {\n    w = - w;\n    z->state->nowrap = 1;\n  }\n\n  // set window size\n  if (w < 8 || w > 15)\n  {\n    inflateEnd(z);\n    return Z_STREAM_ERROR;\n  }\n  z->state->wbits = (uInt)w;\n\n  // create inflate_blocks state\n  if ((z->state->blocks =\n      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))\n      == Z_NULL)\n  {\n    inflateEnd(z);\n    return Z_MEM_ERROR;\n  }\n  LuTracev((stderr, \"inflate: allocated\\n\"));\n\n  // reset state\n  inflateReset(z);\n  return Z_OK;\n}\n\n\n\n#define IM_NEEDBYTE {if(z->avail_in==0)return r;r=f;}\n#define IM_NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)\n\nint inflate(z_streamp z, int f)\n{\n  int r;\n  uInt b;\n\n  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)\n    return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  for (;;) switch (z->state->mode)\n  {\n    case IM_METHOD:\n      IM_NEEDBYTE\n      if (((z->state->sub.method = IM_NEXTBYTE) & 0xf) != Z_DEFLATED)\n      {\n        z->state->mode = IM_BAD;\n        z->msg = (char*)\"unknown compression method\";\n        z->state->sub.marker = 5;       // can't try inflateSync\n        break;\n      }\n      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)\n      {\n        z->state->mode = IM_BAD;\n        z->msg = (char*)\"invalid window size\";\n        z->state->sub.marker = 5;       // can't try inflateSync\n        break;\n      }\n      z->state->mode = IM_FLAG;\n    case IM_FLAG:\n      IM_NEEDBYTE\n      b = IM_NEXTBYTE;\n      if (((z->state->sub.method << 8) + b) % 31)\n      {\n        z->state->mode = IM_BAD;\n        z->msg = (char*)\"incorrect header check\";\n        z->state->sub.marker = 5;       // can't try inflateSync\n        break;\n      }\n      LuTracev((stderr, \"inflate: zlib header ok\\n\"));\n      if (!(b & PRESET_DICT))\n      {\n        z->state->mode = IM_BLOCKS;\n        break;\n      }\n      z->state->mode = IM_DICT4;\n    case IM_DICT4:\n      IM_NEEDBYTE\n      z->state->sub.check.need = (uLong)IM_NEXTBYTE << 24;\n      z->state->mode = IM_DICT3;\n    case IM_DICT3:\n      IM_NEEDBYTE\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 16;\n      z->state->mode = IM_DICT2;\n    case IM_DICT2:\n      IM_NEEDBYTE\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 8;\n      z->state->mode = IM_DICT1;\n    case IM_DICT1:\n      IM_NEEDBYTE; r;\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE;\n      z->adler = z->state->sub.check.need;\n      z->state->mode = IM_DICT0;\n      return Z_NEED_DICT;\n    case IM_DICT0:\n      z->state->mode = IM_BAD;\n      z->msg = (char*)\"need dictionary\";\n      z->state->sub.marker = 0;       // can try inflateSync\n      return Z_STREAM_ERROR;\n    case IM_BLOCKS:\n      r = inflate_blocks(z->state->blocks, z, r);\n      if (r == Z_DATA_ERROR)\n      {\n        z->state->mode = IM_BAD;\n        z->state->sub.marker = 0;       // can try inflateSync\n        break;\n      }\n      if (r == Z_OK)\n        r = f;\n      if (r != Z_STREAM_END)\n        return r;\n      r = f;\n      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);\n      if (z->state->nowrap)\n      {\n        z->state->mode = IM_DONE;\n        break;\n      }\n      z->state->mode = IM_CHECK4;\n    case IM_CHECK4:\n      IM_NEEDBYTE\n      z->state->sub.check.need = (uLong)IM_NEXTBYTE << 24;\n      z->state->mode = IM_CHECK3;\n    case IM_CHECK3:\n      IM_NEEDBYTE\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 16;\n      z->state->mode = IM_CHECK2;\n    case IM_CHECK2:\n      IM_NEEDBYTE\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE << 8;\n      z->state->mode = IM_CHECK1;\n    case IM_CHECK1:\n      IM_NEEDBYTE\n      z->state->sub.check.need += (uLong)IM_NEXTBYTE;\n\n      if (z->state->sub.check.was != z->state->sub.check.need)\n      {\n        z->state->mode = IM_BAD;\n        z->msg = (char*)\"incorrect data check\";\n        z->state->sub.marker = 5;       // can't try inflateSync\n        break;\n      }\n      LuTracev((stderr, \"inflate: zlib check ok\\n\"));\n      z->state->mode = IM_DONE;\n    case IM_DONE:\n      return Z_STREAM_END;\n    case IM_BAD:\n      return Z_DATA_ERROR;\n    default:\n      return Z_STREAM_ERROR;\n  }\n}\n\n\n\n\n\n// unzip.c -- IO on .zip files using zlib\n// Version 0.15 beta, Mar 19th, 1998,\n// Read unzip.h for more info\n\n\n\n\n#define UNZ_BUFSIZE (16384)\n#define UNZ_MAXFILENAMEINZIP (256)\n#define SIZECENTRALDIRITEM (0x2e)\n#define SIZEZIPLOCALHEADER (0x1e)\n\n\n\n\nconst char unz_copyright[] = \" unzip 0.15 Copyright 1998 Gilles Vollant \";\n\n// unz_file_info_interntal contain internal info about a file in zipfile\ntypedef struct unz_file_info_internal_s\n{\n    uLong offset_curfile;// relative offset of local header 4 bytes\n} unz_file_info_internal;\n\n\ntypedef struct\n{ bool is_handle; // either a handle or memory\n  bool canseek;\n  // for handles:\n  HANDLE h; bool herr; unsigned long initial_offset; bool mustclosehandle;\n  // for memory:\n  void *buf; unsigned int len,pos; // if it's a memory block\n} LUFILE;\n\n\nLUFILE *lufopen(void *z,unsigned int len,DWORD flags,ZRESULT *err)\n{ if (flags!=ZIP_HANDLE && flags!=ZIP_FILENAME && flags!=ZIP_MEMORY) {*err=ZR_ARGS; return NULL;}\n  //\n  HANDLE h=0; bool canseek=false; *err=ZR_OK;\n  bool mustclosehandle=false;\n  if (flags==ZIP_HANDLE||flags==ZIP_FILENAME)\n  { if (flags==ZIP_HANDLE)\n    { HANDLE hf = z;\n      h=hf; mustclosehandle=false;\n#ifdef DuplicateHandle\n      BOOL res = DuplicateHandle(GetCurrentProcess(),hf,GetCurrentProcess(),&h,0,FALSE,DUPLICATE_SAME_ACCESS);\n      if (!res) mustclosehandle=true;\n#endif\n    }\n    else\n    { h=CreateFile((const TCHAR*)z,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n      if (h==INVALID_HANDLE_VALUE) {*err=ZR_NOFILE; return NULL;}\n      mustclosehandle=true;\n    }\n    // test if we can seek on it. We can't use GetFileType(h)==FILE_TYPE_DISK since it's not on CE.\n    DWORD res = SetFilePointer(h,0,0,FILE_CURRENT);\n    canseek = (res!=0xFFFFFFFF);\n  }\n  LUFILE *lf = new LUFILE;\n  if (flags==ZIP_HANDLE||flags==ZIP_FILENAME)\n  { lf->is_handle=true; lf->mustclosehandle=mustclosehandle;\n    lf->canseek=canseek;\n    lf->h=h; lf->herr=false;\n    lf->initial_offset=0;\n    if (canseek) lf->initial_offset = SetFilePointer(h,0,NULL,FILE_CURRENT);\n  }\n  else\n  { lf->is_handle=false;\n    lf->canseek=true;\n    lf->mustclosehandle=false;\n    lf->buf=z; lf->len=len; lf->pos=0; lf->initial_offset=0;\n  }\n  *err=ZR_OK;\n  return lf;\n}\n\n\nint lufclose(LUFILE *stream)\n{ if (stream==NULL) return EOF;\n  if (stream->mustclosehandle) CloseHandle(stream->h);\n  delete stream;\n  return 0;\n}\n\nint luferror(LUFILE *stream)\n{ if (stream->is_handle && stream->herr) return 1;\n  else return 0;\n}\n\nlong int luftell(LUFILE *stream)\n{ if (stream->is_handle && stream->canseek) return SetFilePointer(stream->h,0,NULL,FILE_CURRENT)-stream->initial_offset;\n  else if (stream->is_handle) return 0;\n  else return stream->pos;\n}\n\nint lufseek(LUFILE *stream, long offset, int whence)\n{ if (stream->is_handle && stream->canseek)\n  { if (whence==SEEK_SET) SetFilePointer(stream->h,stream->initial_offset+offset,0,FILE_BEGIN);\n    else if (whence==SEEK_CUR) SetFilePointer(stream->h,offset,NULL,FILE_CURRENT);\n    else if (whence==SEEK_END) SetFilePointer(stream->h,offset,NULL,FILE_END);\n    else return 19; // EINVAL\n    return 0;\n  }\n  else if (stream->is_handle) return 29; // ESPIPE\n  else\n  { if (whence==SEEK_SET) stream->pos=offset;\n    else if (whence==SEEK_CUR) stream->pos+=offset;\n    else if (whence==SEEK_END) stream->pos=stream->len+offset;\n    return 0;\n  }\n}\n\n\nsize_t lufread(void *ptr,size_t size,size_t n,LUFILE *stream)\n{ unsigned int toread = (unsigned int)(size*n);\n  if (stream->is_handle)\n  { DWORD red; BOOL res = ReadFile(stream->h,ptr,toread,&red,NULL);\n    if (!res) stream->herr=true;\n    return red/size;\n  }\n  if (stream->pos+toread > stream->len) toread = stream->len-stream->pos;\n  memcpy(ptr, (char*)stream->buf + stream->pos, toread); DWORD red = toread;\n  stream->pos += red;\n  return red/size;\n}\n\n\n\n\n// file_in_zip_read_info_s contain internal information about a file in zipfile,\n//  when reading and decompress it\ntypedef struct\n{\n\tchar  *read_buffer;         // internal buffer for compressed data\n\tz_stream stream;            // zLib stream structure for inflate\n\n\tuLong pos_in_zipfile;       // position in byte on the zipfile, for fseek\n\tuLong stream_initialised;   // flag set if stream structure is initialised\n\n\tuLong offset_local_extrafield;// offset of the local extra field\n\tuInt  size_local_extrafield;// size of the local extra field\n\tuLong pos_local_extrafield;   // position in the local extra field in read\n\n\tuLong crc32;                // crc32 of all data uncompressed\n\tuLong crc32_wait;           // crc32 we must obtain after decompress all\n\tuLong rest_read_compressed; // number of byte to be decompressed\n\tuLong rest_read_uncompressed;//number of byte to be obtained after decomp\n\tLUFILE* file;                 // io structore of the zipfile\n\tuLong compression_method;   // compression method (0==store)\n\tuLong byte_before_the_zipfile;// byte before the zipfile, (>0 for sfx)\n  bool encrypted;               // is it encrypted?\n  unsigned long keys[3];        // decryption keys, initialized by unzOpenCurrentFile\n  int encheadleft;              // the first call(s) to unzReadCurrentFile will read this many encryption-header bytes first\n  char crcenctest;              // if encrypted, we'll check the encryption buffer against this\n} file_in_zip_read_info_s;\n\n\n// unz_s contain internal information about the zipfile\ntypedef struct\n{\n\tLUFILE* file;               // io structore of the zipfile\n\tunz_global_info gi;         // public global information\n\tuLong byte_before_the_zipfile;// byte before the zipfile, (>0 for sfx)\n\tuLong num_file;             // number of the current file in the zipfile\n\tuLong pos_in_central_dir;   // pos of the current file in the central dir\n\tuLong current_file_ok;      // flag about the usability of the current file\n\tuLong central_pos;          // position of the beginning of the central dir\n\n\tuLong size_central_dir;     // size of the central directory\n\tuLong offset_central_dir;   // offset of start of central directory with respect to the starting disk number\n\n\tunz_file_info cur_file_info; // public info about the current file in zip\n\tunz_file_info_internal cur_file_info_internal; // private info about it\n    file_in_zip_read_info_s* pfile_in_zip_read; // structure about the current file if we are decompressing it\n} unz_s, *unzFile;\n\n\nint unzStringFileNameCompare (const char* fileName1,const char* fileName2,int iCaseSensitivity);\n//   Compare two filename (fileName1,fileName2).\n\nz_off_t unztell (unzFile file);\n//  Give the current position in uncompressed data\n\nint unzeof (unzFile file);\n//  return 1 if the end of file was reached, 0 elsewhere\n\nint unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len);\n//  Read extra field from the current file (opened by unzOpenCurrentFile)\n//  This is the local-header version of the extra field (sometimes, there is\n//    more info in the local-header version than in the central-header)\n//\n//  if buf==NULL, it return the size of the local extra field\n//\n//  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n//\tbuf.\n//  the return value is the number of bytes copied in buf, or (if <0)\n//\tthe error code\n\n\n\n// ===========================================================================\n//   Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n// for end of file.\n// IN assertion: the stream s has been sucessfully opened for reading.\n\nint unzlocal_getByte(LUFILE *fin,int *pi)\n{ unsigned char c;\n  int err = (int)lufread(&c, 1, 1, fin);\n  if (err==1)\n  { *pi = (int)c;\n    return UNZ_OK;\n  }\n  else\n  { if (luferror(fin)) return UNZ_ERRNO;\n    else return UNZ_EOF;\n  }\n}\n\n\n// ===========================================================================\n// Reads a long in LSB order from the given gz_stream. Sets\nint unzlocal_getShort (LUFILE *fin,uLong *pX)\n{\n    uLong x ;\n    int i;\n    int err;\n\n    err = unzlocal_getByte(fin,&i);\n    x = (uLong)i;\n\n    if (err==UNZ_OK)\n        err = unzlocal_getByte(fin,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==UNZ_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}\n\nint unzlocal_getLong (LUFILE *fin,uLong *pX)\n{\n    uLong x ;\n    int i;\n    int err;\n\n    err = unzlocal_getByte(fin,&i);\n    x = (uLong)i;\n\n    if (err==UNZ_OK)\n        err = unzlocal_getByte(fin,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==UNZ_OK)\n        err = unzlocal_getByte(fin,&i);\n    x += ((uLong)i)<<16;\n\n    if (err==UNZ_OK)\n        err = unzlocal_getByte(fin,&i);\n    x += ((uLong)i)<<24;\n\n    if (err==UNZ_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}\n\n\n// My own strcmpi / strcasecmp\nint strcmpcasenosensitive_internal (const char* fileName1,const char *fileName2)\n{\n\tfor (;;)\n\t{\n\t\tchar c1=*(fileName1++);\n\t\tchar c2=*(fileName2++);\n\t\tif ((c1>='a') && (c1<='z'))\n\t\t\tc1 -= (char)0x20;\n\t\tif ((c2>='a') && (c2<='z'))\n\t\t\tc2 -= (char)0x20;\n\t\tif (c1=='\\0')\n\t\t\treturn ((c2=='\\0') ? 0 : -1);\n\t\tif (c2=='\\0')\n\t\t\treturn 1;\n\t\tif (c1<c2)\n\t\t\treturn -1;\n\t\tif (c1>c2)\n\t\t\treturn 1;\n\t}\n}\n\n\n\n\n//\n// Compare two filename (fileName1,fileName2).\n// If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n// If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi or strcasecmp)\n//\nint unzStringFileNameCompare (const char*fileName1,const char*fileName2,int iCaseSensitivity)\n{ if (iCaseSensitivity==1) return strcmp(fileName1,fileName2);\n  else return strcmpcasenosensitive_internal(fileName1,fileName2);\n}\n\n#define BUFREADCOMMENT (0x400)\n\n\n//  Locate the Central directory of a zipfile (at the end, just before\n// the global comment). Lu bugfix 2005.07.26 - returns 0xFFFFFFFF if not found,\n// rather than 0, since 0 is a valid central-dir-location for an empty zipfile.\nuLong unzlocal_SearchCentralDir(LUFILE *fin)\n{ if (lufseek(fin,0,SEEK_END) != 0) return 0xFFFFFFFF;\n  uLong uSizeFile = luftell(fin);\n\n  uLong uMaxBack=0xffff; // maximum size of global comment\n  if (uMaxBack>uSizeFile) uMaxBack = uSizeFile;\n\n  unsigned char *buf = (unsigned char*)zmalloc(BUFREADCOMMENT+4);\n  if (buf==NULL) return 0xFFFFFFFF;\n  uLong uPosFound=0xFFFFFFFF;\n\n  uLong uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  { uLong uReadSize,uReadPos ;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack) uBackRead = uMaxBack;\n    else uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);\n    if (lufseek(fin,uReadPos,SEEK_SET)!=0) break;\n    if (lufread(buf,(uInt)uReadSize,1,fin)!=1) break;\n    for (i=(int)uReadSize-3; (i--)>=0;)\n    { if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\t((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n      { uPosFound = uReadPos+i;\tbreak;\n      }\n    }\n    if (uPosFound!=0) break;\n  }\n  if (buf) zfree(buf);\n  return uPosFound;\n}\n\n\nint unzGoToFirstFile (unzFile file);\nint unzCloseCurrentFile (unzFile file);\n\n// Open a Zip file.\n// If the zipfile cannot be opened (file don't exist or in not valid), return NULL.\n// Otherwise, the return value is a unzFile Handle, usable with other unzip functions\nunzFile unzOpenInternal(LUFILE *fin)\n{ if (fin==NULL) return NULL;\n  if (unz_copyright[0]!=' ') {lufclose(fin); return NULL;}\n\n  int err=UNZ_OK;\n  unz_s us;\n  uLong central_pos,uL;\n  central_pos = unzlocal_SearchCentralDir(fin);\n  if (central_pos==0xFFFFFFFF) err=UNZ_ERRNO;\n  if (lufseek(fin,central_pos,SEEK_SET)!=0) err=UNZ_ERRNO;\n  // the signature, already checked\n  if (unzlocal_getLong(fin,&uL)!=UNZ_OK) err=UNZ_ERRNO;\n  // number of this disk\n  uLong number_disk;          // number of the current dist, used for spanning ZIP, unsupported, always 0\n  if (unzlocal_getShort(fin,&number_disk)!=UNZ_OK) err=UNZ_ERRNO;\n  // number of the disk with the start of the central directory\n  uLong number_disk_with_CD;  // number the the disk with central dir, used for spaning ZIP, unsupported, always 0\n  if (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK) err=UNZ_ERRNO;\n  // total number of entries in the central dir on this disk\n  if (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK) err=UNZ_ERRNO;\n  // total number of entries in the central dir\n  uLong number_entry_CD;      // total number of entries in the central dir (same than number_entry on nospan)\n  if (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK) err=UNZ_ERRNO;\n  if ((number_entry_CD!=us.gi.number_entry) || (number_disk_with_CD!=0) || (number_disk!=0)) err=UNZ_BADZIPFILE;\n  // size of the central directory\n  if (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK) err=UNZ_ERRNO;\n  // offset of start of central directory with respect to the starting disk number\n  if (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK) err=UNZ_ERRNO;\n  // zipfile comment length\n  if (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK) err=UNZ_ERRNO;\n  if ((central_pos+fin->initial_offset<us.offset_central_dir+us.size_central_dir) && (err==UNZ_OK)) err=UNZ_BADZIPFILE;\n  if (err!=UNZ_OK) {lufclose(fin);return NULL;}\n\n  us.file=fin;\n  us.byte_before_the_zipfile = central_pos+fin->initial_offset - (us.offset_central_dir+us.size_central_dir);\n  us.central_pos = central_pos;\n  us.pfile_in_zip_read = NULL;\n  fin->initial_offset = 0; // since the zipfile itself is expected to handle this\n\n  unz_s *s = (unz_s*)zmalloc(sizeof(unz_s));\n  *s=us;\n  unzGoToFirstFile((unzFile)s);\n  return (unzFile)s;\n}\n\n\n\n//  Close a ZipFile opened with unzipOpen.\n//  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n//    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n//  return UNZ_OK if there is no problem.\nint unzClose (unzFile file)\n{\n\tunz_s* s;\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n\tlufclose(s->file);\n\tif (s) zfree(s); // unused s=0;\n\treturn UNZ_OK;\n}\n\n\n//  Write info about the ZipFile in the *pglobal_info structure.\n//  No preparation of the structure is needed\n//  return UNZ_OK if there is no problem.\nint unzGetGlobalInfo (unzFile file,unz_global_info *pglobal_info)\n{\n\tunz_s* s;\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\t*pglobal_info=s->gi;\n\treturn UNZ_OK;\n}\n\n\n//   Translate date/time from Dos format to tm_unz (readable more easilty)\nvoid unzlocal_DosDateToTmuDate (uLong ulDosDate, tm_unz* ptm)\n{\n    uLong uDate;\n    uDate = (uLong)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}\n\n//  Get Info about the current file in the zipfile, with internal only info\nint unzlocal_GetCurrentFileInfoInternal (unzFile file,\n                                                  unz_file_info *pfile_info,\n                                                  unz_file_info_internal\n                                                  *pfile_info_internal,\n                                                  char *szFileName,\n\t\t\t\t\t\t\t\t\t\t\t\t  uLong fileNameBufferSize,\n                                                  void *extraField,\n\t\t\t\t\t\t\t\t\t\t\t\t  uLong extraFieldBufferSize,\n                                                  char *szComment,\n\t\t\t\t\t\t\t\t\t\t\t\t  uLong commentBufferSize);\n\nint unzlocal_GetCurrentFileInfoInternal (unzFile file, unz_file_info *pfile_info,\n   unz_file_info_internal *pfile_info_internal, char *szFileName,\n   uLong fileNameBufferSize, void *extraField, uLong extraFieldBufferSize,\n   char *szComment, uLong commentBufferSize)\n{\n\tunz_s* s;\n\tunz_file_info file_info;\n\tunz_file_info_internal file_info_internal;\n\tint err=UNZ_OK;\n\tuLong uMagic;\n\tlong lSeek=0;\n\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\tif (lufseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)\n\t\terr=UNZ_ERRNO;\n\n\n\t// we check the magic\n\tif (err==UNZ_OK)\n\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n\t\t\terr=UNZ_ERRNO;\n\t\telse if (uMagic!=0x02014b50)\n\t\t\terr=UNZ_BADZIPFILE;\n\n\tif (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n\n\tif (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tlSeek+=file_info.size_filename;\n\tif ((err==UNZ_OK) && (szFileName!=NULL))\n\t{\n\t\tuLong uSizeRead ;\n\t\tif (file_info.size_filename<fileNameBufferSize)\n\t\t{\n\t\t\t*(szFileName+file_info.size_filename)='\\0';\n\t\t\tuSizeRead = file_info.size_filename;\n\t\t}\n\t\telse\n\t\t\tuSizeRead = fileNameBufferSize;\n\n\t\tif ((file_info.size_filename>0) && (fileNameBufferSize>0))\n\t\t\tif (lufread(szFileName,(uInt)uSizeRead,1,s->file)!=1)\n\t\t\t\terr=UNZ_ERRNO;\n\t\tlSeek -= uSizeRead;\n\t}\n\n\n\tif ((err==UNZ_OK) && (extraField!=NULL))\n\t{\n\t\tuLong uSizeRead ;\n\t\tif (file_info.size_file_extra<extraFieldBufferSize)\n\t\t\tuSizeRead = file_info.size_file_extra;\n\t\telse\n\t\t\tuSizeRead = extraFieldBufferSize;\n\n\t\tif (lSeek!=0)\n\t\t\tif (lufseek(s->file,lSeek,SEEK_CUR)==0)\n\t\t\t\tlSeek=0;\n\t\t\telse\n\t\t\t\terr=UNZ_ERRNO;\n\t\tif ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n\t\t\tif (lufread(extraField,(uInt)uSizeRead,1,s->file)!=1)\n\t\t\t\terr=UNZ_ERRNO;\n\t\tlSeek += file_info.size_file_extra - uSizeRead;\n\t}\n\telse\n\t\tlSeek+=file_info.size_file_extra;\n\n\n\tif ((err==UNZ_OK) && (szComment!=NULL))\n\t{\n\t\tuLong uSizeRead ;\n\t\tif (file_info.size_file_comment<commentBufferSize)\n\t\t{\n\t\t\t*(szComment+file_info.size_file_comment)='\\0';\n\t\t\tuSizeRead = file_info.size_file_comment;\n\t\t}\n\t\telse\n\t\t\tuSizeRead = commentBufferSize;\n\n\t\tif (lSeek!=0)\n\t\t\tif (lufseek(s->file,lSeek,SEEK_CUR)==0)\n\t\t\t\t{} // unused lSeek=0;\n\t\t\telse\n\t\t\t\terr=UNZ_ERRNO;\n\t\tif ((file_info.size_file_comment>0) && (commentBufferSize>0))\n\t\t\tif (lufread(szComment,(uInt)uSizeRead,1,s->file)!=1)\n\t\t\t\terr=UNZ_ERRNO;\n\t\t//unused lSeek+=file_info.size_file_comment - uSizeRead;\n\t}\n\telse {} //unused lSeek+=file_info.size_file_comment;\n\n\tif ((err==UNZ_OK) && (pfile_info!=NULL))\n\t\t*pfile_info=file_info;\n\n\tif ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n\t\t*pfile_info_internal=file_info_internal;\n\n\treturn err;\n}\n\n\n\n//  Write info about the ZipFile in the *pglobal_info structure.\n//  No preparation of the structure is needed\n//  return UNZ_OK if there is no problem.\nint unzGetCurrentFileInfo (unzFile file, unz_file_info *pfile_info,\n  char *szFileName, uLong fileNameBufferSize, void *extraField, uLong extraFieldBufferSize,\n  char *szComment, uLong commentBufferSize)\n{ return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,szFileName,fileNameBufferSize,\n      extraField,extraFieldBufferSize, szComment,commentBufferSize);\n}\n\n\n//  Set the current file of the zipfile to the first file.\n//  return UNZ_OK if there is no problem\nint unzGoToFirstFile (unzFile file)\n{\n\tint err;\n\tunz_s* s;\n\tif (file==NULL) return UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\ts->pos_in_central_dir=s->offset_central_dir;\n\ts->num_file=0;\n\terr=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n\t\t\t\t\t\t\t\t\t\t\t &s->cur_file_info_internal,\n\t\t\t\t\t\t\t\t\t\t\t NULL,0,NULL,0,NULL,0);\n\ts->current_file_ok = (err == UNZ_OK);\n\treturn err;\n}\n\n\n//  Set the current file of the zipfile to the next file.\n//  return UNZ_OK if there is no problem\n//  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\nint unzGoToNextFile (unzFile file)\n{\n\tunz_s* s;\n\tint err;\n\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\tif (!s->current_file_ok)\n\t\treturn UNZ_END_OF_LIST_OF_FILE;\n\tif (s->num_file+1==s->gi.number_entry)\n\t\treturn UNZ_END_OF_LIST_OF_FILE;\n\n\ts->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n\t\t\ts->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n\ts->num_file++;\n\terr = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n\t\t\t\t\t\t\t\t\t\t\t   &s->cur_file_info_internal,\n\t\t\t\t\t\t\t\t\t\t\t   NULL,0,NULL,0,NULL,0);\n\ts->current_file_ok = (err == UNZ_OK);\n\treturn err;\n}\n\n\n//  Try locate the file szFileName in the zipfile.\n//  For the iCaseSensitivity signification, see unzStringFileNameCompare\n//  return value :\n//  UNZ_OK if the file is found. It becomes the current file.\n//  UNZ_END_OF_LIST_OF_FILE if the file is not found\nint unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)\n{\n\tunz_s* s;\n\tint err;\n\n\n\tuLong num_fileSaved;\n\tuLong pos_in_central_dirSaved;\n\n\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n\ts=(unz_s*)file;\n\tif (!s->current_file_ok)\n\t\treturn UNZ_END_OF_LIST_OF_FILE;\n\n\tnum_fileSaved = s->num_file;\n\tpos_in_central_dirSaved = s->pos_in_central_dir;\n\n\terr = unzGoToFirstFile(file);\n\n\twhile (err == UNZ_OK)\n\t{\n\t\tchar szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n\t\tunzGetCurrentFileInfo(file,NULL,\n\t\t\t\t\t\t\t\tszCurrentFileName,sizeof(szCurrentFileName)-1,\n\t\t\t\t\t\t\t\tNULL,0,NULL,0);\n\t\tif (unzStringFileNameCompare(szCurrentFileName,szFileName,iCaseSensitivity)==0)\n\t\t\treturn UNZ_OK;\n\t\terr = unzGoToNextFile(file);\n\t}\n\n\ts->num_file = num_fileSaved ;\n\ts->pos_in_central_dir = pos_in_central_dirSaved ;\n\treturn err;\n}\n\n\n//  Read the local header of the current zipfile\n//  Check the coherency of the local header and info in the end of central\n//        directory about this file\n//  store in *piSizeVar the size of extra info in local header\n//        (filename and size of extra field data)\nint unzlocal_CheckCurrentFileCoherencyHeader (unz_s *s,uInt *piSizeVar,\n  uLong *poffset_local_extrafield, uInt  *psize_local_extrafield)\n{\n\tuLong uMagic,uData,uFlags;\n\tuLong size_filename;\n\tuLong size_extra_field;\n\tint err=UNZ_OK;\n\n\t*piSizeVar = 0;\n\t*poffset_local_extrafield = 0;\n\t*psize_local_extrafield = 0;\n\n\tif (lufseek(s->file,s->cur_file_info_internal.offset_curfile + s->byte_before_the_zipfile,SEEK_SET)!=0)\n\t\treturn UNZ_ERRNO;\n\n\n\tif (err==UNZ_OK)\n\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n\t\t\terr=UNZ_ERRNO;\n\t\telse if (uMagic!=0x04034b50)\n\t\t\terr=UNZ_BADZIPFILE;\n\n\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n//\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n//\t\terr=UNZ_BADZIPFILE;\n\tif (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n\t\terr=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) // date/time\n\t\terr=UNZ_ERRNO;\n\n\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) // crc\n\t\terr=UNZ_ERRNO;\n\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&\n\t\t                      ((uFlags & 8)==0))\n\t\terr=UNZ_BADZIPFILE;\n\n\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) // size compr\n\t\terr=UNZ_ERRNO;\n\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&\n\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n\t\terr=UNZ_BADZIPFILE;\n\n\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) // size uncompr\n\t\terr=UNZ_ERRNO;\n\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) &&\n\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n\t\terr=UNZ_BADZIPFILE;\n\n\n\tif (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\telse if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n\t\terr=UNZ_BADZIPFILE;\n\n\t*piSizeVar += (uInt)size_filename;\n\n\tif (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)\n\t\terr=UNZ_ERRNO;\n\t*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n\t\t\t\t\t\t\t\t\tSIZEZIPLOCALHEADER + size_filename;\n\t*psize_local_extrafield = (uInt)size_extra_field;\n\n\t*piSizeVar += (uInt)size_extra_field;\n\n\treturn err;\n}\n\n\n\n\n\n//  Open for reading data the current file in the zipfile.\n//  If there is no error and the file is opened, the return value is UNZ_OK.\nint unzOpenCurrentFile (unzFile file, const char *password)\n{\n\tint err;\n\tint Store;\n\tuInt iSizeVar;\n\tunz_s* s;\n\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n\tuLong offset_local_extrafield;  // offset of the local extra field\n\tuInt  size_local_extrafield;    // size of the local extra field\n\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n\tif (!s->current_file_ok)\n\t\treturn UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n\tif (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,\n\t\t\t\t&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n\t\treturn UNZ_BADZIPFILE;\n\n\tpfile_in_zip_read_info = (file_in_zip_read_info_s*)zmalloc(sizeof(file_in_zip_read_info_s));\n\tif (pfile_in_zip_read_info==NULL)\n\t\treturn UNZ_INTERNALERROR;\n\n\tpfile_in_zip_read_info->read_buffer=(char*)zmalloc(UNZ_BUFSIZE);\n\tpfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n\tpfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n\tpfile_in_zip_read_info->pos_local_extrafield=0;\n\n\tif (pfile_in_zip_read_info->read_buffer==NULL)\n\t{\n\t\tif (pfile_in_zip_read_info!=0) zfree(pfile_in_zip_read_info); //unused pfile_in_zip_read_info=0;\n\t\treturn UNZ_INTERNALERROR;\n\t}\n\n\tpfile_in_zip_read_info->stream_initialised=0;\n\n\tif ((s->cur_file_info.compression_method!=0) && (s->cur_file_info.compression_method!=Z_DEFLATED))\n        { // unused err=UNZ_BADZIPFILE;\n        }\n\tStore = s->cur_file_info.compression_method==0;\n\n\tpfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n\tpfile_in_zip_read_info->crc32=0;\n\tpfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n\tpfile_in_zip_read_info->file=s->file;\n\tpfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n\tif (!Store)\n\t{\n\t  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n\t  pfile_in_zip_read_info->stream.zfree = (free_func)0;\n\t  pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n\n          err=inflateInit2(&pfile_in_zip_read_info->stream);\n\t  if (err == Z_OK)\n\t    pfile_in_zip_read_info->stream_initialised=1;\n        // windowBits is passed < 0 to tell that there is no zlib header.\n        // Note that in this case inflate *requires* an extra \"dummy\" byte\n        // after the compressed stream in order to complete decompression and\n        // return Z_STREAM_END.\n        // In unzip, i don't wait absolutely Z_STREAM_END because I known the\n        // size of both compressed and uncompressed data\n\t}\n\tpfile_in_zip_read_info->rest_read_compressed = s->cur_file_info.compressed_size ;\n\tpfile_in_zip_read_info->rest_read_uncompressed = s->cur_file_info.uncompressed_size ;\n  pfile_in_zip_read_info->encrypted = (s->cur_file_info.flag&1)!=0;\n  bool extlochead = (s->cur_file_info.flag&8)!=0;\n  if (extlochead) pfile_in_zip_read_info->crcenctest = (char)((s->cur_file_info.dosDate>>8)&0xff);\n  else pfile_in_zip_read_info->crcenctest = (char)(s->cur_file_info.crc >> 24);\n  pfile_in_zip_read_info->encheadleft = (pfile_in_zip_read_info->encrypted?12:0);\n  pfile_in_zip_read_info->keys[0] = 305419896L;\n  pfile_in_zip_read_info->keys[1] = 591751049L;\n  pfile_in_zip_read_info->keys[2] = 878082192L;\n  for (const char *cp=password; cp!=0 && *cp!=0; cp++) Uupdate_keys(pfile_in_zip_read_info->keys,*cp);\n\n\tpfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n\t\t\t  iSizeVar;\n\n\tpfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n\ts->pfile_in_zip_read = pfile_in_zip_read_info;\n\n  return UNZ_OK;\n}\n\n\n//  Read bytes from the current file.\n//  buf contain buffer where data must be copied\n//  len the size of buf.\n//  return the number of byte copied if somes bytes are copied (and also sets *reached_eof)\n//  return 0 if the end of file was reached. (and also sets *reached_eof).\n//  return <0 with error code if there is an error. (in which case *reached_eof is meaningless)\n//    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\nint unzReadCurrentFile  (unzFile file, voidp buf, unsigned len, bool *reached_eof)\n{ int err=UNZ_OK;\n  uInt iRead = 0;\n  if (reached_eof!=0) *reached_eof=false;\n\n  unz_s *s = (unz_s*)file;\n  if (s==NULL) return UNZ_PARAMERROR;\n\n  file_in_zip_read_info_s* pfile_in_zip_read_info = s->pfile_in_zip_read;\n  if (pfile_in_zip_read_info==NULL) return UNZ_PARAMERROR;\n  if ((pfile_in_zip_read_info->read_buffer == NULL)) return UNZ_END_OF_LIST_OF_FILE;\n  if (len==0) return 0;\n\n  pfile_in_zip_read_info->stream.next_out = (Byte*)buf;\n  pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n  if (len>pfile_in_zip_read_info->rest_read_uncompressed)\n  { pfile_in_zip_read_info->stream.avail_out = (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n  }\n\n  while (pfile_in_zip_read_info->stream.avail_out>0)\n  { if ((pfile_in_zip_read_info->stream.avail_in==0) && (pfile_in_zip_read_info->rest_read_compressed>0))\n    { uInt uReadThis = UNZ_BUFSIZE;\n      if (pfile_in_zip_read_info->rest_read_compressed<uReadThis) uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n      if (uReadThis == 0) {if (reached_eof!=0) *reached_eof=true; return UNZ_EOF;}\n      if (lufseek(pfile_in_zip_read_info->file, pfile_in_zip_read_info->pos_in_zipfile + pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0) return UNZ_ERRNO;\n      if (lufread(pfile_in_zip_read_info->read_buffer,uReadThis,1,pfile_in_zip_read_info->file)!=1) return UNZ_ERRNO;\n      pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n      pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n      pfile_in_zip_read_info->stream.next_in = (Byte*)pfile_in_zip_read_info->read_buffer;\n      pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n      //\n      if (pfile_in_zip_read_info->encrypted)\n      { char *buf = (char*)pfile_in_zip_read_info->stream.next_in;\n        for (unsigned int i=0; i<uReadThis; i++) buf[i]=zdecode(pfile_in_zip_read_info->keys,buf[i]);\n      }\n    }\n\n    unsigned int uDoEncHead = pfile_in_zip_read_info->encheadleft;\n    if (uDoEncHead>pfile_in_zip_read_info->stream.avail_in) uDoEncHead=pfile_in_zip_read_info->stream.avail_in;\n    if (uDoEncHead>0)\n    { char bufcrc=pfile_in_zip_read_info->stream.next_in[uDoEncHead-1];\n      pfile_in_zip_read_info->rest_read_uncompressed-=uDoEncHead;\n      pfile_in_zip_read_info->stream.avail_in -= uDoEncHead;\n      pfile_in_zip_read_info->stream.next_in += uDoEncHead;\n      pfile_in_zip_read_info->encheadleft -= uDoEncHead;\n      if (pfile_in_zip_read_info->encheadleft==0)\n      { if (bufcrc!=pfile_in_zip_read_info->crcenctest) return UNZ_PASSWORD;\n      }\n    }\n\n    if (pfile_in_zip_read_info->compression_method==0)\n    { uInt uDoCopy,i ;\n      if (pfile_in_zip_read_info->stream.avail_out < pfile_in_zip_read_info->stream.avail_in)\n      { uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n      }\n      else\n      { uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n      }\n      for (i=0;i<uDoCopy;i++) *(pfile_in_zip_read_info->stream.next_out+i) = *(pfile_in_zip_read_info->stream.next_in+i);\n      pfile_in_zip_read_info->crc32 = ucrc32(pfile_in_zip_read_info->crc32,pfile_in_zip_read_info->stream.next_out,uDoCopy);\n      pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n      pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n      pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n      pfile_in_zip_read_info->stream.next_out += uDoCopy;\n      pfile_in_zip_read_info->stream.next_in += uDoCopy;\n      pfile_in_zip_read_info->stream.total_out += uDoCopy;\n      iRead += uDoCopy;\n      if (pfile_in_zip_read_info->rest_read_uncompressed==0) {if (reached_eof!=0) *reached_eof=true;}\n    }\n    else\n    { uLong uTotalOutBefore,uTotalOutAfter;\n      const Byte *bufBefore;\n      uLong uOutThis;\n      int flush=Z_SYNC_FLUSH;\n      uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n      bufBefore = pfile_in_zip_read_info->stream.next_out;\n      //\n      err=inflate(&pfile_in_zip_read_info->stream,flush);\n      //\n      uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n      uOutThis = uTotalOutAfter-uTotalOutBefore;\n      pfile_in_zip_read_info->crc32 = ucrc32(pfile_in_zip_read_info->crc32,bufBefore,(uInt)(uOutThis));\n      pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n      iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n      if (err==Z_STREAM_END || pfile_in_zip_read_info->rest_read_uncompressed==0)\n      { if (reached_eof!=0) *reached_eof=true;\n        return iRead;\n      }\n      if (err!=Z_OK) break;\n    }\n  }\n\n  if (err==Z_OK) return iRead;\n  return err;\n}\n\n\n//  Give the current position in uncompressed data\nz_off_t unztell (unzFile file)\n{\n\tunz_s* s;\n\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n\tif (pfile_in_zip_read_info==NULL)\n\t\treturn UNZ_PARAMERROR;\n\n\treturn (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}\n\n\n//  return 1 if the end of file was reached, 0 elsewhere\nint unzeof (unzFile file)\n{\n\tunz_s* s;\n\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n\tif (pfile_in_zip_read_info==NULL)\n\t\treturn UNZ_PARAMERROR;\n\n\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n\n\n//  Read extra field from the current file (opened by unzOpenCurrentFile)\n//  This is the local-header version of the extra field (sometimes, there is\n//    more info in the local-header version than in the central-header)\n//  if buf==NULL, it return the size of the local extra field that can be read\n//  if buf!=NULL, len is the size of the buffer, the extra header is copied in buf.\n//  the return value is the number of bytes copied in buf, or (if <0) the error code\nint unzGetLocalExtrafield (unzFile file,voidp buf,unsigned len)\n{\n\tunz_s* s;\n\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n\tuInt read_now;\n\tuLong size_to_read;\n\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n\tif (pfile_in_zip_read_info==NULL)\n\t\treturn UNZ_PARAMERROR;\n\n\tsize_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n\t\t\t\tpfile_in_zip_read_info->pos_local_extrafield);\n\n\tif (buf==NULL)\n\t\treturn (int)size_to_read;\n\n\tif (len>size_to_read)\n\t\tread_now = (uInt)size_to_read;\n\telse\n\t\tread_now = (uInt)len ;\n\n\tif (read_now==0)\n\t\treturn 0;\n\n\tif (lufseek(pfile_in_zip_read_info->file, pfile_in_zip_read_info->offset_local_extrafield +  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)\n\t\treturn UNZ_ERRNO;\n\n\tif (lufread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)\n\t\treturn UNZ_ERRNO;\n\n\treturn (int)read_now;\n}\n\n//  Close the file in zip opened with unzipOpenCurrentFile\n//  Return UNZ_CRCERROR if all the file was read but the CRC is not good\nint unzCloseCurrentFile (unzFile file)\n{\n\tint err=UNZ_OK;\n\n\tunz_s* s;\n\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n\tif (file==NULL)\n\t\treturn UNZ_PARAMERROR;\n\ts=(unz_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n\tif (pfile_in_zip_read_info==NULL)\n\t\treturn UNZ_PARAMERROR;\n\n\n\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n\t{\n\t\tif (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n\t\t\terr=UNZ_CRCERROR;\n\t}\n\n\n\tif (pfile_in_zip_read_info->read_buffer!=0)\n        { void *buf = pfile_in_zip_read_info->read_buffer;\n          zfree(buf);\n          pfile_in_zip_read_info->read_buffer=0;\n        }\n\tpfile_in_zip_read_info->read_buffer = NULL;\n\tif (pfile_in_zip_read_info->stream_initialised)\n\t\tinflateEnd(&pfile_in_zip_read_info->stream);\n\n\tpfile_in_zip_read_info->stream_initialised = 0;\n        if (pfile_in_zip_read_info!=0) zfree(pfile_in_zip_read_info); // unused pfile_in_zip_read_info=0;\n\n    s->pfile_in_zip_read=NULL;\n\n\treturn err;\n}\n\n\n//  Get the global comment string of the ZipFile, in the szComment buffer.\n//  uSizeBuf is the size of the szComment buffer.\n//  return the number of byte copied or an error code <0\nint unzGetGlobalComment (unzFile file, char *szComment, uLong uSizeBuf)\n{ //int err=UNZ_OK;\n  unz_s* s;\n  uLong uReadThis ;\n  if (file==NULL) return UNZ_PARAMERROR;\n  s=(unz_s*)file;\n  uReadThis = uSizeBuf;\n  if (uReadThis>s->gi.size_comment) uReadThis = s->gi.size_comment;\n  if (lufseek(s->file,s->central_pos+22,SEEK_SET)!=0) return UNZ_ERRNO;\n  if (uReadThis>0)\n  { *szComment='\\0';\n    if (lufread(szComment,(uInt)uReadThis,1,s->file)!=1) return UNZ_ERRNO;\n  }\n  if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment)) *(szComment+s->gi.size_comment)='\\0';\n  return (int)uReadThis;\n}\n\n\n\n\n\nint unzOpenCurrentFile (unzFile file, const char *password);\nint unzReadCurrentFile (unzFile file, void *buf, unsigned len);\nint unzCloseCurrentFile (unzFile file);\n\n\ntypedef unsigned __int32 lutime_t;       // define it ourselves since we don't include time.h\n\nFILETIME timet2filetime(const lutime_t t)\n{ LONGLONG i = Int32x32To64(t,10000000) + 116444736000000000;\n  FILETIME ft;\n  ft.dwLowDateTime = (DWORD) i;\n  ft.dwHighDateTime = (DWORD)(i >>32);\n  return ft;\n}\n\nFILETIME dosdatetime2filetime(WORD dosdate,WORD dostime)\n{ // date: bits 0-4 are day of month 1-31. Bits 5-8 are month 1..12. Bits 9-15 are year-1980\n  // time: bits 0-4 are seconds/2, bits 5-10 are minute 0..59. Bits 11-15 are hour 0..23\n  SYSTEMTIME st;\n  st.wYear = (WORD)(((dosdate>>9)&0x7f) + 1980);\n  st.wMonth = (WORD)((dosdate>>5)&0xf);\n  st.wDay = (WORD)(dosdate&0x1f);\n  st.wHour = (WORD)((dostime>>11)&0x1f);\n  st.wMinute = (WORD)((dostime>>5)&0x3f);\n  st.wSecond = (WORD)((dostime&0x1f)*2);\n  st.wMilliseconds = 0;\n  FILETIME ft; SystemTimeToFileTime(&st,&ft);\n  return ft;\n}\n\n\n\nclass TUnzip\n{ public:\n  TUnzip(const char *pwd) : uf(0), unzbuf(0), currentfile(-1), czei(-1), password(0) {if (pwd!=0) {password=new char[strlen(pwd)+1]; strcpy_s(password,MAX_PATH,pwd);}}\n  ~TUnzip() {if (password!=0) delete[] password; password=0; if (unzbuf!=0) delete[] unzbuf; unzbuf=0;}\n\n  unzFile uf; int currentfile; ZIPENTRY cze; int czei;\n  char *password;\n  char *unzbuf;            // lazily created and destroyed, used by Unzip\n  TCHAR rootdir[MAX_PATH]; // includes a trailing slash\n\n  ZRESULT Open(void *z,unsigned int len,DWORD flags);\n  ZRESULT Get(int index,ZIPENTRY *ze);\n  ZRESULT Find(const TCHAR *name,bool ic,int *index,ZIPENTRY *ze);\n  ZRESULT Unzip(int index,void *dst,unsigned int len,DWORD flags);\n  ZRESULT SetUnzipBaseDir(const TCHAR *dir);\n  ZRESULT Close();\n};\n\n\nZRESULT TUnzip::Open(void *z,unsigned int len,DWORD flags)\n{ if (uf!=0 || currentfile!=-1) return ZR_NOTINITED;\n  //\n#ifdef GetCurrentDirectory\n  GetCurrentDirectory(MAX_PATH,rootdir);\n#else\n  _tcscpy(rootdir,_T(\"\\\\\"));\n#endif\n  TCHAR lastchar = rootdir[_tcslen(rootdir)-1];\n  if (lastchar!='\\\\' && lastchar!='/') _tcscat_s(rootdir,_T(\"\\\\\"));\n  //\n  if (flags==ZIP_HANDLE)\n  { // test if we can seek on it. We can't use GetFileType(h)==FILE_TYPE_DISK since it's not on CE.\n    DWORD res = SetFilePointer(z,0,0,FILE_CURRENT);\n    bool canseek = (res!=0xFFFFFFFF);\n    if (!canseek) return ZR_SEEK;\n  }\n  ZRESULT e; LUFILE *f = lufopen(z,len,flags,&e);\n  if (f==NULL) return e;\n  uf = unzOpenInternal(f);\n  if (uf==0) return ZR_NOFILE;\n  return ZR_OK;\n}\n\nZRESULT TUnzip::SetUnzipBaseDir(const TCHAR *dir)\n{\n  _tcscpy_s(rootdir, MAX_PATH, dir);\n  TCHAR lastchar = rootdir[_tcslen(rootdir)-1];\n  if (lastchar!='\\\\' && lastchar!='/') _tcscat_s(rootdir,_T(\"\\\\\"));\n  return ZR_OK;\n}\n\nZRESULT TUnzip::Get(int index,ZIPENTRY *ze)\n{ if (index<-1 || index>=(int)uf->gi.number_entry) return ZR_ARGS;\n  if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;\n  if (index==czei && index!=-1) {memcpy(ze,&cze,sizeof(ZIPENTRY)); return ZR_OK;}\n  if (index==-1)\n  { ze->index = uf->gi.number_entry;\n    ze->name[0]=0;\n    ze->attr=0;\n    ze->atime.dwLowDateTime=0; ze->atime.dwHighDateTime=0;\n    ze->ctime.dwLowDateTime=0; ze->ctime.dwHighDateTime=0;\n    ze->mtime.dwLowDateTime=0; ze->mtime.dwHighDateTime=0;\n    ze->comp_size=0;\n    ze->unc_size=0;\n    return ZR_OK;\n  }\n  if (index<(int)uf->num_file) unzGoToFirstFile(uf);\n  while ((int)uf->num_file<index) unzGoToNextFile(uf);\n  unz_file_info ufi; char fn[MAX_PATH];\n  unzGetCurrentFileInfo(uf,&ufi,fn,MAX_PATH,NULL,0,NULL,0);\n  // now get the extra header. We do this ourselves, instead of\n  // calling unzOpenCurrentFile &c., to avoid allocating more than necessary.\n  unsigned int extralen,iSizeVar; unsigned long offset;\n  int res = unzlocal_CheckCurrentFileCoherencyHeader(uf,&iSizeVar,&offset,&extralen);\n  if (res!=UNZ_OK) return ZR_CORRUPT;\n  if (lufseek(uf->file,offset,SEEK_SET)!=0) return ZR_READ;\n  unsigned char *extra = new unsigned char[extralen];\n  if (lufread(extra,1,(uInt)extralen,uf->file)!=extralen) {delete[] extra; return ZR_READ;}\n  //\n  ze->index=uf->num_file;\n  TCHAR tfn[MAX_PATH];\n#ifdef UNICODE\n  MultiByteToWideChar(CP_UTF8,0,fn,-1,tfn,MAX_PATH);\n#else\n  strcpy(tfn,fn);\n#endif\n  // As a safety feature: if the zip filename had sneaky stuff\n  // like \"c:\\windows\\file.txt\" or \"\\windows\\file.txt\" or \"fred\\..\\..\\..\\windows\\file.txt\"\n  // then we get rid of them all. That way, when the programmer does UnzipItem(hz,i,ze.name),\n  // it won't be a problem. (If the programmer really did want to get the full evil information,\n  // then they can edit out this security feature from here).\n  // In particular, we chop off any prefixes that are \"c:\\\" or \"\\\" or \"/\" or \"[stuff]\\..\" or \"[stuff]/..\"\n  const TCHAR *sfn=tfn;\n  for (;;)\n  { if (sfn[0]!=0 && sfn[1]==':') {sfn+=2; continue;}\n    if (sfn[0]=='\\\\') {sfn++; continue;}\n    if (sfn[0]=='/') {sfn++; continue;}\n    const TCHAR *c;\n    c=_tcsstr(sfn,_T(\"\\\\..\\\\\")); if (c!=0) {sfn=c+4; continue;}\n    c=_tcsstr(sfn,_T(\"\\\\../\")); if (c!=0) {sfn=c+4; continue;}\n    c=_tcsstr(sfn,_T(\"/../\")); if (c!=0) {sfn=c+4; continue;}\n    c=_tcsstr(sfn,_T(\"/..\\\\\")); if (c!=0) {sfn=c+4; continue;}\n    break;\n  }\n  _tcscpy_s(ze->name, MAX_PATH, sfn);\n\n\n  // zip has an 'attribute' 32bit value. Its lower half is windows stuff\n  // its upper half is standard unix stat.st_mode. We'll start trying\n  // to read it in unix mode\n  unsigned long a = ufi.external_fa;\n  bool isdir  =   (a&0x40000000)!=0;\n  bool readonly=  (a&0x00800000)==0;\n  //bool readable=  (a&0x01000000)!=0; // unused\n  //bool executable=(a&0x00400000)!=0; // unused\n  bool hidden=false, system=false, archive=true;\n  // but in normal hostmodes these are overridden by the lower half...\n  int host = ufi.version>>8;\n  if (host==0 || host==7 || host==11 || host==14)\n  { readonly=  (a&0x00000001)!=0;\n    hidden=    (a&0x00000002)!=0;\n    system=    (a&0x00000004)!=0;\n    isdir=     (a&0x00000010)!=0;\n    archive=   (a&0x00000020)!=0;\n  }\n  ze->attr=0;\n  if (isdir) ze->attr |= FILE_ATTRIBUTE_DIRECTORY;\n  if (archive) ze->attr|=FILE_ATTRIBUTE_ARCHIVE;\n  if (hidden) ze->attr|=FILE_ATTRIBUTE_HIDDEN;\n  if (readonly) ze->attr|=FILE_ATTRIBUTE_READONLY;\n  if (system) ze->attr|=FILE_ATTRIBUTE_SYSTEM;\n  ze->comp_size = ufi.compressed_size;\n  ze->unc_size = ufi.uncompressed_size;\n  //\n  WORD dostime = (WORD)(ufi.dosDate&0xFFFF);\n  WORD dosdate = (WORD)((ufi.dosDate>>16)&0xFFFF);\n  FILETIME ftd = dosdatetime2filetime(dosdate,dostime);\n  FILETIME ft; LocalFileTimeToFileTime(&ftd,&ft);\n  ze->atime=ft; ze->ctime=ft; ze->mtime=ft;\n  // the zip will always have at least that dostime. But if it also has\n  // an extra header, then we'll instead get the info from that.\n  unsigned int epos=0;\n  while (epos+4<extralen)\n  { char etype[3]; etype[0]=extra[epos+0]; etype[1]=extra[epos+1]; etype[2]=0;\n    int size = extra[epos+2];\n    if (strcmp(etype,\"UT\")!=0) {epos += 4+size; continue;}\n    int flags = extra[epos+4];\n    bool hasmtime = (flags&1)!=0;\n    bool hasatime = (flags&2)!=0;\n    bool hasctime = (flags&4)!=0;\n    epos+=5;\n    if (hasmtime)\n    { lutime_t mtime = ((extra[epos+0])<<0) | ((extra[epos+1])<<8) |((extra[epos+2])<<16) | ((extra[epos+3])<<24);\n\t  epos+=4;\n      ze->mtime = timet2filetime(mtime);\n    }\n    if (hasatime)\n    { lutime_t atime = ((extra[epos+0])<<0) | ((extra[epos+1])<<8) |((extra[epos+2])<<16) | ((extra[epos+3])<<24);\n      epos+=4;\n      ze->atime = timet2filetime(atime);\n    }\n    if (hasctime)\n    { lutime_t ctime = ((extra[epos+0])<<0) | ((extra[epos+1])<<8) |((extra[epos+2])<<16) | ((extra[epos+3])<<24);\n      epos+=4;\n      ze->ctime = timet2filetime(ctime);\n    }\n    break;\n  }\n  //\n  if (extra!=0) delete[] extra;\n  memcpy(&cze,ze,sizeof(ZIPENTRY)); czei=index;\n  return ZR_OK;\n}\n\nZRESULT TUnzip::Find(const TCHAR *tname,bool ic,int *index,ZIPENTRY *ze)\n{ char name[MAX_PATH];\n#ifdef UNICODE\n  WideCharToMultiByte(CP_UTF8,0,tname,-1,name,MAX_PATH,0,0);\n#else\n  strcpy(name,tname);\n#endif\n  int res = unzLocateFile(uf,name,ic?CASE_INSENSITIVE:CASE_SENSITIVE);\n  if (res!=UNZ_OK)\n  { if (index!=0) *index=-1;\n    if (ze!=NULL) {ZeroMemory(ze,sizeof(ZIPENTRY)); ze->index=-1;}\n    return ZR_NOTFOUND;\n  }\n  if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;\n  int i = (int)uf->num_file;\n  if (index!=NULL) *index=i;\n  if (ze!=NULL)\n  { ZRESULT zres = Get(i,ze);\n    if (zres!=ZR_OK) return zres;\n  }\n  return ZR_OK;\n}\n\nvoid EnsureDirectory(const TCHAR *rootdir, const TCHAR *dir)\n{ if (rootdir!=0 && GetFileAttributes(rootdir)==0xFFFFFFFF) CreateDirectory(rootdir,0);\n  if (*dir==0) return;\n  const TCHAR *lastslash=dir, *c=lastslash;\n  while (*c!=0) {if (*c=='/' || *c=='\\\\') lastslash=c; c++;}\n  const TCHAR *name=lastslash;\n  if (lastslash!=dir)\n  { TCHAR tmp[MAX_PATH]; memcpy(tmp,dir,sizeof(TCHAR)*(lastslash-dir));\n    tmp[lastslash-dir]=0;\n    EnsureDirectory(rootdir,tmp);\n    name++;\n  }\n  TCHAR cd[MAX_PATH]; *cd=0; if (rootdir!=0) _tcscpy_s(cd, MAX_PATH, rootdir); _tcscat_s(cd,dir);\n  if (GetFileAttributes(cd)==0xFFFFFFFF) CreateDirectory(cd,NULL);\n}\n\n\n\nZRESULT TUnzip::Unzip(int index,void *dst,unsigned int len,DWORD flags)\n{ if (flags!=ZIP_MEMORY && flags!=ZIP_FILENAME && flags!=ZIP_HANDLE) return ZR_ARGS;\n  if (flags==ZIP_MEMORY)\n  { if (index!=currentfile)\n    { if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;\n      if (index>=(int)uf->gi.number_entry) return ZR_ARGS;\n      if (index<(int)uf->num_file) unzGoToFirstFile(uf);\n      while ((int)uf->num_file<index) unzGoToNextFile(uf);\n      unzOpenCurrentFile(uf,password); currentfile=index;\n    }\n    bool reached_eof;\n    int res = unzReadCurrentFile(uf,dst,len,&reached_eof);\n    if (res<=0) {unzCloseCurrentFile(uf); currentfile=-1;}\n    if (reached_eof) return ZR_OK;\n    if (res>0) return ZR_MORE;\n    if (res==UNZ_PASSWORD) return ZR_PASSWORD;\n    return ZR_FLATE;\n  }\n  // otherwise we're writing to a handle or a file\n  if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;\n  if (index>=(int)uf->gi.number_entry) return ZR_ARGS;\n  if (index<(int)uf->num_file) unzGoToFirstFile(uf);\n  while ((int)uf->num_file<index) unzGoToNextFile(uf);\n  ZIPENTRY ze; Get(index,&ze);\n  // zipentry=directory is handled specially\n  if ((ze.attr&FILE_ATTRIBUTE_DIRECTORY)!=0)\n  { if (flags==ZIP_HANDLE) return ZR_OK; // don't do anything\n    const TCHAR *dir = (const TCHAR*)dst;\n    bool isabsolute = (dir[0]=='/' || dir[0]=='\\\\' || (dir[0]!=0 && dir[1]==':'));\n    if (isabsolute) EnsureDirectory(0,dir); else EnsureDirectory(rootdir,dir);\n    return ZR_OK;\n  }\n  // otherwise, we write the zipentry to a file/handle\n  HANDLE h;\n  if (flags==ZIP_HANDLE) h=dst;\n  else\n  { const TCHAR *ufn = (const TCHAR*)dst;\n    // We'll qualify all relative names to our root dir, and leave absolute names as they are\n    // ufn=\"zipfile.txt\"  dir=\"\"  name=\"zipfile.txt\"  fn=\"c:\\\\currentdir\\\\zipfile.txt\"\n    // ufn=\"dir1/dir2/subfile.txt\"  dir=\"dir1/dir2/\"  name=\"subfile.txt\"  fn=\"c:\\\\currentdir\\\\dir1/dir2/subfiles.txt\"\n    // ufn=\"\\z\\file.txt\"  dir=\"\\z\\\"  name=\"file.txt\"  fn=\"\\z\\file.txt\"\n    // This might be a security risk, in the case where we just use the zipentry's name as \"ufn\", where\n    // a malicious zip could unzip itself into c:\\windows. Our solution is that GetZipItem (which\n    // is how the user retrieve's the file's name within the zip) never returns absolute paths.\n    const TCHAR *name=ufn; const TCHAR *c=name; while (*c!=0) {if (*c=='/' || *c=='\\\\') name=c+1; c++;}\n    TCHAR dir[MAX_PATH]; _tcscpy_s(dir, MAX_PATH, ufn); if (name==ufn) *dir=0; else dir[name-ufn]=0;\n    TCHAR fn[MAX_PATH];\n    bool isabsolute = (dir[0]=='/' || dir[0]=='\\\\' || (dir[0]!=0 && dir[1]==':'));\n    if (isabsolute) {wsprintf(fn,_T(\"%s%s\"),dir,name); EnsureDirectory(0,dir);}\n    else {wsprintf(fn,_T(\"%s%s%s\"),rootdir,dir,name); EnsureDirectory(rootdir,dir);}\n    //\n    h = CreateFile(fn,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,ze.attr,NULL);\n  }\n  if (h==INVALID_HANDLE_VALUE) return ZR_NOFILE;\n  unzOpenCurrentFile(uf,password);\n  if (unzbuf==0) unzbuf=new char[16384]; DWORD haderr=0;\n  //\n\n  for (; haderr==0;)\n  { bool reached_eof;\n    int res = unzReadCurrentFile(uf,unzbuf,16384,&reached_eof);\n    if (res==UNZ_PASSWORD) {haderr=ZR_PASSWORD; break;}\n    if (res<0) {haderr=ZR_FLATE; break;}\n    if (res>0) {DWORD writ; BOOL bres=WriteFile(h,unzbuf,res,&writ,NULL); if (!bres) {haderr=ZR_WRITE; break;}}\n    if (reached_eof) break;\n    if (res==0) {haderr=ZR_FLATE; break;}\n  }\n  if (!haderr) SetFileTime(h,&ze.ctime,&ze.atime,&ze.mtime); // may fail if it was a pipe\n  if (flags!=ZIP_HANDLE) CloseHandle(h);\n  unzCloseCurrentFile(uf);\n  if (haderr!=0) return haderr;\n  return ZR_OK;\n}\n\nZRESULT TUnzip::Close()\n{ if (currentfile!=-1) unzCloseCurrentFile(uf); currentfile=-1;\n  if (uf!=0) unzClose(uf); uf=0;\n  return ZR_OK;\n}\n\n\n\n\n\nZRESULT lasterrorU=ZR_OK;\n\nunsigned int FormatZipMessageU(ZRESULT code, TCHAR *buf,unsigned int len)\n{ if (code==ZR_RECENT) code=lasterrorU;\n  const TCHAR *msg=_T(\"unknown zip result code\");\n  switch (code)\n  { case ZR_OK: msg=_T(\"Success\"); break;\n    case ZR_NODUPH: msg=_T(\"Culdn't duplicate handle\"); break;\n    case ZR_NOFILE: msg=_T(\"Couldn't create/open file\"); break;\n    case ZR_NOALLOC: msg=_T(\"Failed to allocate memory\"); break;\n    case ZR_WRITE: msg=_T(\"Error writing to file\"); break;\n    case ZR_NOTFOUND: msg=_T(\"File not found in the zipfile\"); break;\n    case ZR_MORE: msg=_T(\"Still more data to unzip\"); break;\n    case ZR_CORRUPT: msg=_T(\"Zipfile is corrupt or not a zipfile\"); break;\n    case ZR_READ: msg=_T(\"Error reading file\"); break;\n    case ZR_PASSWORD: msg=_T(\"Correct password required\"); break;\n    case ZR_ARGS: msg=_T(\"Caller: faulty arguments\"); break;\n    case ZR_PARTIALUNZ: msg=_T(\"Caller: the file had already been partially unzipped\"); break;\n    case ZR_NOTMMAP: msg=_T(\"Caller: can only get memory of a memory zipfile\"); break;\n    case ZR_MEMSIZE: msg=_T(\"Caller: not enough space allocated for memory zipfile\"); break;\n    case ZR_FAILED: msg=_T(\"Caller: there was a previous error\"); break;\n    case ZR_ENDED: msg=_T(\"Caller: additions to the zip have already been ended\"); break;\n    case ZR_ZMODE: msg=_T(\"Caller: mixing creation and opening of zip\"); break;\n    case ZR_NOTINITED: msg=_T(\"Zip-bug: internal initialisation not completed\"); break;\n    case ZR_SEEK: msg=_T(\"Zip-bug: trying to seek the unseekable\"); break;\n    case ZR_MISSIZE: msg=_T(\"Zip-bug: the anticipated size turned out wrong\"); break;\n    case ZR_NOCHANGE: msg=_T(\"Zip-bug: tried to change mind, but not allowed\"); break;\n    case ZR_FLATE: msg=_T(\"Zip-bug: an internal error during flation\"); break;\n  }\n  unsigned int mlen=(unsigned int)_tcslen(msg);\n  if (buf==0 || len==0) return mlen;\n  unsigned int n=mlen; if (n+1>len) n=len-1;\n  _tcsncpy_s(buf,MAX_PATH,msg,n); buf[n]=0;\n  return mlen;\n}\n\n\ntypedef struct\n{ DWORD flag;\n  TUnzip *unz;\n} TUnzipHandleData;\n\nHZIP OpenZipInternal(void *z,unsigned int len,DWORD flags, const char *password)\n{ TUnzip *unz = new TUnzip(password);\n  lasterrorU = unz->Open(z,len,flags);\n  if (lasterrorU!=ZR_OK) {delete unz; return 0;}\n  TUnzipHandleData *han = new TUnzipHandleData;\n  han->flag=1; han->unz=unz; return (HZIP)han;\n}\nHZIP OpenZipHandle(HANDLE h, const char *password) {return OpenZipInternal((void*)h,0,ZIP_HANDLE,password);}\nHZIP OpenZip(const TCHAR *fn, const char *password) {return OpenZipInternal((void*)fn,0,ZIP_FILENAME,password);}\nHZIP OpenZip(void *z,unsigned int len, const char *password) {return OpenZipInternal(z,len,ZIP_MEMORY,password);}\n\n\nZRESULT GetZipItem(HZIP hz, int index, ZIPENTRY *ze)\n{ ze->index=0; *ze->name=0; ze->unc_size=0;\n  if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}\n  TUnzip *unz = han->unz;\n  lasterrorU = unz->Get(index,ze);\n  return lasterrorU;\n}\n\nZRESULT FindZipItem(HZIP hz, const TCHAR *name, bool ic, int *index, ZIPENTRY *ze)\n{ if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}\n  TUnzip *unz = han->unz;\n  lasterrorU = unz->Find(name,ic,index,ze);\n  return lasterrorU;\n}\n\nZRESULT UnzipItemInternal(HZIP hz, int index, void *dst, unsigned int len, DWORD flags)\n{ if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}\n  TUnzip *unz = han->unz;\n  lasterrorU = unz->Unzip(index,dst,len,flags);\n  return lasterrorU;\n}\nZRESULT UnzipItemHandle(HZIP hz, int index, HANDLE h) {return UnzipItemInternal(hz,index,(void*)h,0,ZIP_HANDLE);}\nZRESULT UnzipItem(HZIP hz, int index, const TCHAR *fn) {return UnzipItemInternal(hz,index,(void*)fn,0,ZIP_FILENAME);}\nZRESULT UnzipItem(HZIP hz, int index, void *z,unsigned int len) {return UnzipItemInternal(hz,index,z,len,ZIP_MEMORY);}\n\nZRESULT SetUnzipBaseDir(HZIP hz, const TCHAR *dir)\n{ if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}\n  TUnzip *unz = han->unz;\n  lasterrorU = unz->SetUnzipBaseDir(dir);\n  return lasterrorU;\n}\n\n\nZRESULT CloseZipU(HZIP hz)\n{ if (hz==0) {lasterrorU=ZR_ARGS;return ZR_ARGS;}\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  if (han->flag!=1) {lasterrorU=ZR_ZMODE;return ZR_ZMODE;}\n  TUnzip *unz = han->unz;\n  lasterrorU = unz->Close();\n  delete unz;\n  delete han;\n  return lasterrorU;\n}\n\nbool IsZipHandleU(HZIP hz)\n{ if (hz==0) return false;\n  TUnzipHandleData *han = (TUnzipHandleData*)hz;\n  return (han->flag==1);\n}",
        "blame_info": {
            "paul@paulbetts.org": [
                [
                    1,
                    4158
                ]
            ]
        }
    },
    {
        "blob_id": "0293e83add680ed3f8e92ecea17c897a91d1270b",
        "directory_id": "1ca3477d99bddb6611f2feb67c8ce0c4569d8a4b",
        "path": "/Memendo.cc",
        "content_id": "7ac722a8f7b952968a9ec15d38a1c9bbc3afc637",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "TaoJun724/DesignPattern",
        "snapshot_id": "0da37a3a34fba54ba21cb809875b20d9eeba3443",
        "revision_id": "b0c62668cfad5b48b85b413e78ee9334812a74b2",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-06-30 08:57:32",
        "revision_date": "2019-08-07 07:42:09",
        "committer_date": "2019-08-07 07:42:09",
        "github_id": 200785533,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1461,
        "extension": "cc",
        "content": "#include <stdio.h>\n#include<string>\n\nclass Memento {\npublic:\n\tMemento(int n, std::string s) {\n\t\t_s = s;\n\t\t_money = n;\n\t}\n\tvoid setMoney(int n) {\n\t\t_money = n;\n\t}\n\n\tint getMoney() {\n\t\treturn _money;\n\t}\n\n\tvoid setState(std::string s) {\n\t\t_s = s;\n\t}\n\n\tstd::string getState() {\n\t\treturn _s;\n\t}\n\nprivate:\n\tint _money;\n\tstd::string _s;\n};\n\nclass Worker {\npublic:\n\tWorker(std::string name, int money, std::string s) {\n\t\t_name = name;\n\t\t_money = money;\n\t\t_s = s;\n\t}\n\n\tvoid show() {\n\t\tprintf(\"%s\u73b0\u5728\u6709\u94b1%d\u5143,\u751f\u6d3b\u72b6\u6001%s\uff01\\n\", _name.c_str(), _money, _s.c_str());\n\t}\n\n\tvoid setState(int money, std::string s) {\n\t\t_money = money;\n\t\t_s = s;\n\t}\n\n\tMemento* createMemnto() {\n\t\treturn new Memento(_money,_s);\n\t}\n\n\tvoid restoreMemnto(Memento* m) {\n\t\t_money = m->getMoney();\n\t\t_s = m->getState();\n\t}\nprivate:\n\tstd::string _name;\n\tint _money;\n\tstd::string _s;\n};\n\nclass WorkerStorage {\npublic:\n\tvoid setMemento(Memento* m) {\n\t\t_memento = m;\n\t}\n\n\tMemento* getMement() {\n\t\treturn _memento;\n\t}\nprivate:\n\tMemento* _memento;\n};\n\nint main() {\n\n\tWorker* zhangsan = new Worker(\"\u5f20\u4e09\", 10000, \"\u5bcc\u88d5\");\n\tzhangsan->show();\n\n\t//\u8bb0\u4f4f\u5f20\u4e09\u73b0\u5728\u7684\u72b6\u6001\n\tWorkerStorage* storage = new WorkerStorage;\n\tstorage->setMemento(zhangsan->createMemnto());\n\n\t//\u5f20\u4e09\u8d4c\u535a\u8f93\u4e86\u94b1\uff0c\u53ea\u5269\u4e0b10\u5143\n\tzhangsan->setState(10, \"\u8d2b\u56f0\");\n\tzhangsan->show();\n\n\t//\u7ecf\u8fc7\u52aa\u529b\u5f20\u4e09\u53c8\u56de\u5230\u4e86\u4e4b\u524d\u7684\u72b6\u6001\u3002\n\tzhangsan->restoreMemnto(storage->getMement());\n\tzhangsan->show();\n\treturn 0;\n}\n\n",
        "blame_info": {
            "2086239852@qq.com": [
                [
                    1,
                    93
                ]
            ]
        }
    },
    {
        "blob_id": "cbee84c2e52dc1341528f8254aaf41ac321f936c",
        "directory_id": "2869112fdc836e565f9fe68e290affc1e223c1d8",
        "path": "/pythran/pythonic/include/__builtin__/set/isdisjoint.hpp",
        "content_id": "10ac38270e03ff35d15b79143e6164321a7b5afb",
        "detected_licenses": [
            "LicenseRef-scancode-unknown-license-reference",
            "BSD-3-Clause"
        ],
        "license_type": "permissive",
        "repo_name": "coyotte508/pythran",
        "snapshot_id": "ab26e9ddb9a9e00e77b457df316aa33dc8435914",
        "revision_id": "a5da78f2aebae712a2c6260ab691dab7d09e307c",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-15 10:07:09",
        "revision_date": "2015-05-01 07:00:42",
        "committer_date": "2015-05-01 07:00:42",
        "github_id": 35020532,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": "2015-05-04 07:27:29",
        "gha_created_at": "2015-05-04 07:27:29",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 621,
        "extension": "hpp",
        "content": "#ifndef PYTHONIC_INCLUDE_BUILTIN_SET_ISDISJOINT_HPP\n#define PYTHONIC_INCLUDE_BUILTIN_SET_ISDISJOINT_HPP\n\n#include \"pythonic/utils/proxy.hpp\"\n#include \"pythonic/types/set.hpp\"\n\nnamespace pythonic {\n\n    namespace __builtin__  {\n\n        namespace set {\n            template<class T, class U>\n                bool\n                isdisjoint(types::set<T> const& calling_set, U const& arg_set);\n\n            template<class U>\n                bool\n                isdisjoint(types::empty_set const& calling_set, U const& arg_set);\n\n            PROXY_DECL(pythonic::__builtin__::set, isdisjoint);\n\n        }\n\n    }\n\n}\n#endif \n",
        "blame_info": {
            "serge.guelton@telecom-bretagne.eu": [
                [
                    1,
                    27
                ]
            ]
        }
    },
    {
        "blob_id": "95534aae2f06adbc3b44e859658780f8bf0cf800",
        "directory_id": "3f9081b23333e414fb82ccb970e15b8e74072c54",
        "path": "/bs2k/behaviors/skills/oneortwo_step_kick_bms.h",
        "content_id": "e7f968c14d8092e86a4e41ed23b6e7ac3a2558ab",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "rc2dcc/Brainstormers05PublicRelease",
        "snapshot_id": "5c8da63ac4dd3b84985bdf791a4e5580bbf0ba59",
        "revision_id": "2141093960fad33bf2b3186d6364c08197e9fe8e",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-03-22 07:32:36",
        "revision_date": "2018-07-04 18:28:32",
        "committer_date": "2018-07-04 18:28:32",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 7945,
        "extension": "h",
        "content": "/*\nBrainstormers 2D (Soccer Simulation League 2D)\nPUBLIC SOURCE CODE RELEASE 2005\nCopyright (C) 1998-2005 Neuroinformatics Group,\n                        University of Osnabrueck, Germany\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n*/\n\n#ifndef _ONEORTWO_STEP_KICK_BMS_H_\n#define _ONEORTWO_STEP_KICK_BMS_H_\n\n/* This behavior is a port of Move_1or2_Step_Kick into the behavior\n   framework. get_cmd will try to kick in one step and otherwise return\n   a cmd that will start a two-step kick. There are some functions\n   that return information about the reachable velocities and the needed\n   steps, so that you can prepare in your code for what this behavior will\n   do.\n\n   This behavior usually takes the current player position as reference point,\n   but you can override this by calling set_state() prior to any other function.\n   This makes it possible to \"fake\" the player's position during the current cycle.\n   Use reset_state to re-read the WS information, or wait until the next cycle.\n\n   Note that kick_to_pos_with_final_vel() is rather unprecise concerning the\n   final velocity of the ball. I don't know how to calculate the needed starting\n   vel precisely, so I have taken the formula from the original Neuro_Kick2 move\n   (which was even more unprecise...) and tweaked it a bit, but it is still\n   not perfect.\n\n   Note also that this behavior, as opposed to the original move, has a working\n   collision check - the original move ignored the player's vel...\n\n   (w) 2002 Manuel Nickschas\n*/\n\n\n#include \"../base_bm.h\"\n#include \"one_step_kick_bms.h\"\n#include \"angle.h\"\n#include \"Vector.h\"\n#include \"tools.h\"\n#include \"cmd.h\"\n#include \"n++.h\"\n#include \"macro_msg.h\"\n#include \"valueparser.h\"\n#include \"options.h\"\n#include \"ws_info.h\"\n#include \"log_macros.h\"\n#include \"mystate.h\"\n#include \"../../policy/abstract_mdp.h\"\n\nclass OneOrTwoStepKickItrActions {\n  static const Value kick_pwr_min = 20;\n  static const Value kick_pwr_inc = 10;\n  static const Value kick_pwr_max = 100;\n  static const Value kick_ang_min = 0;\n  static const Value kick_ang_inc = 2*PI/8.;\n  //  static const Value kick_ang_inc = 2*PI/36.; // ridi: I think it should be as much! too much\n  static const Value kick_ang_max = 2*PI-kick_ang_inc;\n  static const Value dash_pwr_min = 20;\n  static const Value dash_pwr_inc = 20;\n  static const Value dash_pwr_max = 100;\n  static const Value turn_ang_min = 0;\n  static const Value turn_ang_inc = 2*PI/18.;\n  //  static const Value turn_ang_max = 2*PI-turn_ang_inc;\n  static const Value turn_ang_max = 0;  // ridi: do not allow turns\n\n  static const Value kick_pwr_steps = (kick_pwr_max-kick_pwr_min)/kick_pwr_inc + 1;\n  static const Value dash_pwr_steps = (dash_pwr_max-dash_pwr_min)/dash_pwr_inc + 1;\n  static const Value turn_ang_steps = (turn_ang_max-turn_ang_min)/turn_ang_inc + 1;\n  static const Value kick_ang_steps = (kick_ang_max-kick_ang_min)/kick_ang_inc + 1;\n  \n  Cmd_Main action;\n\n  Value kick_pwr,dash_pwr;\n  ANGLE kick_ang,turn_ang;\n  int kick_pwr_done,kick_ang_done,dash_pwr_done,turn_ang_done;\n\n public:\n  void reset() {\n    kick_pwr_done=0;kick_ang_done=0;dash_pwr_done=0;turn_ang_done=0;\n    kick_pwr=kick_pwr_min;kick_ang= ANGLE(kick_ang_min);dash_pwr=dash_pwr_min;\n    turn_ang=ANGLE(turn_ang_min);\n  }\n\n  Cmd_Main *next() {\n    if(kick_pwr_done<kick_pwr_steps && kick_ang_done<kick_ang_steps) {\n      action.unset_lock();\n      action.unset_cmd();\n      action.set_kick(kick_pwr,kick_ang.get_value_mPI_pPI());\n      kick_ang+= ANGLE(kick_ang_inc);\n      if(++kick_ang_done>=kick_ang_steps) {\n\tkick_ang=ANGLE(kick_ang_min);\n\tkick_ang_done=0;\n\tkick_pwr+=kick_pwr_inc;\n\tkick_pwr_done++;\n      }\n      return &action;\n    }\n    if(dash_pwr_done<dash_pwr_steps) {\n      action.unset_lock();\n      action.unset_cmd();\n      action.set_dash(dash_pwr);\n      dash_pwr+=dash_pwr_inc;\n      dash_pwr_done++;\n      return &action;\n    }\n    if(turn_ang_done<turn_ang_steps) {\n      action.unset_lock();\n      action.unset_cmd();\n      action.set_turn(turn_ang);\n      turn_ang+= ANGLE(turn_ang_inc);\n      turn_ang_done++;\n      return &action;\n    }\n    return NULL;\n  }\n};\n\nclass OneOrTwoStepKick: public BaseBehavior {\n  static bool initialized;\n#if 0\n  struct MyState {\n    Vector my_vel;\n    Vector my_pos;\n    ANGLE  my_angle;\n    Vector ball_pos;\n    Vector ball_vel;\n    Vector op_pos;\n    ANGLE op_bodydir;\n  };\n#endif\n\n  OneStepKick *onestepkick;\n\n  OneOrTwoStepKickItrActions itr_actions;\n  \n  Cmd_Main result_cmd1,result_cmd2;\n  Value result_vel1,result_vel2;\n  bool result_status;\n  bool need_2_steps;\n  long set_in_cycle;\n  Vector target_pos;\n  ANGLE target_dir;\n  Value target_vel;\n  bool kick_to_pos;\n  bool calc_done;\n\n  MyState fake_state;\n  long fake_state_time; \n  void get_ws_state(MyState &state);\n\n  MyState get_cur_state();\n  \n  bool calculate(const MyState &state,Value vel,const ANGLE &dir,const Vector &pos,bool to_pos,\n\t\t Cmd_Main &res_cmd1,Value &res_vel1,Cmd_Main &res_cmd2,Value &res_vel2,\n\t\t bool &need_2steps); \n  bool do_calc();\n\n public:\n\n  /** This makes it possible to \"fake\" WS information.\n      This must be called _BEFORE_ any of the kick functions, and is valid for \n      the current cycle only.\n  */\n  void set_state(const Vector &mypos,const Vector &myvel,const ANGLE &myang,\n\t\t const Vector &ballpos,const Vector &ballvel, \n\t\t const Vector &op_pos = Vector(1000,1000), \n\t\t const ANGLE &op_bodydir = ANGLE(0),\n\t\t const int op_bodydir_age = 1000);\n\n  void set_state( const AState & state );\n  \n  /** Resets the current state to that found in WS.\n      This must be called _BEFORE_ any of the kick functions.\n  */\n  void reset_state();\n  \n  void kick_in_dir_with_initial_vel(Value vel,const ANGLE &dir);\n  void kick_in_dir_with_max_vel(const ANGLE &dir);\n  void kick_to_pos_with_initial_vel(Value vel,const Vector &point);\n  void kick_to_pos_with_final_vel(Value vel,const Vector &point);\n  void kick_to_pos_with_max_vel(const Vector &point);\n\n  /** false is returned if we do not reach our desired vel within two cycles.\n     Note that velocities are set to zero if the resulting pos is not ok,\n     meaning that even if a cmd would reach the desired vel, we will ignore\n     it if the resulting pos is not ok.\n  */\n  bool get_vel(Value &vel_1step,Value &vel_2step);\n  bool get_cmd(Cmd &cmd_1step,Cmd &cmd_2step);\n  bool get_vel(Value &best_vel);    // get best possible vel (1 or 2 step)\n  bool get_cmd(Cmd &best_cmd);      // get best possible cmd (1 or 2 step)\n\n  // returns 0 if kick is not possible, 1 if kick in 1 step is possible, 2 if in 2 steps. probably modifies vel\n  int is_kick_possible(Value &speed,const ANGLE &dir);\n\n  bool need_two_steps();\n\n  bool  can_keep_ball_in_kickrange();\n    \n  static bool init(char const * conf_file, int argc, char const* const* argv) {\n    if(initialized) return true;\n    initialized = true;\n    if(OneStepKick::init(conf_file,argc,argv)) {\n      cout << \"\\nOneOrTwoStepKick behavior initialized.\";\n    } else { \n      ERROR_OUT << \"\\nCould not initialize OneStepKick behavior - stop loading.\";\n      exit(1);\n    }\n    return true;\n  }\n\n  OneOrTwoStepKick() {\n    set_in_cycle = -1;\n    onestepkick = new OneStepKick();\n    onestepkick->set_log(false); // we don't want OneStepKick-Info in our logs!\n  }\n  virtual ~OneOrTwoStepKick() {\n    delete onestepkick;\n  }\n};\n    \n\n#endif\n",
        "blame_info": {
            "cookie.yz@qq.com": [
                [
                    1,
                    238
                ]
            ]
        }
    },
    {
        "blob_id": "ab5bc031413c9ef1306cacfd08a9878b7b902ed5",
        "directory_id": "35e79b51f691b7737db254ba1d907b2fd2d731ef",
        "path": "/AtCoder/ABC/007/D.cpp",
        "content_id": "1f7d6ef9dd955d37b91e67aebfabda6b728594c7",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "rodea0952/competitive-programming",
        "snapshot_id": "00260062d00f56a011f146cbdb9ef8356e6b69e4",
        "revision_id": "9d7089307c8f61ea1274a9f51d6ea00d67b80482",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-07-01 02:25:46",
        "revision_date": "2022-06-04 08:44:42",
        "committer_date": "2022-06-04 08:44:42",
        "github_id": 202485546,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1189,
        "extension": "cpp",
        "content": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\ntemplate <typename T> inline string toString(const T &a){ostringstream oss; oss<<a; return oss.str();};\n\nll solve(string &s){\n    int n=s.size();\n\n    ll dp[20][2][2];\n    // dp[\u6c7a\u3081\u305f\u6841\u6570][\u672a\u6e80\u30d5\u30e9\u30b0][4\u307e\u305f\u306f9\u3092\u542b\u3080\u304b] := \u6c42\u3081\u308b\u7dcf\u6570\n\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0]=1;\n\n    for(int i=0; i<n; i++){         // \u6841\n        int D=s[i]-'0';\n        for(int j=0; j<2; j++){     // \u672a\u6e80\u30d5\u30e9\u30b0\n            for(int k=0; k<2; k++){ // k=1 \u306e\u3068\u304d4\u307e\u305f\u306f9\u3092\u542b\u3080\n                for(int d=0; d<=(j?9:D); d++){\n                    dp[i+1][j || (d<D)][k || d==4 || d==9]+=dp[i][j][k];\n                }\n            }\n        }\n    }\n    return dp[n][0][1]+dp[n][1][1];\n}\n\nint main(){\n    ll a, b; cin>>a>>b;\n    string A=toString(a-1), B=toString(b);\n    cout << solve(B) - solve(A) << endl;\n}\n\n",
        "blame_info": {
            "dragondoor0912@yahoo.co.jp": [
                [
                    1,
                    48
                ]
            ]
        }
    },
    {
        "blob_id": "40bc68efa1d237aacc7f1b2a5010046f0e4cf13c",
        "directory_id": "4b1289b0eb41c045a24b4626857097571c988e9b",
        "path": "/Least_Loose_Number_In_The_Array.cpp",
        "content_id": "01dac7320be1eee1ec1af9b49c0962158327697f",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "Arvy1998/Calculus-and-Play-with-New-Syntax",
        "snapshot_id": "136d942c1be8dc59d3b6d764881d7a9aea5a68cd",
        "revision_id": "b442156a850dad2ed7c53ce86d3435fb35d78fe9",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-07-11 02:05:09",
        "revision_date": "2019-03-12 22:00:42",
        "committer_date": "2019-03-12 22:00:42",
        "github_id": 129288984,
        "star_events_count": 1,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 965,
        "extension": "cpp",
        "content": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tlong long n, seka[101], MIN_TEIG = 0, count;\n\tvector <long long> izulus_teig_sk;\n\tcin >> n;\n\tfor (auto x = 0; x < n; x++) {\n\t\tcin >> seka[x];\n\t}\n\tfor (auto i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tif (seka[i] > seka[i + 1]) {\n\t\t\t\tizulus_teig_sk.push_back(seka[i]);\n\t\t\t}\n\t\t}\n\t\tif (i > 0 && i < n - 1) {\n\t\t\tif (seka[i] > seka[i - 1] && seka[i] > seka[i + 1]) {\n\t\t\t\tizulus_teig_sk.push_back(seka[i]);\n\t\t\t}\n\t\t}\n\t\tif (i == n - 1) {\n\t\t\tif (seka[i] > seka[i - 1]) {\n\t\t\t\tizulus_teig_sk.push_back(seka[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (izulus_teig_sk.size() == 0 || n <= 1) {\n\t\tcout << \"NO\";\n\t\texit(0);\n\t}\n\telse {\n\t\tsort(izulus_teig_sk.begin(), izulus_teig_sk.end());\n\t\tfor (size_t j = 0; j < izulus_teig_sk.size(); j++) {\n\t\t\tif (izulus_teig_sk[j] > 0) {\n\t\t\t\tMIN_TEIG = izulus_teig_sk[j];\n\t\t\t\tcout << MIN_TEIG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (MIN_TEIG == 0) {\n\t\tcout << \"NO\";\n\t}\n    return 0;\n}\n",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    50
                ]
            ]
        }
    },
    {
        "blob_id": "36a545137c7c8972f084997716e578ad86d3ac15",
        "directory_id": "afcce85e08d8fc5141a840fe77bf7bf93f49df54",
        "path": "/tests/2015-09-10/fft_shift/main.cpp",
        "content_id": "5fd27aab9e2480a56af1d2bf0dfe2ab2e4eeaa98",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "icopavan/Automatic-Modulation-Classification-ELEN4012",
        "snapshot_id": "ff8f58a467129b371a9d2b042169fc99620b2959",
        "revision_id": "d72e3b4d36ad88b2872a8b33606c120f18b974e6",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-12 21:07:15",
        "revision_date": "2015-10-09 21:29:56",
        "committer_date": "2015-10-09 21:29:56",
        "github_id": 44043227,
        "star_events_count": 2,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": "2015-10-11 07:30:41",
        "gha_created_at": "2015-10-11 07:30:40",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 910,
        "extension": "cpp",
        "content": "#include \"mainwindow.h\"\n#include <QApplication>\n#include <fftw3.h>\n#include <cmath>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    MainWindow w;\n    w.show();\n\n    double PI = 4 * atan(1);\n    int N = 512; // number of samples\n    double fs = 10e3; // sampling frequency\n    double fc = 1000; // signal frequency\n\n    double t[N];\n    fftw_complex * x = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n    double f[N];\n\n    // calculation\n    for (int n = 0; n < N; ++n)\n    {\n        t[n] = n/fs;\n        x[n][0] = cos(2*PI*fc*t[n]);\n        x[n][1] = 0;\n\n        f[n] = (n - N/2) * fs / (N-1);\n    }\n\n    fftw_complex *out;\n    fftw_plan plan_forward;\n\n    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);\n    plan_forward = fftw_plan_dft_1d(N, x, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    fftw_execute(plan_forward);\n\n    w.plot(f, out, N);\n\n    return a.exec();\n}\n",
        "blame_info": {
            "anthonyjamesfarquharson@gmail.com": [
                [
                    1,
                    42
                ]
            ]
        }
    },
    {
        "blob_id": "33fa115e3d756b655d4b8fd3fc840eb94198c8be",
        "directory_id": "012784e8de35581e1929306503439bb355be4c4f",
        "path": "/problems/37. \u89e3\u6570\u72ec/3.cc",
        "content_id": "84bf778bd32645766fc6275be6ca3a9a288a96dc",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "silenke/my-leetcode",
        "snapshot_id": "7502057c9394e41ddeb2e7fd6c1b8261661639e0",
        "revision_id": "d24ef0970785c547709b1d3c7228e7d8b98b1f06",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-06-05 02:05:48",
        "revision_date": "2021-07-01 16:18:29",
        "committer_date": "2021-07-01 16:18:29",
        "github_id": 331948127,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1979,
        "extension": "cc",
        "content": "#include \"..\\..\\leetcode.h\"\n\nclass Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n\n        row = col = box = vector<int>(9);\n        int count = 0;\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') count++;\n                else fill(i, j, i / 3 * 3 + j / 3, board[i][j] - '1');\n            }\n        }\n        dfs(count, board);\n    }\n\nprivate:\n    vector<int> row, col, box;\n\n    void fill(int i, int j, int k, int n) {\n\n        row[i] |= 1 << n;\n        col[j] |= 1 << n;\n        box[k] |= 1 << n;\n    }\n\n    void zero(int i, int j, int k, int n) {\n\n        row[i] &= ~(1 << n);\n        col[j] &= ~(1 << n);\n        box[k] &= ~(1 << n);\n    }\n\n    int possible(int i, int j) {\n\n        return ~(row[i] | col[j] | box[i / 3 * 3 + j / 3]) & ((1 << 9) - 1);\n    }\n\n    pair<int, int> next(vector<vector<char>>& board) {\n\n        pair<int, int> res;\n        int min_count = INT_MAX;\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] != '.') continue;\n                int c = count(possible(i, j));\n                if (c < min_count) {\n                    min_count = c;\n                    res = {i, j};\n                }\n            }\n        }\n        return res;\n    }\n\n    bool dfs(int count, vector<vector<char>>& board) {\n\n        if (count == 0) return true;\n\n        auto [i, j] = next(board);\n        int p = possible(i, j);\n        int k = i / 3 * 3 + j / 3;\n        while (p) {\n            int n = __builtin_ctz(p & -p);\n            board[i][j] = n + '1';\n            fill(i, j, k, n);\n            if (dfs(count - 1, board)) return true;\n            board[i][j] = '.';\n            zero(i, j, k, n);\n            p &= p - 1;\n        }\n        return false;\n    }\n\n    int count(int p) {\n\n        int count = 0;\n        while (p) {\n            count++;\n            p &= p - 1;\n        }\n        return count;\n    }\n};",
        "blame_info": {
            "2595756713@qq.com": [
                [
                    1,
                    85
                ]
            ]
        }
    },
    {
        "blob_id": "b1bcf5c96e5da91d67fb19ffdce0f2269d7bd395",
        "directory_id": "cbb3ef472b4f4bbf1480552160aedbd88f230ee3",
        "path": "/Carpeta_de_proyectos_Arduino_copia_de_seguridad/NodemCU_Firebase_central/NodemCU_Firebase_central.ino",
        "content_id": "27d5e0ce48b73f435a3d2f3cb93ee7104a25d57a",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "agrgal/ARDUINO_CS",
        "snapshot_id": "5a68e236ec660b7ce4e34ee1253b1c0ed27033f0",
        "revision_id": "f94200dceb4a8d7d27332a3045301daecbb6c979",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-09-13 08:06:10",
        "revision_date": "2022-08-29 14:30:27",
        "committer_date": "2022-08-29 14:30:27",
        "github_id": 242396006,
        "star_events_count": 2,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 2424,
        "extension": "ino",
        "content": "\n/*\n * Created by Aurelio Gallardo Rodr\u00edguez \n * Based on: K. Suwatchai (Mobizt)\n * \n * Email: aurelio@seritium.es\n * \n * CENTRAL. Lectura\n * \n * Julio - 2019\n *\n*/\n\n\n//FirebaseESP8266.h must be included before ESP8266WiFi.h\n#include \"FirebaseESP8266.h\"\n#include <ESP8266WiFi.h>\n\n#define FIREBASE_HOST \"botonpanicoseritium.firebaseio.com\"\n#define FIREBASE_AUTH \"Y0QVBot29hCVGZJQbpVUMr3IKngc7GacE2355bdy\"\n#define WIFI_SSID \"JAZZTEL_shny\"\n#define WIFI_PASSWORD \"3z7s5tvbtu4s\"\n\n//Define FirebaseESP8266 data object\nFirebaseData bd;\n\nString path = \"/Estaciones\"; // path a FireBase \nchar *estaciones[]= {\"A\",\"B\",\"C\",\"D\",\"E\"}; // Estaciones que voy a controlar\n\nint i=1; // contador general\n\nint activo=0; // Alarma \n\n#define LED 5 // D1(gpio5)\n\nvoid setup()\n{\n\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n  \n  // conectando a la WIFI\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Conectando a la WiFi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(300);\n  }\n  Serial.println();\n  Serial.print(\"Conectado con IP: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n\n  // Conectando a la bd real Time Firebase\n  Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH);\n  Firebase.reconnectWiFi(true);\n\n  //Set database read timeout to 1 minute (max 15 minutes)\n  Firebase.setReadTimeout(bd, 1000 * 60);\n  //tiny, small, medium, large and unlimited.\n  //Size and its write timeout e.g. tiny (1s), small (10s), medium (30s) and large (60s).\n  Firebase.setwriteSizeLimit(bd, \"unlimited\");\n    \n}\n\n// Bucle principal\nvoid loop() {\n\n  activo=0; // reinicializo la variable\n  \n  for(i=0;i<=4;i++) {\n    delay(1);\n    activo=activo+rFB(\"/\"+(String) estaciones[i]);    \n  }\n  digitalWrite(LED,(activo>=1)); // activo el LED si es mayor o igual a 1.\n  \n\n}\n\n\n\n// Funci\u00f3n de lectura\nint rFB(String estacion){// lee el dato de la entrada correspondiente\n\n  int valor=0;\n \n  if (Firebase.getInt(bd, path+estacion)) {\n    if (bd.dataType() == \"int\") {\n      Serial.println(\"Dato le\u00eddo: \"+ path+estacion +\" --> \" + (String) bd.intData());\n      valor = bd.intData(); // retorna el valor       \n    }\n  } else {\n    // Si no existe el dato de la estaci\u00f3n, salta el error\n    // Pero el error se muestra en pantalla (bd.errorReason()) Y REINICIALIZA LA UNIDAD, lo cual no quiero.\n    Serial.println(\"Estoy dando un error... ojo\");\n    // Serial.println(bd.errorReason());   \n  }\n\n  return valor;\n  \n}\n",
        "blame_info": {
            "aurelio@seritium.es": [
                [
                    1,
                    102
                ]
            ]
        }
    },
    {
        "blob_id": "334f0712fc8566ea028524f0cd56702b83f8dbd4",
        "directory_id": "9b273539e02cca8d408e8cf793007ee84e6637d5",
        "path": "/ext/bliss/src/iterators/edge_iterator.hpp",
        "content_id": "2217a705bef1dc4b94ba3493a6facab66fe6ad3e",
        "detected_licenses": [
            "Apache-2.0"
        ],
        "license_type": "permissive",
        "repo_name": "tuan1225/parconnect_sc16",
        "snapshot_id": "23b82c956eed4dabe5deec8bd48cc8ead91af615",
        "revision_id": "bcd6f99101685d746cf30e22fa3c3f63ddd950c9",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-12-24 12:01:13",
        "revision_date": "2016-11-07 16:51:29",
        "committer_date": "2016-11-07 16:51:29",
        "github_id": 73055274,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 9760,
        "extension": "hpp",
        "content": "/*\n * edge_iterator.hpp\n *\n *  Created on: Aug 4, 2015\n *      Author: yongchao\n */\n\n#ifndef EDGE_ITERATOR_HPP_\n#define EDGE_ITERATOR_HPP_\n\n#include <iterator>\n#include \"common/alphabets.hpp\"\n\nnamespace bliss\n{\n\n  namespace iterator\n  {\n\n    // careful with the use of enable_if.  evaluation should occur at function call time,\n    //   i.e. class template params will be evaluated with no substitution.\n    // instead, a function should declare a template parameter proxy for the class template parameter.\n    //   then enable_if evaluates using the proxy.\n    //  e.g. template< class c = C; typename std::enable_if<std::is_same<c, std::string>::value, int>::type x = 0>\n\n    /**\n     * @class   edge_iterator\n     * @brief   given a k-mer position, retrieve its left and right bases, including the dummy bases at both ends\n     * @details specializations of this class uses a byte to manage the edge info.\n     *          upper 4 bits holds the left base (encoded), lower 4 bits holds the right base (encoded)\n     *\n     *          no reverse complement or reordering is applied.\n     *\n     *          edge iterator should be valid for std::distance(_data_end - _data_start - k + 1) iterations.\n     */\n  \ttemplate<typename IT, typename ALPHA = bliss::common::DNA16>\n  \tclass edge_iterator : public ::std::iterator<::std::forward_iterator_tag, uint8_t>\n  \t{\n      protected:\n\n          // curr position\n          IT _curr;\n          //previous position\n          IT _left;\n          //a position of distance k from the _curr on the right\n          IT _right;\n\n          /*data*/\n          const IT _data_start;\n          const IT _data_end;\n\n        public:\n\n          typedef ALPHA    Alphabet;\n          typedef edge_iterator<IT, ALPHA> self_type; /*define edge iterator type*/\n          typedef uint8_t edge_type; //type to represent an edge\n\n          // accessors\n          IT& getBase()\n          {\n            return _curr;\n          }\n\n          //constructor\n          edge_iterator(IT data_start, IT data_end, const uint32_t k)\n            : _curr (data_start), _left(data_end), _right(data_start), _data_start(data_start), _data_end(data_end)\n          {\n            /*compute the offset*/\n            ::std::advance(_curr, k - 1);\n            _right = _curr;\n            ::std::advance(_right, 1);\n          }\n          edge_iterator(IT data_end)\n            : _curr(data_end), _left(data_end), _right(data_end), _data_start(data_end), _data_end(data_end)\n          {\n\n          }\n          /// copy constructor\n          edge_iterator(const self_type& Other)\n            : _curr (Other._curr), _left(Other._left), _right(Other._right),\n              _data_start(Other._data_start), _data_end(Other._data_end)\n          {\n            /*do nothing*/\n          }\n\n\n          /// copy assignment iterator\n          self_type& operator=(const self_type& Other)\n          {\n            _curr = Other._curr;\n            _left = Other._left;\n            _right = Other._right;\n            _data_start = Other._data_start;\n            _data_end = Other._data_end;\n\n            return *this;\n          }\n\n          /// increment to next matching element in base iterator\n          self_type& operator++()\n          {  // if _curr at end, subsequent calls should not move _curr.\n             // on call, if not at end, need to move first then evaluate.\n            if (_curr == _data_end){  // if at end, don't move it.\n              return *this;\n            }\n\n            /*save the previous position*/\n            if (_left == _data_end) _left = _data_start;\n            else ++_left;\n\n            /*move forward by 1*/\n            ++_curr;\n\n            /*ensure that _right does not exceed _end*/\n            if(_right != _data_end){\n              ++_right;\n            }\n            return *this;\n          }\n\n          /**\n           * post increment.  make a copy then increment that.\n           */\n          self_type operator++(int)\n          {\n            self_type output(*this);\n            this->operator++();\n            return output;\n          }\n\n          /// compare 2 filter iterators\n          inline bool operator==(const self_type& rhs)\n          {\n            return _curr == rhs._curr;\n          }\n\n          /// compare 2 filter iterators\n          inline bool operator!=(const self_type& rhs)\n          {\n            return _curr != rhs._curr;\n          }\n\n          /// dereference operator. _curr is guaranteed to be valid\n          inline edge_type operator*()\n          {\n            /*using four bits to represent an edge*/\n            if(_left != _data_end && _right != _data_end){\n                /*internal k-mer node*/\n                return (ALPHA::FROM_ASCII[*_left] << 4) | ALPHA::FROM_ASCII[*_right];\n            }else if(_left == _data_end && _right != _data_end){  /*the left-most k-mer node*/\n              return  ALPHA::FROM_ASCII[*_right];\n            }else if(_left != _data_end && _right == _data_end){  /*the rigth-most k-mer node*/\n              return ALPHA::FROM_ASCII[*_left] << 4;\n            }\n\n            /*if(_left == _end && _right == _end)*/\n            return 0;\n          }\n      };\n\n  \ttemplate<typename IT>\n  \tusing DNA16_edge_iterator = edge_iterator<IT, bliss::common::DNA16>;\n    template<typename IT>\n    using DNA_IUPAC_edge_iterator = edge_iterator<IT, bliss::common::DNA_IUPAC>;\n    // not suitable for edge iterator since there is no value for unknown char.\n    template<typename IT>\n    using DNA_edge_iterator = edge_iterator<IT, bliss::common::DNA>;\n    template<typename IT>\n    using DNA5_edge_iterator = edge_iterator<IT, bliss::common::DNA5>;\n    // not suitable for edge iterator since there is no value for unknown char.\n    template<typename IT>\n    using RNA_edge_iterator = edge_iterator<IT, bliss::common::RNA>;\n    template<typename IT>\n    using RNA5_edge_iterator = edge_iterator<IT, bliss::common::RNA5>;\n\n\n  \t/*EdgeType = short unsigned int*/\n  \ttemplate<typename IT>\n  \tclass edge_iterator<IT, bliss::common::ASCII>: public ::std::iterator<::std::forward_iterator_tag, uint16_t>\n  \t{\n  \tprotected:\n\n        // curr position\n        IT _curr;\n        //previous position\n        IT _left;\n        //a position of distance k from the _curr on the right\n        IT _right;\n\n        /*data*/\n        const IT _data_start;\n        const IT _data_end;\n\n      public:\n        typedef bliss::common::ASCII    Alphabet;\n\n        typedef edge_iterator<IT, bliss::common::ASCII> self_type;\t/*define edge iterator type*/\n        typedef uint16_t edge_type;\t//type to represent an edge\n\n        // accessors\n        IT& getBase()\n        {\n          return _curr;\n        }\n\n        //constructor\n        edge_iterator(IT data_start, IT data_end, const uint32_t k)\n        \t: _curr (data_start), _left(data_end), _right(data_start), _data_start(data_start), _data_end(data_end)\n        {\n        \t/*compute the offset*/\n          ::std::advance(_curr, k-1);\n          _right = _curr;\n        \t::std::advance(_right, 1);\n        }\n        edge_iterator(IT data_end)\n        \t: _curr(data_end), _left(data_end), _right(data_end), _data_start(data_end), _data_end(data_end)\n        {\n\n        }\n\n        /// copy constructor\n        edge_iterator(const self_type& Other)\n        \t: _curr (Other._curr), _left(Other._left), _right(Other._right),\n        \t  _data_start(Other._data_start), _data_end(Other._data_end)\n        {\n        \t/*do nothing*/\n        }\n\n\n        /// copy assignment iterator\n        self_type& operator=(const self_type& Other)\n        {\n          _curr = Other._curr;\n          _left = Other._left;\n          _right = Other._right;\n          _data_start = Other._data_start;\n          _data_end = Other._data_end;\n\n          return *this;\n        }\n\n        /// increment to next matching element in base iterator\n        self_type& operator++()\n        {  // if _curr at end, subsequent calls should not move _curr.\n           // on call, if not at end, need to move first then evaluate.\n          if (_curr == _data_end){  // if at end, don'IT move it.\n            return *this;\n          }\n\n          /*save the previous position*/\n          if (_left == _data_end) _left = _data_start;\n          else ++_left;\n\n          /*move forward by 1*/\n          ++_curr;\n\n          /*ensure that _right does not exceed _end*/\n          if(_right != _data_end){\n        \t  ++_right;\n          }\n          return *this;\n        }\n\n        /**\n         * post increment.  make a copy then increment that.\n         */\n        self_type operator++(int)\n        {\n        \tself_type output(*this);\n          this->operator++();\n          return output;\n        }\n\n        /// compare 2 filter iterators\n        inline bool operator==(const self_type& rhs)\n        {\n          return _curr == rhs._curr;\n        }\n\n        /// compare 2 filter iterators\n        inline bool operator!=(const self_type& rhs)\n        {\n          return _curr != rhs._curr;\n        }\n\n        /// dereference operator. _curr is guaranteed to be valid\n        inline edge_type operator*()\n        {\n        \t/*using 8 bits to represent an edge*/\n        \tif(_left != _data_end && _right != _data_end){\n            \t/*internal k-mer node*/\n            \treturn (*_left << 8) | *_right;\n        \t}else if(_left == _data_end && _right != _data_end){\t/*the left-most k-mer node*/\n        \t\treturn *_right & 0x0ff;\n        \t}else if(_left != _data_end && _right == _data_end){\t/*the rigth-most k-mer node*/\n        \t\treturn *_left << 8;\n        \t}\n\n        \t/*if(_left == _end && _right == _end)*/\n        \treturn 0;\n        }\n    };\n  \ttemplate<typename IT>\n  \tusing raw_edge_iterator = edge_iterator<IT, bliss::common::ASCII>;\n\n\n  } // iterator\n} // bliss\n\n\n\n#endif /* EDGE_ITERATOR_HPP_ */\n",
        "blame_info": {
            "tuannguyen1225@yahoo.com": [
                [
                    1,
                    312
                ]
            ]
        }
    },
    {
        "blob_id": "131a93f902c1a8715e74d2700bc7f4ed05b9b4db",
        "directory_id": "2d7b108dd96795e0c881b60150dcca4cd1ebb1d2",
        "path": "/tests/unit_tests/unbound.cpp",
        "content_id": "e55fa615de30cf0338ce41ba9fba0e31825ab03d",
        "detected_licenses": [
            "LicenseRef-scancode-unknown-license-reference",
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "bydotcoin/bydotcoin",
        "snapshot_id": "f251d7bfb30cdf3174fd28786dd2bcf8e9cb1da6",
        "revision_id": "235366b993f0c316039cf3702211b728271ecea0",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-11-21 13:04:42",
        "revision_date": "2020-07-21 08:38:29",
        "committer_date": "2020-07-21 08:38:29",
        "github_id": 280835356,
        "star_events_count": 1,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 2415,
        "extension": "cpp",
        "content": "// Copyright (c) 2020, The Bydotcoin Project // Copyright (c) 2017-2020, The Electroneum Project\n// Copyright (c) 2016-2019, The Monero Project\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification, are\n// permitted provided that the following conditions are met:\n// \n// 1. Redistributions of source code must retain the above copyright notice, this list of\n//    conditions and the following disclaimer.\n// \n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\n//    of conditions and the following disclaimer in the documentation and/or other\n//    materials provided with the distribution.\n// \n// 3. Neither the name of the copyright holder nor the names of its contributors may be\n//    used to endorse or promote products derived from this software without specific\n//    prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers\n\n#include \"gtest/gtest.h\"\n\n#ifdef STATICLIB\n\nextern \"C\" int dnskey_algo_id_is_supported(int);\n\nTEST(unbound, supported_algorithms)\n{\n  // Electroneum causes these to be tried, but we don't have access\n  // to this internal unbound header here, so we use raw numbers\n  // LDNS_RSASHA1            = 5,\n  // LDNS_RSASHA1_NSEC3      = 7,\n  // LDNS_RSASHA256          = 8,   /* RFC 5702 */\n  // LDNS_ECDSAP256SHA256    = 13,  /* RFC 6605 */\n\n  ASSERT_TRUE(dnskey_algo_id_is_supported(5));\n  ASSERT_TRUE(dnskey_algo_id_is_supported(7));\n  ASSERT_TRUE(dnskey_algo_id_is_supported(8));\n  ASSERT_TRUE(dnskey_algo_id_is_supported(13));\n}\n\n#endif\n\n",
        "blame_info": {
            "68498206+bydotcoin@users.noreply.github.com": [
                [
                    1,
                    1
                ]
            ],
            "binaryfate@users.noreply.github.com": [
                [
                    2,
                    2
                ]
            ],
            "moneromooo-monero@users.noreply.github.com": [
                [
                    3,
                    39
                ],
                [
                    41,
                    54
                ]
            ],
            "andre_luis@outlook.com": [
                [
                    40,
                    40
                ]
            ]
        }
    },
    {
        "blob_id": "3025038669b687c8e7bd508bb41b1b5adb4ab7b2",
        "directory_id": "64824c859f6af21ad97edf16fb00a32b81c8e800",
        "path": "/\u7b2c23\u8282.cpp",
        "content_id": "01bf003a3ed3a08ee1f72d2bdd25d275403bbf9b",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "leigelaing/C-",
        "snapshot_id": "7ea94df8fed45bc47eb5437eedda5b6cc98bc754",
        "revision_id": "513b5ba2a8891717d4a21e5cfabd935f66071b57",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-04-09 06:49:11",
        "revision_date": "2021-04-20 00:11:38",
        "committer_date": "2021-04-20 00:11:38",
        "github_id": 296510796,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "GB18030",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1887,
        "extension": "cpp",
        "content": "#include<stdio.h>\r\nint Add(int x,int y)\r\n{\r\n   int z = 0;\r\n   z = x + y;\r\n   return z;\r\n}\r\n\r\nint main()\r\n{\r\n    int a = 10;\r\n\tint b = 20;\r\n\tint ret = 0;\r\n\tret = Add(a,b);\r\n\treturn 0;\r\n}\r\n\r\n//\u538b\u6808\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\ntypedef struct stu\r\n{\r\n\t//\u6210\u5458\u53d8\u91cf\r\n    char name[20];\r\n\tshort age;\r\n\tchar tele[12];\r\n\tchar sex[5];\r\n}stu;  \r\nvoid print1(stu tmp)\r\n{\r\n printf(\"name: %s\\n\",tmp.name);\r\n printf(\" age: %d\\n\",tmp.age);\r\n printf(\"tele: %s\\n\",tmp.tele );\r\n printf(\" sex: %s\\n\",tmp.sex );\r\n}\r\n void print2(stu* pa)\r\n {\r\n  printf(\"name: %s\\n\",pa->name);\r\n  printf(\" age: %d\\n\",pa->age);\r\n  printf(\"tele: %s\\n\",pa->tele );\r\n  printf(\" sex: %s\\n\",pa->sex );\r\n }\r\n  \r\nint main()\r\n{\r\n    stu s = {\"\u674e\u56db\",40,\"1561341658\",\"\u7537\"};\r\n\t//\u6253\u5370\u7ed3\u6784\u4f53\u6570\u636e\r\n\t//print1\u4e0eprint2\u54ea\u4e2a\u66f4\u597d print1\u6d6a\u8d39\u7a7a\u95f4\uff0c   \r\n\tprint1(s);\r\n\tprint2(&s);\r\n\treturn 0;\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*struct S\r\n{\r\n int a;\r\n char c;\r\n char arr[20];\r\n double d;\r\n};\r\nstruct T\r\n{\r\n char ch[10];\r\n struct S s;\r\n char *pc;\r\n};\r\nint main()\r\n{\r\n\tchar arr[] = \"hello bit\\n\";\r\n\tstruct T t = {\"hehe\",{100,'w',\"hello world\",3.14},arr};   \r\n\tprintf(\"%s\\n\",t.ch);\r\n    printf(\"%s\\n\",t.s.arr);\r\n\tprintf(\"%lf\\n\",t.s.d);\r\n    printf(\"%s\\n\",t.pc);\r\n\treturn 0;\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\ntypedef struct stu\r\n{\r\n\t//\u6210\u5458\u53d8\u91cf\r\n    char name[20];\r\n\tshort age;\r\n\tchar tele[12];\r\n\tchar sex[5];\r\n}stu;      //struct \u88ab\u6539\u540d\u4e3a stu\r\nint main()\r\n{\r\n    struct stu s1 = {\"\u5f20\u4e09\",20,\"125226236213\",\"\u7537\"};//s\u5c40\u90e8\u53d8\u91cf\uff1b\r\n\tstu s2 = {\"\u65fa\u8d22\",30,\"1646346464646\",\"\u5973\"};\r\n\treturn 0;\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n//struct  \u7ed3\u6784\u4f53\u5173\u952e\u5b57\uff0c  stu\u2014\u7ed3\u6784\u4f53\u6807\u7b7e   struct stu\u2014\u7ed3\u6784\u4f53\u7c7b\u578b(\u4e0d\u5360\u7528\u5185\u5b58\u7a7a\u95f4)\r\nstruct stu\r\n{\r\n\t//\u6210\u5458\u53d8\u91cf\r\n    char name[20];\r\n\tshort age;\r\n\tchar tele[12];\r\n\tchar sex[5];\r\n}s1,s2,s3;//s1,s2,s3\u662f\u5168\u5c40\u53d8\u91cf\r\nint main()\r\n{\r\n    struct stu s;//s\u5c40\u90e8\u53d8\u91cf\uff1b\r\n\t\r\n\treturn 0;\r\n}\r\n*/",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    145
                ]
            ]
        }
    },
    {
        "blob_id": "493c297fd0391458d123cd98d86bbc0010f7efb3",
        "directory_id": "33b567f6828bbb06c22a6fdf903448bbe3b78a4f",
        "path": "/opencascade/Interface_IntList.hxx",
        "content_id": "271c0baf41f9a0b0990c52ba315cff59814383d3",
        "detected_licenses": [
            "Apache-2.0"
        ],
        "license_type": "permissive",
        "repo_name": "CadQuery/OCP",
        "snapshot_id": "fbee9663df7ae2c948af66a650808079575112b5",
        "revision_id": "b5cb181491c9900a40de86368006c73f169c0340",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-07-10 18:35:44",
        "revision_date": "2023-06-12 18:09:07",
        "committer_date": "2023-06-12 18:09:07",
        "github_id": 228692262,
        "star_events_count": 64,
        "fork_events_count": 28,
        "gha_license_id": "Apache-2.0",
        "gha_event_created_at": "2023-09-11 12:40:09",
        "gha_created_at": "2019-12-17 20:02:11",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 5914,
        "extension": "hxx",
        "content": "// Created on: 1995-05-12\n// Created by: Christian CAILLET\n// Copyright (c) 1995-1999 Matra Datavision\n// Copyright (c) 1999-2014 OPEN CASCADE SAS\n//\n// This file is part of Open CASCADE Technology software library.\n//\n// This library is free software; you can redistribute it and/or modify it under\n// the terms of the GNU Lesser General Public License version 2.1 as published\n// by the Free Software Foundation, with special exception defined in the file\n// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT\n// distribution for complete text of the license and disclaimer of any warranty.\n//\n// Alternatively, this file may be used under the terms of Open CASCADE\n// commercial license or contractual agreement.\n\n#ifndef _Interface_IntList_HeaderFile\n#define _Interface_IntList_HeaderFile\n\n#include <Standard.hxx>\n#include <Standard_DefineAlloc.hxx>\n#include <Standard_Handle.hxx>\n\n#include <Standard_Integer.hxx>\n#include <TColStd_HArray1OfInteger.hxx>\n#include <Standard_Boolean.hxx>\n\n//! This class detains the data which describe a Graph. A Graph\n//! has two lists, one for shared refs, one for sharing refs\n//! (the reverses). Each list comprises, for each Entity of the\n//! Model of the Graph, a list of Entities (shared or sharing).\n//! In fact, entities are identified by their numbers in the Model\n//! or Graph : this gives better performances.\n//!\n//! A simple way to implement this is to instantiate a HArray1\n//! with a HSequenceOfInteger : each Entity Number designates a\n//! value, which is a Sequence (if it is null, it is considered as\n//! empty : this is a little optimisation).\n//!\n//! This class gives a more efficient way to implement this.\n//! It has two lists (two arrays of integers), one to describe\n//! list (empty, one value given immediately, or negated index in\n//! the second list), one to store refs (pointed from the first\n//! list). This is much more efficient than a list of sequences,\n//! in terms of speed (especially for read) and of memory\n//!\n//! An IntList can also be set to access data for a given entity\n//! number, it then acts as a single sequence\n//!\n//! Remark that if an IntList is created from another one, it can\n//! be read, but if it is created without copying, it may not be\n//! edited\nclass Interface_IntList \n{\npublic:\n\n  DEFINE_STANDARD_ALLOC\n\n  \n  //! Creates empty IntList.\n  Standard_EXPORT Interface_IntList();\n  \n  //! Creates an IntList for <nbe> entities\n  Standard_EXPORT Interface_IntList(const Standard_Integer nbe);\n  \n  //! Creates an IntList from another one.\n  //! if <copied> is True, copies data\n  //! else, data are not copied, only the header object is\n  Standard_EXPORT Interface_IntList(const Interface_IntList& other, const Standard_Boolean copied);\n  \n  //! Initialize IntList by number of entities.\n  Standard_EXPORT void Initialize (const Standard_Integer nbe);\n  \n  //! Returns internal values, used for copying\n  Standard_EXPORT void Internals (Standard_Integer& nbrefs, Handle(TColStd_HArray1OfInteger)& ents, Handle(TColStd_HArray1OfInteger)& refs) const;\n  \n  //! Returns count of entities to be aknowledged\n  Standard_EXPORT Standard_Integer NbEntities() const;\n  \n  //! Changes the count of entities (ignored if decreased)\n  Standard_EXPORT void SetNbEntities (const Standard_Integer nbe);\n  \n  //! Sets an entity number as current (for read and fill)\n  Standard_EXPORT void SetNumber (const Standard_Integer number);\n  \n  //! Returns the current entity number\n  Standard_EXPORT Standard_Integer Number() const;\n  \n  //! Returns an IntList, identical to <me> but set to a specified\n  //! entity Number\n  //! By default, not copied (in order to be read)\n  //! Specified <copied> to produce another list and edit it\n  Standard_EXPORT Interface_IntList List (const Standard_Integer number, const Standard_Boolean copied = Standard_False) const;\n  \n  //! Sets current entity list to be redefined or not\n  //! This is used in a Graph for redefinition list : it can be\n  //! disable (no redefinition, i.e. list is cleared), or enabled\n  //! (starts as empty). The original list has not to be \"redefined\"\n  Standard_EXPORT void SetRedefined (const Standard_Boolean mode);\n  \n  //! Makes a reservation for <count> references to be later\n  //! attached to the current entity. If required, it increases\n  //! the size of array used to store refs. Remark that if count is\n  //! less than two, it does nothing (because immediate storing)\n  Standard_EXPORT void Reservate (const Standard_Integer count);\n  \n  //! Adds a reference (as an integer value, an entity number) to\n  //! the current entity number. Zero is ignored\n  Standard_EXPORT void Add (const Standard_Integer ref);\n  \n  //! Returns the count of refs attached to current entity number\n  Standard_EXPORT Standard_Integer Length() const;\n\n  //! Returns True if the list for a number\n  //! (default is taken as current) is \"redefined\" (useful for empty list)\n  Standard_EXPORT Standard_Boolean IsRedefined (const Standard_Integer num = 0) const;\n\n  //! Returns a reference number in the list for current number,\n  //! according to its rank\n  Standard_EXPORT Standard_Integer Value (const Standard_Integer num) const;\n  \n  //! Removes an item in the list for current number, given its rank\n  //! Returns True if done, False else\n  Standard_EXPORT Standard_Boolean Remove (const Standard_Integer num);\n  \n  //! Clears all data, hence each entity number has an empty list\n  Standard_EXPORT void Clear();\n  \n  //! Resizes lists to exact sizes. For list of refs, a positive\n  //! margin can be added.\n  Standard_EXPORT void AdjustSize (const Standard_Integer margin = 0);\n\nprivate:\n\n  Standard_Integer thenbe;\n  Standard_Integer thenbr;\n  Standard_Integer thenum;\n  Standard_Integer thecount;\n  Standard_Integer therank;\n  Handle(TColStd_HArray1OfInteger) theents;\n  Handle(TColStd_HArray1OfInteger) therefs;\n\n};\n\n#endif // _Interface_IntList_HeaderFile\n",
        "blame_info": {
            "adam.jan.urbanczyk@gmail.com": [
                [
                    1,
                    112
                ],
                [
                    116,
                    116
                ],
                [
                    118,
                    145
                ]
            ],
            "noreply@github.com": [
                [
                    113,
                    115
                ],
                [
                    117,
                    117
                ]
            ]
        }
    },
    {
        "blob_id": "36ffd69f21bf2277cef7fea364841c3a12967399",
        "directory_id": "d04b3793ed3611d5bdc8e3bc990bf9eb8562cece",
        "path": "/CheatSheet.cpp",
        "content_id": "e00970193f00ed69d57e398e36db43427aaf83b0",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "nebulou5/CppExamples",
        "snapshot_id": "c7198cdc24ba1d681cc20738a3b21e2b17b98498",
        "revision_id": "98044227b888a7f9faa8934ab76bb3cac443b75e",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-09-01 18:55:44",
        "revision_date": "2016-01-25 17:57:40",
        "committer_date": "2016-01-25 17:57:40",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1222,
        "extension": "cpp",
        "content": "#include <iostream>\nusing namespace std;\n\nvoid printI(int &i) {\n  cout << \"Printing i: \" << i << endl;\n}\n\nint main() {\n\n  // defining a basic 10 integer array\n  int x[10];\n  int xLen = sizeof(x) / sizeof(x[0]);\n\n  for (int i = 0; i < xLen; i++) {\n    cout << x[i] << endl;\n  }\n\n  // defining an array in place\n  float v[] = {1.1, 2.2, 3.3};\n  int vLen = sizeof(v) / sizeof(v[0]);\n\n  for (int i = 0; i < vLen; i++ ) {\n    cout << v[i] << endl;\n  }\n\n  // multidimensional array\n  float ab[3][3];\n  int abLen = sizeof(ab) / sizeof(ab[0]);\n\n  for (int i = 0; i < abLen; i++) {\n    printI(i);\n    for (int j = 0; j < abLen; j++) {\n      cout << \"Element: \" << i << \", \" << j << \": \" << ab[i][j] << endl;\n    }\n  }\n\n  // array allocated at runtime\n  int someUserDefinedSize = 3;\n  float* rta = new float[someUserDefinedSize]; // pointer dynamically allocates memory at runtime\n  delete[] rta; // but programmer must clean up the memory afterwards\n\n  // basic pointer usage\n  int i = 3;\n  int *j = &i; // store address of i @ \"j\"\n  int k = *j; // dereference address stored @ \"j\"\n\n  // initializing a nullptr\n  // valid in c++ 11 and beyond\n  int *nullPointer = nullptr;\n  int *nullPointerSynonymous{}; // also sets a nullptr\n\n}\n",
        "blame_info": {
            "rwharrington87@gmail.com": [
                [
                    1,
                    52
                ]
            ]
        }
    },
    {
        "blob_id": "f45da0032ec95894d113360f36e2c7e74a3b4bd2",
        "directory_id": "be522f6110d4ed6f330da41a653460e4fb1ed3a7",
        "path": "/runtime/nf/httpparser/Buffer.cc",
        "content_id": "e4717f524b583c4cfdc3f533c545bdec74c3946c",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "yxd886/nfa",
        "snapshot_id": "2a796b10e6e2085470e54dd4f9a4a3721c0d27a9",
        "revision_id": "209fd992ab931f955afea11562673fec943dd8a6",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-06-17 22:09:37",
        "revision_date": "2017-03-24 03:07:38",
        "committer_date": "2017-03-24 03:07:38",
        "github_id": 74966034,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 981,
        "extension": "cc",
        "content": "\n#include \"Buffer.h\"\n\nvoid CBuffer_Reset(struct CBuffer& Cbuf){\n\tif(!Cbuf.buf){\n\t\tCbuf.buf = (char*) malloc(BUFFER_SIZE);\n\t\tmemset(Cbuf.buf,0x00,Cbuf._free);\n\t}\n\n\tif(Cbuf.len > BUFFER_SIZE * 2 && Cbuf.buf){\n\t\t//\u5982\u679c\u76ee\u524dbuf\u7684\u5927\u5c0f\u662f\u9ed8\u8ba4\u503c\u76842\u500d\uff0c\u5219\u5bf9\u5176\u88c1\u526a\u5185\u5b58\uff0c\u4fdd\u6301buf\u7684\u5927\u5c0f\u4e3a\u9ed8\u8ba4\u503c\uff0c\u51cf\u5c0f\u5185\u5b58\u8017\u8d39\n\t\tchar* newbuf = (char*) realloc(Cbuf.buf,BUFFER_SIZE);\n\t\tif(newbuf != Cbuf.buf)\n\t\tCbuf.buf = newbuf;\n\t}\n\n\tCbuf.len = 0;\n\tCbuf._free = BUFFER_SIZE;\n}\n\nbool Append(struct CBuffer& Cbuf,char* p, size_t size){\n\tif(!p || !size)\n\t\t\treturn true;\n\tif(size < Cbuf._free){\n\t\tmemcpy(Cbuf.buf + Cbuf.len, p , size);\n\t\tCbuf.len += size;\n\t\tCbuf._free -= size;\n\t}else{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nchar* GetBuf(struct CBuffer Cbuf,uint32_t& size){\n\tsize = Cbuf.len;\n\treturn Cbuf.buf;\n}\n\nuint32_t GetBufLen(struct CBuffer Cbuf){\n\n\treturn Cbuf.len;\n\n}\n\n\nvoid Buf_init(struct CBuffer& Cbuf){\n\tCbuf.len=0;\n\tCbuf._free=0;\n\tCbuf.buf=0;\n\tCBuffer_Reset(Cbuf);\n}\n",
        "blame_info": {
            "duanjp8617@gmail.com": [
                [
                    1,
                    52
                ]
            ]
        }
    },
    {
        "blob_id": "6bb71dcc34b99d77ceb1ceff65cfbc759d142cb5",
        "directory_id": "fb72a82827496e66e04ecb29abbca788a1ea0525",
        "path": "/src/wallet/wallet.h",
        "content_id": "5c79de2b263b987cf010ed0c6314bf311d8d6581",
        "detected_licenses": [
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "exiliumcore/exilium",
        "snapshot_id": "92631c2e7abeeae6a80debbb699441d6b56e2fee",
        "revision_id": "6aa88fe0c40fe72850e5bdb265741a375b2ab766",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-03-14 05:50:41",
        "revision_date": "2018-05-13 01:00:24",
        "committer_date": "2018-05-13 01:00:24",
        "github_id": 131472364,
        "star_events_count": 0,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 37762,
        "extension": "h",
        "content": "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2015 The Bitcoin Core developers\n// Copyright (c) 2014-2017 The Dash Core developers\n// Copyright (c) 2018 The Exilium Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#ifndef BITCOIN_WALLET_WALLET_H\n#define BITCOIN_WALLET_WALLET_H\n\n#include \"amount.h\"\n#include \"base58.h\"\n#include \"streams.h\"\n#include \"tinyformat.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"utilstrencodings.h\"\n#include \"validationinterface.h\"\n#include \"wallet/crypter.h\"\n#include \"wallet/wallet_ismine.h\"\n#include \"wallet/walletdb.h\"\n\n#include \"privatesend.h\"\n\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stdexcept>\n#include <stdint.h>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <boost/shared_ptr.hpp>\n\n/**\n * Settings\n */\nextern CFeeRate payTxFee;\nextern CAmount maxTxFee;\nextern unsigned int nTxConfirmTarget;\nextern bool bSpendZeroConfChange;\nextern bool fSendFreeTransactions;\n\nstatic const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n//! -paytxfee default\nstatic const CAmount DEFAULT_TRANSACTION_FEE = 0;\n//! -paytxfee will warn if called with a higher fee than this amount (in satoshis) per KB\nstatic const CAmount nHighTransactionFeeWarning = 0.01 * COIN;\n//! -fallbackfee default\nstatic const CAmount DEFAULT_FALLBACK_FEE = 1000;\n//! -mintxfee default\nstatic const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n//! -maxtxfee default\nstatic const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.2 * COIN; // \"smallest denom\" + X * \"denom tails\"\n//! minimum change amount\nstatic const CAmount MIN_CHANGE = CENT;\n//! Default for -spendzeroconfchange\nstatic const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;\n//! Default for -sendfreetransactions\nstatic const bool DEFAULT_SEND_FREE_TRANSACTIONS = false;\n//! -txconfirmtarget default\nstatic const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2;\n//! -maxtxfee will warn if called with a higher fee than this amount (in satoshis)\nstatic const CAmount nHighTransactionMaxFeeWarning = 100 * nHighTransactionFeeWarning;\n//! Largest (in bytes) free transaction we're willing to create\nstatic const unsigned int MAX_FREE_TRANSACTION_CREATE_SIZE = 1000;\nstatic const bool DEFAULT_WALLETBROADCAST = true;\n\n//! if set, all keys will be derived by using BIP39/BIP44\nstatic const bool DEFAULT_USE_HD_WALLET = false;\n\nclass CBlockIndex;\nclass CCoinControl;\nclass COutput;\nclass CReserveKey;\nclass CScript;\nclass CTxMemPool;\nclass CWalletTx;\n\n/** (client) version numbers for particular wallet features */\nenum WalletFeature\n{\n    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getinfo's clientversion output)\n\n    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n    FEATURE_HD = 120200,    // Hierarchical key derivation after BIP32 (HD Wallet), BIP44 (multi-coin), BIP39 (mnemonic)\n                            // which uses on-the-fly private key derivation\n\n    FEATURE_LATEST = 61000\n};\n\nenum AvailableCoinsType\n{\n    ALL_COINS,\n    ONLY_DENOMINATED,\n    ONLY_NONDENOMINATED,\n    ONLY_1000, // find masternode outputs including locked ones (use with caution)\n    ONLY_PRIVATESEND_COLLATERAL\n};\n\nstruct CompactTallyItem\n{\n    CTxDestination txdest;\n    CAmount nAmount;\n    std::vector<CTxIn> vecTxIn;\n    CompactTallyItem()\n    {\n        nAmount = 0;\n    }\n};\n\n/** A key pool entry */\nclass CKeyPool\n{\npublic:\n    int64_t nTime;\n    CPubKey vchPubKey;\n    bool fInternal; // for change outputs\n\n    CKeyPool();\n    CKeyPool(const CPubKey& vchPubKeyIn, bool fInternalIn);\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(nTime);\n        READWRITE(vchPubKey);\n        if (ser_action.ForRead()) {\n            try {\n                READWRITE(fInternal);\n            }\n            catch (std::ios_base::failure&) {\n                /* flag as external address if we can't read the internal boolean\n                   (this will be the case for any wallet before the HD chain split version) */\n                fInternal = false;\n            }\n        }\n        else {\n            READWRITE(fInternal);\n        }\n    }\n};\n\n/** Address book data */\nclass CAddressBookData\n{\npublic:\n    std::string name;\n    std::string purpose;\n\n    CAddressBookData()\n    {\n        purpose = \"unknown\";\n    }\n\n    typedef std::map<std::string, std::string> StringMap;\n    StringMap destdata;\n};\n\nstruct CRecipient\n{\n    CScript scriptPubKey;\n    CAmount nAmount;\n    bool fSubtractFeeFromAmount;\n};\n\ntypedef std::map<std::string, std::string> mapValue_t;\n\n\nstatic void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n{\n    if (!mapValue.count(\"n\"))\n    {\n        nOrderPos = -1; // TODO: calculate elsewhere\n        return;\n    }\n    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n}\n\n\nstatic void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n{\n    if (nOrderPos == -1)\n        return;\n    mapValue[\"n\"] = i64tostr(nOrderPos);\n}\n\nstruct COutputEntry\n{\n    CTxDestination destination;\n    CAmount amount;\n    int vout;\n};\n\n/** A transaction with a merkle branch linking it to the block chain. */\nclass CMerkleTx : public CTransaction\n{\nprivate:\n  /** Constant used in hashBlock to indicate tx has been abandoned */\n    static const uint256 ABANDON_HASH;\n\npublic:\n    uint256 hashBlock;\n\n    /* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest\n     * block in the chain we know this or any in-wallet dependency conflicts\n     * with. Older clients interpret nIndex == -1 as unconfirmed for backward\n     * compatibility.\n     */\n    int nIndex;\n\n    CMerkleTx()\n    {\n        Init();\n    }\n\n    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n    {\n        Init();\n    }\n\n    void Init()\n    {\n        hashBlock = uint256();\n        nIndex = -1;\n    }\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        std::vector<uint256> vMerkleBranch; // For compatibility with older versions.\n        READWRITE(*(CTransaction*)this);\n        nVersion = this->nVersion;\n        READWRITE(hashBlock);\n        READWRITE(vMerkleBranch);\n        READWRITE(nIndex);\n    }\n\n    int SetMerkleBranch(const CBlock& block);\n\n    /**\n     * Return depth of transaction in blockchain:\n     * <0  : conflicts with a transaction this deep in the blockchain\n     *  0  : in memory pool, waiting to be included in a block\n     * >=1 : this many blocks deep in the main chain\n     */\n    int GetDepthInMainChain(const CBlockIndex* &pindexRet, bool enableIX = true) const;\n    int GetDepthInMainChain(bool enableIX = true) const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet, enableIX); }\n    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) > 0; }\n    int GetBlocksToMaturity() const;\n    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectAbsurdFee=true);\n    bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); }\n    bool isAbandoned() const { return (hashBlock == ABANDON_HASH); }\n    void setAbandoned() { hashBlock = ABANDON_HASH; }\n};\n\n/** \n * A transaction with a bunch of additional info that only the owner cares about.\n * It includes any unrecorded transactions needed to link it back to the block chain.\n */\nclass CWalletTx : public CMerkleTx\n{\nprivate:\n    const CWallet* pwallet;\n\npublic:\n    mapValue_t mapValue;\n    std::vector<std::pair<std::string, std::string> > vOrderForm;\n    unsigned int fTimeReceivedIsTxTime;\n    unsigned int nTimeReceived; //! time received by this node\n    unsigned int nTimeSmart;\n    char fFromMe;\n    std::string strFromAccount;\n    int64_t nOrderPos; //! position in ordered transaction list\n\n    // memory only\n    mutable bool fDebitCached;\n    mutable bool fCreditCached;\n    mutable bool fImmatureCreditCached;\n    mutable bool fAvailableCreditCached;\n    mutable bool fAnonymizedCreditCached;\n    mutable bool fDenomUnconfCreditCached;\n    mutable bool fDenomConfCreditCached;\n    mutable bool fWatchDebitCached;\n    mutable bool fWatchCreditCached;\n    mutable bool fImmatureWatchCreditCached;\n    mutable bool fAvailableWatchCreditCached;\n    mutable bool fChangeCached;\n    mutable CAmount nDebitCached;\n    mutable CAmount nCreditCached;\n    mutable CAmount nImmatureCreditCached;\n    mutable CAmount nAvailableCreditCached;\n    mutable CAmount nAnonymizedCreditCached;\n    mutable CAmount nDenomUnconfCreditCached;\n    mutable CAmount nDenomConfCreditCached;\n    mutable CAmount nWatchDebitCached;\n    mutable CAmount nWatchCreditCached;\n    mutable CAmount nImmatureWatchCreditCached;\n    mutable CAmount nAvailableWatchCreditCached;\n    mutable CAmount nChangeCached;\n\n    CWalletTx()\n    {\n        Init(NULL);\n    }\n\n    CWalletTx(const CWallet* pwalletIn)\n    {\n        Init(pwalletIn);\n    }\n\n    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n    {\n        Init(pwalletIn);\n    }\n\n    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n    {\n        Init(pwalletIn);\n    }\n\n    void Init(const CWallet* pwalletIn)\n    {\n        pwallet = pwalletIn;\n        mapValue.clear();\n        vOrderForm.clear();\n        fTimeReceivedIsTxTime = false;\n        nTimeReceived = 0;\n        nTimeSmart = 0;\n        fFromMe = false;\n        strFromAccount.clear();\n        fDebitCached = false;\n        fCreditCached = false;\n        fImmatureCreditCached = false;\n        fAvailableCreditCached = false;\n        fAnonymizedCreditCached = false;\n        fDenomUnconfCreditCached = false;\n        fDenomConfCreditCached = false;\n        fWatchDebitCached = false;\n        fWatchCreditCached = false;\n        fImmatureWatchCreditCached = false;\n        fAvailableWatchCreditCached = false;\n        fChangeCached = false;\n        nDebitCached = 0;\n        nCreditCached = 0;\n        nImmatureCreditCached = 0;\n        nAvailableCreditCached = 0;\n        nAnonymizedCreditCached = 0;\n        nDenomUnconfCreditCached = 0;\n        nDenomConfCreditCached = 0;\n        nWatchDebitCached = 0;\n        nWatchCreditCached = 0;\n        nAvailableWatchCreditCached = 0;\n        nImmatureWatchCreditCached = 0;\n        nChangeCached = 0;\n        nOrderPos = -1;\n    }\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        if (ser_action.ForRead())\n            Init(NULL);\n        char fSpent = false;\n\n        if (!ser_action.ForRead())\n        {\n            mapValue[\"fromaccount\"] = strFromAccount;\n\n            WriteOrderPos(nOrderPos, mapValue);\n\n            if (nTimeSmart)\n                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n        }\n\n        READWRITE(*(CMerkleTx*)this);\n        std::vector<CMerkleTx> vUnused; //! Used to be vtxPrev\n        READWRITE(vUnused);\n        READWRITE(mapValue);\n        READWRITE(vOrderForm);\n        READWRITE(fTimeReceivedIsTxTime);\n        READWRITE(nTimeReceived);\n        READWRITE(fFromMe);\n        READWRITE(fSpent);\n\n        if (ser_action.ForRead())\n        {\n            strFromAccount = mapValue[\"fromaccount\"];\n\n            ReadOrderPos(nOrderPos, mapValue);\n\n            nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n        }\n\n        mapValue.erase(\"fromaccount\");\n        mapValue.erase(\"version\");\n        mapValue.erase(\"spent\");\n        mapValue.erase(\"n\");\n        mapValue.erase(\"timesmart\");\n    }\n\n    //! make sure balances are recalculated\n    void MarkDirty()\n    {\n        fCreditCached = false;\n        fAvailableCreditCached = false;\n        fImmatureCreditCached = false;\n        fAnonymizedCreditCached = false;\n        fDenomUnconfCreditCached = false;\n        fDenomConfCreditCached = false;\n        fWatchDebitCached = false;\n        fWatchCreditCached = false;\n        fAvailableWatchCreditCached = false;\n        fImmatureWatchCreditCached = false;\n        fDebitCached = false;\n        fChangeCached = false;\n    }\n\n    void BindWallet(CWallet *pwalletIn)\n    {\n        pwallet = pwalletIn;\n        MarkDirty();\n    }\n\n    //! filter decides which addresses will count towards the debit\n    CAmount GetDebit(const isminefilter& filter) const;\n    CAmount GetCredit(const isminefilter& filter) const;\n    CAmount GetImmatureCredit(bool fUseCache=true) const;\n    CAmount GetAvailableCredit(bool fUseCache=true) const;\n    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;\n    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;\n    CAmount GetChange() const;\n\n    CAmount GetAnonymizedCredit(bool fUseCache=true) const;\n    CAmount GetDenominatedCredit(bool unconfirmed, bool fUseCache=true) const;\n\n    void GetAmounts(std::list<COutputEntry>& listReceived,\n                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n\n    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n\n    bool IsFromMe(const isminefilter& filter) const\n    {\n        return (GetDebit(filter) > 0);\n    }\n\n    // True if only scriptSigs are different\n    bool IsEquivalentTo(const CWalletTx& tx) const;\n\n    bool InMempool() const;\n    bool IsTrusted() const;\n\n    bool WriteToDisk(CWalletDB *pwalletdb);\n\n    int64_t GetTxTime() const;\n    int GetRequestCount() const;\n\n    bool RelayWalletTransaction(CConnman* connman, std::string strCommand=\"tx\");\n\n    std::set<uint256> GetConflicts() const;\n};\n\n\n\n\nclass COutput\n{\npublic:\n    const CWalletTx *tx;\n    int i;\n    int nDepth;\n    bool fSpendable;\n    bool fSolvable;\n\n    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn)\n    {\n        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn;\n    }\n\n    //Used with Darksend. Will return largest nondenom, then denominations, then very small inputs\n    int Priority() const;\n\n    std::string ToString() const;\n};\n\n\n\n\n/** Private key that includes an expiration date in case it never gets used. */\nclass CWalletKey\n{\npublic:\n    CPrivKey vchPrivKey;\n    int64_t nTimeCreated;\n    int64_t nTimeExpires;\n    std::string strComment;\n    //! todo: add something to note what created it (user, getnewaddress, change)\n    //!   maybe should have a map<string, string> property map\n\n    CWalletKey(int64_t nExpires=0);\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(vchPrivKey);\n        READWRITE(nTimeCreated);\n        READWRITE(nTimeExpires);\n        READWRITE(LIMITED_STRING(strComment, 65536));\n    }\n};\n\n/**\n * Internal transfers.\n * Database key is acentry<account><counter>.\n */\nclass CAccountingEntry\n{\npublic:\n    std::string strAccount;\n    CAmount nCreditDebit;\n    int64_t nTime;\n    std::string strOtherAccount;\n    std::string strComment;\n    mapValue_t mapValue;\n    int64_t nOrderPos;  //! position in ordered transaction list\n    uint64_t nEntryNo;\n\n    CAccountingEntry()\n    {\n        SetNull();\n    }\n\n    void SetNull()\n    {\n        nCreditDebit = 0;\n        nTime = 0;\n        strAccount.clear();\n        strOtherAccount.clear();\n        strComment.clear();\n        nOrderPos = -1;\n        nEntryNo = 0;\n    }\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        //! Note: strAccount is serialized as part of the key, not here.\n        READWRITE(nCreditDebit);\n        READWRITE(nTime);\n        READWRITE(LIMITED_STRING(strOtherAccount, 65536));\n\n        if (!ser_action.ForRead())\n        {\n            WriteOrderPos(nOrderPos, mapValue);\n\n            if (!(mapValue.empty() && _ssExtra.empty()))\n            {\n                CDataStream ss(nType, nVersion);\n                ss.insert(ss.begin(), '\\0');\n                ss << mapValue;\n                ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());\n                strComment.append(ss.str());\n            }\n        }\n\n        READWRITE(LIMITED_STRING(strComment, 65536));\n\n        size_t nSepPos = strComment.find(\"\\0\", 0, 1);\n        if (ser_action.ForRead())\n        {\n            mapValue.clear();\n            if (std::string::npos != nSepPos)\n            {\n                CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), nType, nVersion);\n                ss >> mapValue;\n                _ssExtra = std::vector<char>(ss.begin(), ss.end());\n            }\n            ReadOrderPos(nOrderPos, mapValue);\n        }\n        if (std::string::npos != nSepPos)\n            strComment.erase(nSepPos);\n\n        mapValue.erase(\"n\");\n    }\n\nprivate:\n    std::vector<char> _ssExtra;\n};\n\n\n/** \n * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n * and provides the ability to create new transactions.\n */\nclass CWallet : public CCryptoKeyStore, public CValidationInterface\n{\nprivate:\n    /**\n     * Select a set of coins such that nValueRet >= nTargetValue and at least\n     * all coins from coinControl are selected; Never select unconfirmed coins\n     * if they are not ours\n     */\n    bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL, AvailableCoinsType nCoinType=ALL_COINS, bool fUseInstantSend = true) const;\n\n    CWalletDB *pwalletdbEncryption;\n\n    //! the current wallet version: clients below this version are not able to load the wallet\n    int nWalletVersion;\n\n    //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n    int nWalletMaxVersion;\n\n    int64_t nNextResend;\n    int64_t nLastResend;\n    bool fBroadcastTransactions;\n\n    mutable bool fAnonymizableTallyCached;\n    mutable std::vector<CompactTallyItem> vecAnonymizableTallyCached;\n    mutable bool fAnonymizableTallyCachedNonDenom;\n    mutable std::vector<CompactTallyItem> vecAnonymizableTallyCachedNonDenom;\n\n    /**\n     * Used to keep track of spent outpoints, and\n     * detect and report conflicts (double-spends or\n     * mutated transactions where the mutant gets mined).\n     */\n    typedef std::multimap<COutPoint, uint256> TxSpends;\n    TxSpends mapTxSpends;\n    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n    void AddToSpends(const uint256& wtxid);\n\n    std::set<COutPoint> setWalletUTXO;\n\n    /* Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n    void MarkConflicted(const uint256& hashBlock, const uint256& hashTx);\n\n    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n\n    /* HD derive new child key (on internal or external chain) */\n    void DeriveNewChildKey(const CKeyMetadata& metadata, CKey& secretRet, uint32_t nAccountIndex, bool fInternal /*= false*/);\n\npublic:\n    /*\n     * Main wallet lock.\n     * This lock protects all the fields added by CWallet\n     *   except for:\n     *      fFileBacked (immutable after instantiation)\n     *      strWalletFile (immutable after instantiation)\n     */\n    mutable CCriticalSection cs_wallet;\n\n    bool fFileBacked;\n    const std::string strWalletFile;\n\n    void LoadKeyPool(int nIndex, const CKeyPool &keypool)\n    {\n        if (keypool.fInternal) {\n            setInternalKeyPool.insert(nIndex);\n        } else {\n            setExternalKeyPool.insert(nIndex);\n        }\n\n        // If no metadata exists yet, create a default with the pool key's\n        // creation time. Note that this may be overwritten by actually\n        // stored metadata for that key later, which is fine.\n        CKeyID keyid = keypool.vchPubKey.GetID();\n        if (mapKeyMetadata.count(keyid) == 0)\n            mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n    }\n\n    std::set<int64_t> setInternalKeyPool;\n    std::set<int64_t> setExternalKeyPool;\n    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n\n    typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n    MasterKeyMap mapMasterKeys;\n    unsigned int nMasterKeyMaxID;\n\n    CWallet()\n    {\n        SetNull();\n    }\n\n    CWallet(const std::string& strWalletFileIn) \n    : strWalletFile(strWalletFileIn)\n    {\n        SetNull();\n\n        fFileBacked = true;\n    }\n\n    ~CWallet()\n    {\n        delete pwalletdbEncryption;\n        pwalletdbEncryption = NULL;\n    }\n\n    void SetNull()\n    {\n        nWalletVersion = FEATURE_BASE;\n        nWalletMaxVersion = FEATURE_BASE;\n        fFileBacked = false;\n        nMasterKeyMaxID = 0;\n        pwalletdbEncryption = NULL;\n        nOrderPosNext = 0;\n        nNextResend = 0;\n        nLastResend = 0;\n        nTimeFirstKey = 0;\n        fBroadcastTransactions = false;\n        fAnonymizableTallyCached = false;\n        fAnonymizableTallyCachedNonDenom = false;\n        vecAnonymizableTallyCached.clear();\n        vecAnonymizableTallyCachedNonDenom.clear();\n    }\n\n    std::map<uint256, CWalletTx> mapWallet;\n    std::list<CAccountingEntry> laccentries;\n\n    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n    typedef std::multimap<int64_t, TxPair > TxItems;\n    TxItems wtxOrdered;\n\n    int64_t nOrderPosNext;\n    std::map<uint256, int> mapRequestCount;\n\n    std::map<CTxDestination, CAddressBookData> mapAddressBook;\n\n    CPubKey vchDefaultKey;\n\n    std::set<COutPoint> setLockedCoins;\n\n    int64_t nTimeFirstKey;\n    int64_t nKeysLeftSinceAutoBackup;\n\n    std::map<CKeyID, CHDPubKey> mapHdPubKeys; //<! memory map of HD extended pubkeys\n\n    const CWalletTx* GetWalletTx(const uint256& hash) const;\n\n    //! check whether we are allowed to upgrade (or already support) to the named feature\n    bool CanSupportFeature(enum WalletFeature wf) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n\n    /**\n     * populate vCoins with vector of available COutputs.\n     */\n    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL, bool fIncludeZeroValue=false, AvailableCoinsType nCoinType=ALL_COINS, bool fUseInstantSend = false) const;\n\n    /**\n     * Shuffle and select coins until nTargetValue is reached while avoiding\n     * small change; This method is stochastic for some inputs and upon\n     * completion the coin set and corresponding actual target value is\n     * assembled\n     */\n    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, bool fUseInstantSend = false) const;\n\n    // Coin selection\n    bool SelectCoinsByDenominations(int nDenom, CAmount nValueMin, CAmount nValueMax, std::vector<CTxDSIn>& vecTxDSInRet, std::vector<COutput>& vCoinsRet, CAmount& nValueRet, int nPrivateSendRoundsMin, int nPrivateSendRoundsMax);\n    bool GetCollateralTxDSIn(CTxDSIn& txdsinRet, CAmount& nValueRet) const;\n    bool SelectCoinsDark(CAmount nValueMin, CAmount nValueMax, std::vector<CTxIn>& vecTxInRet, CAmount& nValueRet, int nPrivateSendRoundsMin, int nPrivateSendRoundsMax) const;\n\n    bool SelectCoinsGrouppedByAddresses(std::vector<CompactTallyItem>& vecTallyRet, bool fSkipDenominated = true, bool fAnonymizable = true, bool fSkipUnconfirmed = true) const;\n\n    /// Get 1000exilium output and keys which can be used for the Masternode\n    bool GetMasternodeOutpointAndKeys(COutPoint& outpointRet, CPubKey& pubKeyRet, CKey& keyRet, std::string strTxHash = \"\", std::string strOutputIndex = \"\");\n    /// Extract txin information and keys from output\n    bool GetOutpointAndKeysFromOutput(const COutput& out, COutPoint& outpointRet, CPubKey& pubKeyRet, CKey& keyRet);\n\n    bool HasCollateralInputs(bool fOnlyConfirmed = true) const;\n    int  CountInputsWithAmount(CAmount nInputAmount);\n\n    // get the PrivateSend chain depth for a given input\n    int GetRealOutpointPrivateSendRounds(const COutPoint& outpoint, int nRounds) const;\n    // respect current settings\n    int GetOutpointPrivateSendRounds(const COutPoint& outpoint) const;\n\n    bool IsDenominated(const COutPoint& outpoint) const;\n\n    bool IsSpent(const uint256& hash, unsigned int n) const;\n\n    bool IsLockedCoin(uint256 hash, unsigned int n) const;\n    void LockCoin(COutPoint& output);\n    void UnlockCoin(COutPoint& output);\n    void UnlockAllCoins();\n    void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n\n    /**\n     * keystore implementation\n     * Generate a new key\n     */\n    CPubKey GenerateNewKey(uint32_t nAccountIndex, bool fInternal /*= false*/);\n    //! HaveKey implementation that also checks the mapHdPubKeys\n    bool HaveKey(const CKeyID &address) const;\n    //! GetPubKey implementation that also checks the mapHdPubKeys\n    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n    //! GetKey implementation that can derive a HD private key on the fly\n    bool GetKey(const CKeyID &address, CKey& keyOut) const;\n    //! Adds a HDPubKey into the wallet(database)\n    bool AddHDPubKey(const CExtPubKey &extPubKey, bool fInternal);\n    //! loads a HDPubKey into the wallets memory\n    bool LoadHDPubKey(const CHDPubKey &hdPubKey);\n    //! Adds a key to the store, and saves it to disk.\n    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n    //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n    bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n    //! Load metadata (used by LoadWallet)\n    bool LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &metadata);\n\n    bool LoadMinVersion(int nVersion) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n\n    //! Adds an encrypted key to the store, and saves it to disk.\n    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n    //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n    bool LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n    bool AddCScript(const CScript& redeemScript);\n    bool LoadCScript(const CScript& redeemScript);\n\n    //! Adds a destination data tuple to the store, and saves it to disk\n    bool AddDestData(const CTxDestination &dest, const std::string &key, const std::string &value);\n    //! Erases a destination data tuple in the store and on disk\n    bool EraseDestData(const CTxDestination &dest, const std::string &key);\n    //! Adds a destination data tuple to the store, without saving it to disk\n    bool LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value);\n    //! Look up a destination data tuple in the store, return true if found false otherwise\n    bool GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const;\n\n    //! Adds a watch-only address to the store, and saves it to disk.\n    bool AddWatchOnly(const CScript &dest);\n    bool RemoveWatchOnly(const CScript &dest);\n    //! Adds a watch-only address to the store, without saving it to disk (used by LoadWallet)\n    bool LoadWatchOnly(const CScript &dest);\n\n    bool Unlock(const SecureString& strWalletPassphrase, bool fForMixingOnly = false);\n    bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n    bool EncryptWallet(const SecureString& strWalletPassphrase);\n\n    void GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const;\n\n    /** \n     * Increment the next transaction order id\n     * @return next transaction order id\n     */\n    int64_t IncOrderPosNext(CWalletDB *pwalletdb = NULL);\n\n    void MarkDirty();\n    bool AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletDB* pwalletdb);\n    void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n    int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n    void ReacceptWalletTransactions();\n    void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman);\n    std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman);\n    CAmount GetBalance() const;\n    CAmount GetUnconfirmedBalance() const;\n    CAmount GetImmatureBalance() const;\n    CAmount GetWatchOnlyBalance() const;\n    CAmount GetUnconfirmedWatchOnlyBalance() const;\n    CAmount GetImmatureWatchOnlyBalance() const;\n\n    CAmount GetAnonymizableBalance(bool fSkipDenominated = false, bool fSkipUnconfirmed = true) const;\n    CAmount GetAnonymizedBalance() const;\n    float GetAverageAnonymizedRounds() const;\n    CAmount GetNormalizedAnonymizedBalance() const;\n    CAmount GetNeedsToBeAnonymizedBalance(CAmount nMinBalance = 0) const;\n    CAmount GetDenominatedBalance(bool unconfirmed=false) const;\n\n    bool GetBudgetSystemCollateralTX(CTransaction& tx, uint256 hash, CAmount amount, bool fUseInstantSend);\n    bool GetBudgetSystemCollateralTX(CWalletTx& tx, uint256 hash, CAmount amount, bool fUseInstantSend);\n\n    /**\n     * Insert additional inputs into the transaction by\n     * calling CreateTransaction();\n     */\n    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, bool includeWatching);\n\n    /**\n     * Create a new transaction paying the recipients with a set of coins\n     * selected by SelectCoins(); Also create the change output, when needed\n     */\n    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet,\n                           std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true, AvailableCoinsType nCoinType=ALL_COINS, bool fUseInstantSend=false);\n    bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CConnman* connman, std::string strCommand=\"tx\");\n\n    bool CreateCollateralTransaction(CMutableTransaction& txCollateral, std::string& strReason);\n    bool ConvertList(std::vector<CTxIn> vecTxIn, std::vector<CAmount>& vecAmounts);\n\n    bool AddAccountingEntry(const CAccountingEntry&, CWalletDB & pwalletdb);\n\n    static CFeeRate minTxFee;\n    static CFeeRate fallbackFee;\n    /**\n     * Estimate the minimum fee considering user set parameters\n     * and the required fee\n     */\n    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);\n    /**\n     * Return the minimum required fee taking into account the\n     * floating relay fee and user set minimum transaction fee\n     */\n    static CAmount GetRequiredFee(unsigned int nTxBytes);\n\n    bool NewKeyPool();\n    size_t KeypoolCountExternalKeys();\n    size_t KeypoolCountInternalKeys();\n    bool TopUpKeyPool(unsigned int kpSize = 0);\n    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fInternal);\n    void KeepKey(int64_t nIndex);\n    void ReturnKey(int64_t nIndex, bool fInternal);\n    bool GetKeyFromPool(CPubKey &key, bool fInternal /*= false*/);\n    int64_t GetOldestKeyPoolTime();\n    void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;\n\n    std::set< std::set<CTxDestination> > GetAddressGroupings();\n    std::map<CTxDestination, CAmount> GetAddressBalances();\n\n    std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n\n    isminetype IsMine(const CTxIn& txin) const;\n    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n    isminetype IsMine(const CTxOut& txout) const;\n    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n    bool IsChange(const CTxOut& txout) const;\n    CAmount GetChange(const CTxOut& txout) const;\n    bool IsMine(const CTransaction& tx) const;\n    /** should probably be renamed to IsRelevantToMe */\n    bool IsFromMe(const CTransaction& tx) const;\n    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n    CAmount GetChange(const CTransaction& tx) const;\n    void SetBestChain(const CBlockLocator& loc);\n\n    DBErrors LoadWallet(bool& fFirstRunRet);\n    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n\n    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n\n    bool DelAddressBook(const CTxDestination& address);\n\n    bool UpdatedTransaction(const uint256 &hashTx);\n\n    void Inventory(const uint256 &hash)\n    {\n        {\n            LOCK(cs_wallet);\n            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n            if (mi != mapRequestCount.end())\n                (*mi).second++;\n        }\n    }\n\n    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);\n    void ResetRequestCount(const uint256 &hash)\n    {\n        LOCK(cs_wallet);\n        mapRequestCount[hash] = 0;\n    };\n    \n    unsigned int GetKeyPoolSize()\n    {\n        AssertLockHeld(cs_wallet); // set{Ex,In}ternalKeyPool\n        return setInternalKeyPool.size() + setExternalKeyPool.size();\n    }\n\n    bool SetDefaultKey(const CPubKey &vchPubKey);\n\n    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n\n    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n    bool SetMaxVersion(int nVersion);\n\n    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n\n    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n    std::set<uint256> GetConflicts(const uint256& txid) const;\n\n    //! Flush wallet (bitdb flush)\n    void Flush(bool shutdown=false);\n\n    //! Verify the wallet database and perform salvage if required\n    static bool Verify(const std::string& walletFile, std::string& warningString, std::string& errorString);\n    \n    /** \n     * Address book entry changed.\n     * @note called with lock cs_wallet held.\n     */\n    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n            &address, const std::string &label, bool isMine,\n            const std::string &purpose,\n            ChangeType status)> NotifyAddressBookChanged;\n\n    /** \n     * Wallet transaction added, removed or updated.\n     * @note called with lock cs_wallet held.\n     */\n    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n            ChangeType status)> NotifyTransactionChanged;\n\n    /** Show progress e.g. for rescan */\n    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n\n    /** Watch-only address added */\n    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n\n    /** Inquire whether this wallet broadcasts transactions. */\n    bool GetBroadcastTransactions() const { return fBroadcastTransactions; }\n    /** Set whether this wallet broadcasts transactions. */\n    void SetBroadcastTransactions(bool broadcast) { fBroadcastTransactions = broadcast; }\n\n    /* Mark a transaction (and it in-wallet descendants) as abandoned so its inputs may be respent. */\n    bool AbandonTransaction(const uint256& hashTx);\n\n    /**\n     * HD Wallet Functions\n     */\n\n    /* Returns true if HD is enabled */\n    bool IsHDEnabled();\n    /* Generates a new HD chain */\n    void GenerateNewHDChain();\n    /* Set the HD chain model (chain child index counters) */\n    bool SetHDChain(const CHDChain& chain, bool memonly);\n    bool SetCryptedHDChain(const CHDChain& chain, bool memonly);\n    bool GetDecryptedHDChain(CHDChain& hdChainRet);\n};\n\n/** A key allocated from the key pool. */\nclass CReserveKey : public CReserveScript\n{\nprotected:\n    CWallet* pwallet;\n    int64_t nIndex;\n    CPubKey vchPubKey;\n    bool fInternal;\npublic:\n    CReserveKey(CWallet* pwalletIn)\n    {\n        nIndex = -1;\n        pwallet = pwalletIn;\n        fInternal = false;\n    }\n\n    ~CReserveKey()\n    {\n        ReturnKey();\n    }\n\n    void ReturnKey();\n    bool GetReservedKey(CPubKey &pubkey, bool fInternalIn /*= false*/);\n    void KeepKey();\n    void KeepScript() { KeepKey(); }\n};\n\n\n/** \n * Account information.\n * Stored in wallet with key \"acc\"+string account name.\n */\nclass CAccount\n{\npublic:\n    CPubKey vchPubKey;\n\n    CAccount()\n    {\n        SetNull();\n    }\n\n    void SetNull()\n    {\n        vchPubKey = CPubKey();\n    }\n\n    ADD_SERIALIZE_METHODS;\n\n    template <typename Stream, typename Operation>\n    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(vchPubKey);\n    }\n};\n\n#endif // BITCOIN_WALLET_WALLET_H\n",
        "blame_info": {
            "devexilium@gmail.com": [
                [
                    1,
                    1097
                ]
            ]
        }
    },
    {
        "blob_id": "0e5baca75fdd2c54621542f6cf7b7bde1bdf4164",
        "directory_id": "fdebe3129bb47afc1924e45e1ed3c97ee9213ac4",
        "path": "/GA-TSP/test.cpp",
        "content_id": "3bbfaacce92afe022185cf0c23ee0c0d44e5e17d",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "SYSU532/artificial-intelligence",
        "snapshot_id": "3604e07b3670555d65ac2d36dbbf458f69658a07",
        "revision_id": "e0847fb1d181415137580e1c3e529e2120ed09d4",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-04-05 20:26:14",
        "revision_date": "2019-01-11 12:50:27",
        "committer_date": "2019-01-11 12:50:27",
        "github_id": 157179948,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1044,
        "extension": "cpp",
        "content": "#include <node.h>\n\nnamespace demo{\n    using v8::FunctionCallbackInfo;\n    using v8::Isolate;\n    using v8::Local;\n    using v8::Object;\n    using v8::String;\n    using v8::Value;\n    using v8::Number;\n\n    // Method1 \u5b9e\u73b0\u4e00\u4e2a \u8f93\u51fa\"hello world ONE !\" \u7684\u65b9\u6cd5\n    void Method1(const FunctionCallbackInfo<Value>& args){\n        Isolate* isolate = args.GetIsolate();\n        args.GetReturnValue().Set(String::NewFromUtf8(isolate, \"hello world ONE !\"));\n    }\n\n    // Method2 \u5b9e\u73b0\u4e00\u4e2a \u52a0\u4e00 \u7684\u65b9\u6cd5\n    void Method2(const FunctionCallbackInfo<Value>& args){\n        Isolate* isolate = args.GetIsolate();\n        Local<Number> value = Local<Number>::Cast(args[0]); \n        double num = value->NumberValue() + 1;\n\n        char buf[128] = {0};\n        sprintf(buf,\"%f\", num);\n\n        args.GetReturnValue().Set(String::NewFromUtf8(isolate, buf));\n    }\n\n    void init(Local<Object> exports){\n        NODE_SET_METHOD(exports, \"hello1\", Method1);\n        NODE_SET_METHOD(exports, \"addOne\", Method2);\n    }\n\n    NODE_MODULE(addon, init)\n}",
        "blame_info": {
            "chenmliang@mail2.sysu.edu.cn": [
                [
                    1,
                    36
                ]
            ]
        }
    },
    {
        "blob_id": "d906994d3f90133151039af0434882e3553ba719",
        "directory_id": "1c02e13a776e5e8bc3e2a6182b5df4efb2c71d32",
        "path": "/core/unit_test/tstDeepCopy.hpp",
        "content_id": "b3fdab4da5ef0b61357d256cf996dae1b69884f0",
        "detected_licenses": [
            "BSD-3-Clause"
        ],
        "license_type": "permissive",
        "repo_name": "junghans/Cabana",
        "snapshot_id": "91b82827dd9fb8321bea9ea3750c196946a6aac0",
        "revision_id": "7b9078f81bde68c949fd6ae913ce80eeaf0f8f8a",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-06-14 09:57:01",
        "revision_date": "2019-01-04 22:24:45",
        "committer_date": "2019-01-04 22:24:45",
        "github_id": 150330482,
        "star_events_count": 1,
        "fork_events_count": 1,
        "gha_license_id": "BSD-3-Clause",
        "gha_event_created_at": "2019-01-07 16:24:20",
        "gha_created_at": "2018-09-25 21:17:53",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 5252,
        "extension": "hpp",
        "content": "/****************************************************************************\n * Copyright (c) 2018 by the Cabana authors                                 *\n * All rights reserved.                                                     *\n *                                                                          *\n * This file is part of the Cabana library. Cabana is distributed under a   *\n * BSD 3-clause license. For the licensing terms see the LICENSE file in    *\n * the top-level directory.                                                 *\n *                                                                          *\n * SPDX-License-Identifier: BSD-3-Clause                                    *\n ****************************************************************************/\n\n#include <Cabana_DeepCopy.hpp>\n#include <Cabana_AoSoA.hpp>\n#include <Cabana_Types.hpp>\n\n#include <gtest/gtest.h>\n\nnamespace Test\n{\n\n//---------------------------------------------------------------------------//\n// Check the data given a set of values.\ntemplate<class aosoa_type>\nvoid checkDataMembers(\n    aosoa_type aosoa,\n    const float fval, const double dval, const int ival,\n    const int dim_1, const int dim_2, const int dim_3 )\n{\n    auto slice_0 = aosoa.template slice<0>();\n    auto slice_1 = aosoa.template slice<1>();\n    auto slice_2 = aosoa.template slice<2>();\n    auto slice_3 = aosoa.template slice<3>();\n\n    for ( std::size_t idx = 0; idx < aosoa.size(); ++idx )\n    {\n        // Member 0.\n        for ( int i = 0; i < dim_1; ++i )\n            for ( int j = 0; j < dim_2; ++j )\n                for ( int k = 0; k < dim_3; ++k )\n                    EXPECT_EQ( slice_0( idx, i, j, k ),\n                                 fval * (i+j+k) );\n\n        // Member 1.\n        EXPECT_EQ( slice_1( idx ), ival );\n\n        // Member 2.\n        for ( int i = 0; i < dim_1; ++i )\n            EXPECT_EQ( slice_2( idx, i ), dval * i );\n\n        // Member 3.\n        for ( int i = 0; i < dim_1; ++i )\n            for ( int j = 0; j < dim_2; ++j )\n                EXPECT_EQ( slice_3( idx, i, j ), dval * (i+j) );\n    }\n}\n\n//---------------------------------------------------------------------------//\n// Perform a deep copy test.\ntemplate<class DstMemorySpace, class SrcMemorySpace,\n         int DstVectorLength, int SrcVectorLength>\nvoid testDeepCopy()\n{\n    // Data dimensions.\n    const int dim_1 = 3;\n    const int dim_2 = 2;\n    const int dim_3 = 4;\n\n    // Declare data types.\n    using DataTypes =\n        Cabana::MemberTypes<float[dim_1][dim_2][dim_3],\n                            int,\n                            double[dim_1],\n                            double[dim_1][dim_2]\n                            >;\n\n    // Declare the AoSoA types.\n    using DstAoSoA_t = Cabana::AoSoA<DataTypes,DstMemorySpace,DstVectorLength>;\n    using SrcAoSoA_t = Cabana::AoSoA<DataTypes,SrcMemorySpace,SrcVectorLength>;\n\n    // Create AoSoAs.\n    int num_data = 357;\n    DstAoSoA_t dst_aosoa( num_data );\n    SrcAoSoA_t src_aosoa( num_data );\n\n    // Initialize data with the rank accessors.\n    float fval = 3.4;\n    double dval = 1.23;\n    int ival = 1;\n    auto slice_0 = src_aosoa.template slice<0>();\n    auto slice_1 = src_aosoa.template slice<1>();\n    auto slice_2 = src_aosoa.template slice<2>();\n    auto slice_3 = src_aosoa.template slice<3>();\n    for ( std::size_t idx = 0; idx < src_aosoa.size(); ++idx )\n    {\n        // Member 0.\n        for ( int i = 0; i < dim_1; ++i )\n            for ( int j = 0; j < dim_2; ++j )\n                for ( int k = 0; k < dim_3; ++k )\n                    slice_0( idx, i, j, k ) = fval * (i+j+k);\n\n        // Member 1.\n        slice_1( idx ) = ival;\n\n        // Member 2.\n        for ( int i = 0; i < dim_1; ++i )\n            slice_2( idx, i ) = dval * i;\n\n        // Member 3.\n        for ( int i = 0; i < dim_1; ++i )\n            for ( int j = 0; j < dim_2; ++j )\n                slice_3( idx, i, j ) = dval * (i+j);\n    }\n\n    // Deep copy\n    Cabana::deep_copy( dst_aosoa, src_aosoa );\n\n    // Check values.\n    checkDataMembers( dst_aosoa, fval, dval, ival, dim_1, dim_2, dim_3 );\n}\n\n//---------------------------------------------------------------------------//\n// TESTS\n//---------------------------------------------------------------------------//\nTEST_F( TEST_CATEGORY, deep_copy_to_host_same_layout_test )\n{\n    testDeepCopy<Cabana::HostSpace,TEST_MEMSPACE,16,16>();\n}\n\n//---------------------------------------------------------------------------//\nTEST_F( TEST_CATEGORY, deep_copy_from_host_same_layout_test )\n{\n    testDeepCopy<TEST_MEMSPACE,Cabana::HostSpace,16,16>();\n}\n\n//---------------------------------------------------------------------------//\nTEST_F( TEST_CATEGORY, deep_copy_to_host_different_layout_test )\n{\n    testDeepCopy<Cabana::HostSpace,TEST_MEMSPACE,16,32>();\n    testDeepCopy<Cabana::HostSpace,TEST_MEMSPACE,64,8>();\n}\n\n//---------------------------------------------------------------------------//\nTEST_F( TEST_CATEGORY, deep_copy_from_host_different_layout_test )\n{\n    testDeepCopy<TEST_MEMSPACE,Cabana::HostSpace,64,8>();\n    testDeepCopy<TEST_MEMSPACE,Cabana::HostSpace,16,32>();\n}\n\n//---------------------------------------------------------------------------//\n\n} // end namespace Test\n",
        "blame_info": {
            "slatterysr@ornl.gov": [
                [
                    1,
                    151
                ]
            ]
        }
    },
    {
        "blob_id": "06c1ab5ff8ab138987ba9ad1ed0f423d945bafe7",
        "directory_id": "6817617489ef291d4d53ac844ba7a2b14cc17ae2",
        "path": "/11942.cpp",
        "content_id": "dcc6c32bd3395a76801df96fb6b8693215e020ec",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "Asad51/UVA-Problem-Solving",
        "snapshot_id": "1932f2cd73261cd702f58d4f189a4a134dbd6286",
        "revision_id": "af28ae36a2074d4e2a67670dbbbd507438c56c3e",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-03-23 14:52:49",
        "revision_date": "2019-10-24 17:03:37",
        "committer_date": "2019-10-24 17:03:37",
        "github_id": 120592261,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 449,
        "extension": "cpp",
        "content": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint t;\n\tcin>>t;\n\tcout<<\"Lumberjacks:\\n\";\n\twhile(t--){\n\t\tbool in = true;\n\t\tbool dec = true;\n\t\tint p;\n\t\tfor(int i=0; i<10; i++){\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tif(!i){\n\t\t\t\tp = n;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(n<p || !in)\n\t\t\t\tin = false;\n\t\t\tif(n>p || !dec)\n\t\t\t\tdec = false;\n\t\t\tp = n;\n\t\t}\n\t\tif(!in && !dec)\n\t\t\tcout<<\"Unordered\\n\";\n\t\telse\n\t\t\tcout<<\"Ordered\\n\";\n\t}\n\treturn 0;\n}\n",
        "blame_info": {
            "asad.cse.ru.15@gmail.com": [
                [
                    1,
                    32
                ]
            ]
        }
    },
    {
        "blob_id": "49d04327f2bb77b7681762dfab736d8274441b2c",
        "directory_id": "d1dc3c6ec24ce3291a257b16bd1f2aa6bd791d2e",
        "path": "/Project1/src/Main66.cpp",
        "content_id": "e774f1c5c93157824bc10e4e8b6864ae00497def",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "wrapdavid/Cherno_practice",
        "snapshot_id": "8248bbcedee31a48c536dbd191eca5265178e762",
        "revision_id": "e95ff1857fd72fc195a0e4c57c15a5965287ea69",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-09-08 10:32:04",
        "revision_date": "2020-02-11 02:29:49",
        "committer_date": "2020-02-11 02:29:49",
        "github_id": 221109286,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 242,
        "extension": "cpp",
        "content": "#include<iostream>\n\n\n\ntemplate<typename T, char N>\nclass Array {\nprivate:\n\tT m_Array[N];\npublic:\n\tchar GetArray() const { return N; }\n};\n\n\nint main() {\n\n\tArray<int, 61> array;\n\tstd::cout << array.GetArray() << std::endl;\n\n\n\tstd::cin.get();\n\n}",
        "blame_info": {
            "etdog0910@gmail.com": [
                [
                    1,
                    22
                ]
            ]
        }
    },
    {
        "blob_id": "c1be7ed8331d413fbb32c4f4da225eabb0c94905",
        "directory_id": "2d4346d0da0a4145f6bcc91a8cb2c0ab4d669d7e",
        "path": "/chat-up-server/src/Authentication/AuthenticationService.h",
        "content_id": "b172c8a7281e736007294715851af51947b6b669",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "xgallom/chat-up",
        "snapshot_id": "5570d069a495acf6398bdf1f62b1fb1d91289376",
        "revision_id": "7cb664ce745cf041fb508b04165d2179563aa010",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-04-18 05:40:58",
        "revision_date": "2019-01-29 22:36:04",
        "committer_date": "2019-01-29 22:36:04",
        "github_id": 167287878,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 608,
        "extension": "h",
        "content": "//\n// Created by xgallom on 1/27/19.\n//\n\n#ifndef CHAT_UP_AUTHENTICATIONSERVICE_H\n#define CHAT_UP_AUTHENTICATIONSERVICE_H\n\n#include <Messaging/Message.h>\n#include <Messaging/MessageSender.h>\n#include <Outcome.h>\n#include <Authentication/User.h>\n\nclass AuthenticationStorage;\n\nclass AuthenticationService {\n    AuthenticationStorage &m_storage;\n    User m_user = User();\n\npublic:\n    AuthenticationService() noexcept;\n\n    Outcome::Enum run(MessageSender &sender, const Message &message);\n\n    bool registerUser(const User &user);\n\n    User user() const noexcept;\n};\n\n\n#endif //CHAT_UP_AUTHENTICATIONSERVICE_H\n",
        "blame_info": {
            "gallo.milan.jr@gmail.com": [
                [
                    1,
                    30
                ]
            ]
        }
    },
    {
        "blob_id": "41411ede81a3f14d5f5efda3aad396093d6910f8",
        "directory_id": "16337b0d88df96767281cbc0024ed4e5e0dc2309",
        "path": "/Tic-Tac-bigToe.cpp",
        "content_id": "ccd6f979a725f324386a94cc966771516cbbf2ac",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "Xephoney/Tic-Tac-bigToe",
        "snapshot_id": "8c3c5d93a5f49799d90034a428a61d509b672883",
        "revision_id": "3ea53e4f72486c476eb673a8f1736b24f3f5442c",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-12-24 15:47:03",
        "revision_date": "2020-09-27 19:22:51",
        "committer_date": "2020-09-27 19:22:51",
        "github_id": 298370665,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "WINDOWS-1252",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 12368,
        "extension": "cpp",
        "content": "#include <iostream>\n#include <string>\n#include <vector> //This is included for the use of vectors\n#include <time.h> //This is for random number generation\n\n//Here we declare the functions that i will define further down.\n//these functions are tied to the gameplay loop\nvoid DisplayGrid();\nvoid InputAndExec();\nvoid PlayerSwitch();\nint WinConditionCheck();\nvoid CalculateComputerMove(char);\n\n//These are the main functions between games.\nvoid GamePvP();\nvoid GamePvE();\nvoid MainMenu();\n\n//The reason i went with global variables was to limit the amount of calls, and passing variables to functions and getting...\n//the right return variables. Only the important variables are global.\nstd::vector<char> grid { '1','2','3','4','5','6','7','8','9' };\n\nchar players[2] { 'X', 'O' };\nint playerIndex = 1;\n\n\nint main()\n{\n    srand(time(NULL));\n\n    //Greeting when first running the application\n    std::cout << \"Welcome to Tic-Tac-(Big)Toe \\n\";\n    MainMenu();\n    return 0;\n}\n\nvoid MainMenu()\n{\n    int answer = NULL;\n    std::cout << \"What would you like to play? \\n\";\n    std::cout << \" 1 : Player VS Player \\n\" << \" 2 : Player VS CPU \\n \\n\" << \" 8 : Exit Game \\n\";\n    std::cout << \"Select a gamemode : \";\n    std::cin >> answer;\n\n    //here we do the corresponding code execution based on what the user typed in. \n\n    // I wanted to avoid using a while loop here, because of the thought that it would be a loop, in a loop, in a loop... for ever. \n    // So instead i just kept to Functions executions.\n    // I don't know for sure whether this is the best solution or not, but it works! :D \n\n    //Here i get then input from the player and execute the right code that was selected from the player.\n    switch (answer)\n    {\n    case 0:\n        //I have to include cin.clear and cin.ignore before calling MainMenu() again, to stop it from looping forever.\n        system(\"CLS\");\n        std::cin.clear();\n        std::cin.ignore(10000, '\\n');\n        MainMenu();\n        break;\n    case 1:\n        system(\"CLS\");\n        GamePvP();\n        break;\n    case 2:\n        system(\"CLS\");\n        GamePvE();\n        break;\n    case 8:\n        std::cout << \"Closing Game\";\n        return;\n    default:\n        //I have to include cin.clear and cin.ignore before calling MainMenu() again, to stop it from looping forever.\n        system(\"CLS\");\n        std::cin.clear();\n        std::cin.ignore(10000, '\\n');\n        MainMenu();\n        break;\n    }\n}\n\nint moves = 0;\nvoid GamePvP()\n{\n    playerIndex = 0;\n    bool GameOver = false;\n    moves = 0;\n    //The reason why i fill out the grid here, is because everytime the game restarts...\n    //I need to make sure its a new grid. so it clears the board from the last game.\n    grid = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n    do\n    {\n        //as the functions says it displays the grid. \n        DisplayGrid();\n        \n        //This is for getting input, aswell as \n        InputAndExec();\n        \n        //Here i run the Win Condition function and store the result of that test in my X variable. \n        //Then we proceed to check weather that the winner was either X or O. \n        int x = WinConditionCheck();\n        if (x == 0 || x == 1)\n        {\n            //The reason for Display Grid is just to update the display so you could see where the\n            //Where the winning connections were!\n            DisplayGrid();\n            std::cout << \"\\nPlayer \" << players[x] << \" wins! Congrats! \\n\";\n            GameOver = true;\n            system(\"pause\");\n        }\n        //I keep a count of the total amount of moves. and if the total number of moves is 9, and wincheck returns false. then it has to be a tie.\n        else if (moves == 9)\n        {\n            //Tie\n            DisplayGrid();\n            std::cout << \"\\n [- TIE -] \\n\";\n            GameOver = true;\n            system(\"pause\");\n        }\n    } while (!GameOver);\n    \n    //Clears screen and returns to Main Menu\n    system(\"CLS\");\n    MainMenu();\n}\n\nvoid GamePvE()\n{\n\n    playerIndex = 0;\n    bool GameOver = false;\n    moves = 0;\n    grid = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    char answer = '\u00e6';\n    int computer = -1;\n    int player = -1;\n\n    std::cout << \"Do you want to be X or O? \\n \";\n    std::cout << \"X / O : \";\n    std::cin >> answer;\n    answer = toupper(answer);\n    \n    //This is just to make sure that the input is a Char value.\n    //Initial game setup. The player selects their desigered and the cpu gets \n    if (answer == players[0])\n    {\n        computer = 1;\n        player = 0;\n        std::cout << \"Okay, You = X CPU = O \\n When you are ready \";\n    }\n    else if (answer == players[1])\n    {\n        computer = 0;\n        player = 1;\n        std::cout << \"Okay, CPU = X You = O \\n When you are ready \";\n        \n    }\n    else //This is just to remove the possibility of a rogue exec without the right variables.\n    {\n        std::cin.clear();\n        std::cin.ignore(10000, '\\n');\n        GamePvE();\n        return;\n    }\n\n    system(\"pause\");\n    //This do-while loop goes aslong as GameOver is false.\n    do\n    {\n        DisplayGrid();\n        if (playerIndex == computer)\n        {\n            //this just ends up passing through what character the computer has. \n            //So it can do the right placement in the grid.\n            CalculateComputerMove(players[computer]);\n        }\n        else\n        {\n            InputAndExec();\n        }\n\n        //This is the section of the gameloop that checks for wins or if the game is a tie.\n        int x = WinConditionCheck();\n        if (x == computer)\n        {\n            //The reason for Display Grid is just to update the display so you could see where the\n            //Where the winning connections were!\n            DisplayGrid();\n            std::cout << \"\\n [- CPU WON -] \";\n            GameOver = true;\n            system(\"pause\");\n        }\n        else if (x == player)\n        {\n            DisplayGrid();\n            std::cout << \"\\n [- YOU WON -] \";\n            GameOver = true;\n            system(\"pause\");\n        }\n        else if (moves == 9)\n        {\n            DisplayGrid();\n            std::cout << \"\\n [- TIE -] \\n\";\n            GameOver = true;\n            system(\"pause\");\n        }\n\n    } while (!GameOver);\n\n\n\n    system(\"CLS\");\n    MainMenu();\n}\n\n//Game Loop functions\nvoid DisplayGrid()\n{\n    system(\"CLS\");\n    for (auto x = 0; x < grid.size(); x++)\n    {\n        std::cout << \"| \" << grid.at(x) << \" \";\n        if (x == 2 || x == 5 || x == 8)\n        {\n            std::cout << \"|\" << std::endl;\n        }\n    }\n}\nvoid InputAndExec()\n{\n    //The reason for this being a long long int, is because i kept getting build errors because i was doing a arithmetic overflow warning\n    //So i then \"upgraded\" to this to remove that error.\n    long long int playerInput = 0;\n    std::cout << \"[\" << players[playerIndex] << \"] turn : \";\n    \n    //Gets input from console and store the answer in the playerInput variable\n    \n    std::cin >> playerInput;\n    \n    if (playerInput-1 <= 8 && playerInput-1 >= 0)\n    {\n        if (grid.at(playerInput-1) == 'X' || grid.at(playerInput-1) == 'O')\n        {\n            std::cout << \"Invalid selection, you cannot select a place that has already been taken! \\n\";\n            InputAndExec();\n            return;\n        }\n        else\n        {\n            grid[playerInput-1] = players[playerIndex];\n            moves++;\n            PlayerSwitch();\n            return;\n        }\n    }\n    else // This else is to catch any input that isn't an integer. then repeat.\n    {\n        std::cin.clear();\n        std::cin.ignore(10000, '\\n');\n        std::cout << \"Invalid input! Choose a number from the grid above! \\n\";\n    }\n}\nint WinConditionCheck()\n{\n\n    //Here im just creating a variable that checks for winner, and then returns the player index number...\n    //which corresponds with a char in players[].\n    char winner = '\u00d8';\n    \n    char a, b, c;\n\n    //Horizontal\n    for (long int i = 1; i <= 7; i+=3)\n    {\n        // These variables are temp just for storing values so the if statement further down stays relativly clean and easy to debug.\n        a = grid.at(i);\n        b = grid.at(i-1);\n        c = grid.at(i+1);\n        //What these variables check store is what is in the grid at the spesific point. They only hold that info based on the current iteration.\n\n        //This if statement then checks weather or not they are all the same, it doesn't matter if its X or O. Aslong as all of them are the same...\n        //it then continues to the next check\n        if (a == b && b == c)\n        {\n            //Here we grab the character value of the winning row, then we do a check as to who won. then return a int value.\n            //This int value that is returned, corresponds with the index of the players[], where X = 0, and O = 1. \n            winner = grid.at(i);\n            if (winner == 'X')\n            {\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n    }\n    \n    //Vertical win check\n    for (long int i = 0; i < 3; i++)\n    {\n        //Here i grab a the current iterator and add the required grid locations to make a check. \n        //im just using a, b and c because it really doesn't require to be that spesific. These are temp variables that...\n        //have a single purpose, which is to check weather or not they are the same. \n\n        a = grid.at(i);\n        b = grid.at(i + 3);\n        c = grid.at(i + 6);\n\n        //This if statement just checks that all the temp variables are the same, and by that we can determine that we have a winner.\n        //Since the temp varibles are set to check the one beneath another, this then checks the colum for a win condition.\n        if (a == b && b == c)\n        {\n            //Here we grab the character value of the winning row, then we do a check as to who won. then return a int value.\n            //This int value that is returned, corresponds with the index of the players[], where X = 0, and O = 1. \n            winner = grid.at(i);\n            if (winner == 'X')\n            {\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n    }\n\n    //For the diagonal checks, all i have to do, since there are only two options. i will hardcode those checks. \n    //The reason for that is because of time, i could most likly come up with a clever solution, however it would end up taking way longer..\n    //Than simply writing it out. This is only Tic-Tac-Toe. \n    \n#pragma region DiagonalChecks\n\n    //Diagonal Check 1\n    a = grid.at(2);\n    b = grid.at(4);\n    c = grid.at(6);\n    std::cout << a << b << c;\n\n    if (a == b && b == c)\n    {\n        //Same as before, we grab the variable at a this time, and return the correct index in players[].\n        winner = b;\n        if (winner == 'X')\n        {\n            return 0;\n        }\n        else\n        {\n            return 1;\n        }\n    }\n    //Diagonal Check 2\n    a = grid.at(0);\n    b = grid.at(4);\n    c = grid.at(8);\n    if (a == b && b == c)\n    {\n        //Same as before, we grab the variable at a this time, and return the correct index in players[]. \n        winner = b;\n        if (winner == 'X')\n        {\n            return 0;\n        }\n        else\n        {\n            return 1;\n        }\n    }\n    \n#pragma endregion\n\n\n    return 2;\n}\nvoid PlayerSwitch()\n{\n    //This function just inverts the player index. I think there is a better and prettier way to do this, however this will do for now.\n    //Its not pretty, but i added an easter-egg incase something went horribly wrong! \n    switch (playerIndex)\n    {\n    case 0 : \n        playerIndex = 1;\n        break;\n    case 1 :\n        playerIndex = 0;\n        break;\n    default:\n        std::cout << \"WTF just happened, im just gonna try something\\n\";\n        playerIndex = 0;\n        break;\n    }\n}\nvoid CalculateComputerMove(char CPUchar)\n{\n    //Just initializing a seed(time) for my random number generator.\n    \n    \n    int selected = (rand() % 8 + 1)-1;\n    if (grid.at(selected) == 'X' || grid.at(selected) == 'O')\n    {\n        CalculateComputerMove(CPUchar);\n        return;\n    }\n    else\n    {\n        grid.at(selected) = CPUchar;\n        moves++;\n        PlayerSwitch();\n        return;\n    }\n\n}",
        "blame_info": {
            "hans_olahoftun@hotmail.com": [
                [
                    1,
                    414
                ]
            ]
        }
    },
    {
        "blob_id": "be342d25f24c065b687f2354984709c3205a3034",
        "directory_id": "03c9dcedb5c93f6930fbe274d188199df574e87c",
        "path": "/node_location/code/MultiviewGeometryUtility.cpp",
        "content_id": "bfe4419fde1892cae668b58fc56a44cb6e5a9d18",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "marvinCMU/marvin",
        "snapshot_id": "6b5f6af693746657650a66b78f899fadbb937071",
        "revision_id": "6f6e378f78447d6b8de2e8b97b82e1bc7f3f5cfc",
        "branch_name": "refs/heads/master",
        "visit_date": "2016-09-06 04:51:17",
        "revision_date": "2014-06-17 03:43:45",
        "committer_date": "2014-06-17 03:43:45",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 345280,
        "extension": "cpp",
        "content": "#include \"MultiviewGeometryUtility.h\"\r\n#include <assert.h>\r\n\r\nusing namespace std;\r\n\r\n//void BilinearCameraPoseEstimation(vector<Feature> vFeature, int initialFrame1, int initialFrame2, double ransacThreshold, int ransacMaxIter, CvMat *K, CvMat &P, CvMat &X, vector<int> &visibleStructureID)\r\n//{\r\n//\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n//\tCvMat cx1, cx2, nx1, nx2;\r\n//\tvector<int> visibleFeatureID;\r\n//\tX = *cvCreateMat(vFeature.size(), 3, CV_32FC1);\r\n//\tVisibleIntersection(vFeature, initialFrame1, initialFrame2, cx1, cx2, visibleFeatureID);\r\n//\tassert(visibleFeatureID.size() > 7);\r\n//\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n//\r\n//\tClassifier classifier;\r\n//\tvector<int> visibleID;\r\n//\tclassifier.SetRansacParam(ransacThreshold, ransacMaxIter);\r\n//\tclassifier.SetCorrespondance(&cx1, &cx2, visibleFeatureID);\r\n//\tclassifier.Classify();\r\n//\tvector<int> vInlierID, vOutlierID;\r\n//\tclassifier.GetClassificationResultByFeatureID(vInlierID, vOutlierID);\r\n//\tvisibleFeatureID = vInlierID;\r\n//\tF = cvCloneMat(classifier.F);\r\n//\tcx1 = *cvCreateMat(classifier.inlier1->rows, classifier.inlier1->cols, CV_32FC1);\r\n//\tcx2 = *cvCreateMat(classifier.inlier2->rows, classifier.inlier2->cols, CV_32FC1);\r\n//\tcx1 = *cvCloneMat(classifier.inlier1);\r\n//\tcx2 = *cvCloneMat(classifier.inlier2);\r\n//\r\n//\t//vector<int> vInlierID;\r\n//\t//CvMat *status = cvCreateMat(1,cx1.rows,CV_8UC1);\r\n//\t//int n = cvFindFundamentalMat(&cx1, &cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n//\t//for (int i = 0; i < cx1.rows; i++)\r\n//\t//{\r\n//\t//\tif (cvGetReal2D(status, 0, i) == 1)\r\n//\t//\t{\r\n//\t//\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n//\t//\t}\r\n//\t//}\r\n//\t//visibleFeatureID = vInlierID;\r\n//\t//CvMat *tempCx1 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n//\t//CvMat *tempCx2 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n//\t//int temprow = 0;\r\n//\t//for (int i = 0; i < cx1.rows; i++)\r\n//\t//{\r\n//\t//\tif (cvGetReal2D(status, 0, i) == 1)\r\n//\t//\t{\r\n//\t//\t\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(&cx1, i, 0));\r\n//\t//\t\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(&cx1, i, 1));\r\n//\t//\t\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(&cx2, i, 0));\r\n//\t//\t\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(&cx2, i, 1));\r\n//\t//\t\ttemprow++;\r\n//\t//\t}\r\n//\t//}\r\n//\t//cx1 = *cvCreateMat(tempCx1->rows, tempCx1->cols, CV_32FC1);\r\n//\t//cx2 = *cvCreateMat(tempCx2->rows, tempCx2->cols, CV_32FC1);\r\n//\t//cx1 = *cvCloneMat(tempCx1);\r\n//\t//cx2 = *cvCloneMat(tempCx2);\r\n//\t//cvReleaseMat(&status);\r\n//\t//cvReleaseMat(&tempCx1);\r\n//\t//cvReleaseMat(&tempCx2);\r\n//\r\n//\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n//\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n//\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n//\r\n//\tcvTranspose(K, temp33);\r\n//\tcvMatMul(temp33, F, temp33);\r\n//\tcvMatMul(temp33, K, E);\r\n//\r\n//\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(K, invK);\r\n//\tPxx_inhomo(invK, &cx1, nx1);\r\n//\tPxx_inhomo(invK, &cx2, nx2);\r\n//\r\n//\tGetExtrinsicParameterFromE(E, &nx1, &nx2, P);\r\n//\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n//\tcvSetIdentity(P0);\r\n//\tCvMat cX;\r\n//\r\n//\tLinearTriangulation(&nx1, P0, &nx2, &P, cX);\r\n//\tcvSetZero(&X);\r\n//\tSetIndexedMatRowwise(&X, visibleFeatureID, &cX);\r\n//\tcvMatMul(K, &P, temp34);\r\n//\tP = *cvCloneMat(temp34);\r\n//\r\n//\tvisibleStructureID = visibleFeatureID;\r\n//\r\n//\tcvReleaseMat(&F);\r\n//\tcvReleaseMat(&E);\r\n//\tcvReleaseMat(&temp33);\r\n//\tcvReleaseMat(&temp34);\r\n//\tcvReleaseMat(&invK);\r\n//\tcvReleaseMat(&P0);\t\r\n//}\r\n\r\nvoid BilinearCameraPoseEstimation_OPENCV(vector<Feature> vFeature, int initialFrame1, int initialFrame2, double ransacThreshold, int ransacMaxIter, CvMat *K, CvMat &P, CvMat &X, vector<int> &visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tCvMat cx1, cx2, nx1, nx2;\r\n\tvector<int> visibleFeatureID;\r\n\tX = *cvCreateMat(vFeature.size(), 3, CV_32FC1);\r\n\tVisibleIntersection(vFeature, initialFrame1, initialFrame2, cx1, cx2, visibleFeatureID);\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\t//Classifier classifier;\r\n\t//vector<int> visibleID;\r\n\t//classifier.SetRansacParam(ransacThreshold, ransacMaxIter);\r\n\t//classifier.SetCorrespondance(&cx1, &cx2, visibleFeatureID);\r\n\t//classifier.Classify();\r\n\t//vector<int> vInlierID, vOutlierID;\r\n\t//classifier.GetClassificationResultByFeatureID(vInlierID, vOutlierID);\r\n\t//visibleFeatureID = vInlierID;\r\n\t//F = cvCloneMat(classifier.F);\r\n\t//cx1 = *cvCreateMat(classifier.inlier1->rows, classifier.inlier1->cols, CV_32FC1);\r\n\t//cx2 = *cvCreateMat(classifier.inlier2->rows, classifier.inlier2->cols, CV_32FC1);\r\n\t//cx1 = *cvCloneMat(classifier.inlier1);\r\n\t//cx2 = *cvCloneMat(classifier.inlier2);\r\n\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1.rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(&cx1, &cx2, F, CV_FM_RANSAC , 1, 0.99, status);\r\n\tfor (int i = 0; i < cx1.rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t}\r\n\t}\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tint temprow = 0;\r\n\tfor (int i = 0; i < cx1.rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(&cx1, i, 0));\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(&cx1, i, 1));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(&cx2, i, 0));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(&cx2, i, 1));\r\n\t\t\ttemprow++;\r\n\t\t}\r\n\t}\r\n\tcx1 = *cvCreateMat(tempCx1->rows, tempCx1->cols, CV_32FC1);\r\n\tcx2 = *cvCreateMat(tempCx2->rows, tempCx2->cols, CV_32FC1);\r\n\tcx1 = *cvCloneMat(tempCx1);\r\n\tcx2 = *cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\r\n\tcvTranspose(K, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K, E);\r\n\r\n\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K, invK);\r\n\tPxx_inhomo(invK, &cx1, nx1);\r\n\tPxx_inhomo(invK, &cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, &nx1, &nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\tCvMat cX;\r\n\r\n\tLinearTriangulation(&nx1, P0, &nx2, &P, cX);\r\n\tcvSetZero(&X);\r\n\tSetIndexedMatRowwise(&X, visibleFeatureID, &cX);\r\n\tcvMatMul(K, &P, temp34);\r\n\tP = *cvCloneMat(temp34);\r\n\r\n\tvisibleStructureID = visibleFeatureID;\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&invK);\r\n\tcvReleaseMat(&P0);\t\r\n}\r\n\r\nint BilinearCameraPoseEstimation_OPENCV(vector<Feature> vFeature, int initialFrame1, int initialFrame2, int max_nFrames, vector<Camera> vCamera, CvMat &P, CvMat &X, vector<int> &visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tCvMat cx1, cx2, nx1, nx2;\r\n\tvector<int> visibleFeatureID;\r\n\tX = *cvCreateMat(vFeature.size(), 3, CV_32FC1);\r\n\tVisibleIntersection(vFeature, initialFrame1, initialFrame2, cx1, cx2, visibleFeatureID);\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1.rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(&cx1, &cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n\t//int n = cvFindFundamentalMat(&cx1, &cx2, F, CV_FM_8POINT  , 3, 0.99, status);\r\n\tPrintMat(F, \"Fundamental Matrix\");\r\n\tfor (int i = 0; i < cx1.rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t}\r\n\t}\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tint temprow = 0;\r\n\tfor (int i = 0; i < cx1.rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(&cx1, i, 0));\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(&cx1, i, 1));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(&cx2, i, 0));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(&cx2, i, 1));\r\n\t\t\ttemprow++;\r\n\t\t}\r\n\t}\r\n\tcx1 = *cvCreateMat(tempCx1->rows, tempCx1->cols, CV_32FC1);\r\n\tcx2 = *cvCreateMat(tempCx2->rows, tempCx2->cols, CV_32FC1);\r\n\tcx1 = *cvCloneMat(tempCx1);\r\n\tcx2 = *cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tK1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tK2 = cvCloneMat(vCamera[camera2].vK[idx2]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tPxx_inhomo(invK1, &cx1, nx1);\r\n\tPxx_inhomo(invK2, &cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, &nx1, &nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\tCvMat cX;\r\n\r\n\tLinearTriangulation(&nx1, P0, &nx2, &P, cX);\r\n\tcvSetZero(&X);\r\n\tSetIndexedMatRowwise(&X, visibleFeatureID, &cX);\r\n\tcvMatMul(K2, &P, temp34);\r\n\tP = *cvCloneMat(temp34);\r\n\r\n\tvisibleStructureID = visibleFeatureID;\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n\treturn n;\r\n}\r\n\r\nvoid SetCvMatFromVectors(vector<vector<double> > x, CvMat *X)\r\n{\r\n\tfor (int i = 0; i < x.size(); i++)\r\n\t{\r\n\t\tfor (int j = 0; j < x[i].size(); j++)\r\n\t\t\tcvSetReal2D(X, i, j, x[i][j]);\r\n\t}\r\n}\r\n\r\nint BilinearCameraPoseEstimation_OPENCV_mem(vector<Feature> &vFeature, int initialFrame1, int initialFrame2, int max_nFrames, vector<Camera> vCamera, CvMat *P, CvMat *X, vector<int> &visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tvector<int> visibleFeatureID;\r\n\tvector<vector<double> > cx1_vec, cx2_vec, nx1_vec, nx2_vec;\r\n\r\n\tVisibleIntersection_mem(vFeature, initialFrame1, initialFrame2, cx1_vec, cx2_vec, visibleFeatureID);\r\n\tCvMat *cx1 = cvCreateMat(cx1_vec.size(), 2, CV_32FC1);\r\n\tCvMat *cx2 = cvCreateMat(cx2_vec.size(), 2, CV_32FC1);\r\n\tSetCvMatFromVectors(cx1_vec, cx1);\r\n\tSetCvMatFromVectors(cx2_vec, cx2);\r\n\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1->rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(cx1, cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n\tPrintMat(F, \"Fundamental Matrix\");\r\n\tfor (int i = 0; i < cx1->rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t}\r\n\t}\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vInlierID.size(), 2, CV_32FC1);\r\n\tint temprow = 0;\r\n\tfor (int i = 0; i < cx1->rows; i++)\r\n\t{\r\n\t\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t\t{\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(cx1, i, 0));\r\n\t\t\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(cx1, i, 1));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(cx2, i, 0));\r\n\t\t\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(cx2, i, 1));\r\n\t\t\ttemprow++;\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcx1 = cvCloneMat(tempCx1);\r\n\tcx2 = cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\t//CvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tCvMat *K1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tCvMat *K2 = cvCloneMat(vCamera[camera2].vK[idx2]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tCvMat *nx1 = cvCreateMat(cx1->rows, cx1->cols, CV_32FC1);\r\n\tCvMat *nx2 = cvCreateMat(cx2->rows, cx2->cols, CV_32FC1);\r\n\tPxx_inhomo(invK1, cx1, nx1);\r\n\tPxx_inhomo(invK2, cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, nx1, nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\tCvMat *cX = cvCreateMat(nx1->rows, 3, CV_32FC1);\r\n\r\n\tLinearTriangulation(nx1, P0, nx2, P, cX);\r\n\tcvSetZero(X);\r\n\tSetIndexedMatRowwise(X, visibleFeatureID, cX);\r\n\tcvMatMul(K2, P, temp34);\r\n\tSetSubMat(P, 0, 0, temp34);\r\n\r\n\tvisibleStructureID = visibleFeatureID;\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcvReleaseMat(&nx1);\r\n\tcvReleaseMat(&nx2);\r\n\tcvReleaseMat(&cX);\r\n\treturn n;\r\n}\r\n\r\nint BilinearCameraPoseEstimation_OPENCV_mem_fast(vector<Feature> &vFeature, int initialFrame1, int initialFrame2, int max_nFrames, vector<Camera> vCamera, CvMat *P, CvMat *X)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tvector<int> visibleFeatureID;\r\n\tvector<vector<double> > cx1_vec, cx2_vec, nx1_vec, nx2_vec;\r\n\r\n\tVisibleIntersection_mem(vFeature, initialFrame1, initialFrame2, cx1_vec, cx2_vec, visibleFeatureID);\r\n\tCvMat *cx1 = cvCreateMat(cx1_vec.size(), 2, CV_32FC1);\r\n\tCvMat *cx2 = cvCreateMat(cx2_vec.size(), 2, CV_32FC1);\r\n\tSetCvMatFromVectors(cx1_vec, cx1);\r\n\tSetCvMatFromVectors(cx2_vec, cx2);\r\n\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1->rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(cx1, cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n\tPrintMat(F, \"Fundamental Matrix\");\r\n\t//for (int i = 0; i < cx1->rows; i++)\r\n\t//{\r\n\t//\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t//\t{\r\n\t//\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t//\t}\r\n\t//}\r\n\r\n\tcout << n << endl;\r\n\r\n\tvector<int> vCX_indx;\r\n\tfor (int i = 0; i < cx1->rows; i++)\r\n\t{\r\n\t\tCvMat *xM2 = cvCreateMat(1,3,CV_32FC1);\r\n\t\tCvMat *xM1 = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *s = cvCreateMat(1,1, CV_32FC1);\r\n\t\tcvSetReal2D(xM2, 0, 0, cvGetReal2D(cx2, i, 0));\r\n\t\tcvSetReal2D(xM2, 0, 1, cvGetReal2D(cx2, i, 1));\r\n\t\tcvSetReal2D(xM2, 0, 2, 1);\r\n\t\tcvSetReal2D(xM1, 0, 0, cvGetReal2D(cx1, i, 0));\r\n\t\tcvSetReal2D(xM1, 1, 0, cvGetReal2D(cx1, i, 1));\r\n\t\tcvSetReal2D(xM1, 2, 0, 1);\r\n\t\tcvMatMul(xM2, F, xM2);\r\n\t\tcvMatMul(xM2, xM1, s);\t\t\t\r\n\r\n\t\tdouble l1 = cvGetReal2D(xM2, 0, 0);\r\n\t\tdouble l2 = cvGetReal2D(xM2, 0, 1);\r\n\t\tdouble l3 = cvGetReal2D(xM2, 0, 2);\r\n\r\n\t\tdouble dist = abs(cvGetReal2D(s, 0, 0))/sqrt(l1*l1+l2*l2);\r\n\r\n\t\tif (dist < 5)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t\tvCX_indx.push_back(i);\r\n\t\t}\r\n\r\n\t\tcvReleaseMat(&xM2);\r\n\t\tcvReleaseMat(&xM1);\r\n\t\tcvReleaseMat(&s);\r\n\t\t//if (cvGetReal2D(status, 0, i) == 1)\r\n\t\t//{\r\n\t\t//\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(cx1, i, 0));\r\n\t\t//\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(cx1, i, 1));\r\n\t\t//\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(cx2, i, 0));\r\n\t\t//\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(cx2, i, 1));\r\n\t\t//\ttemprow++;\r\n\t\t//}\r\n\t}\r\n\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierID.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(tempCx1, iInlier, 0, cvGetReal2D(cx1, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx1, iInlier, 1, cvGetReal2D(cx1, vCX_indx[iInlier], 1));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 0, cvGetReal2D(cx2, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 1, cvGetReal2D(cx2, vCX_indx[iInlier], 1));\r\n\t}\r\n\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcx1 = cvCloneMat(tempCx1);\r\n\tcx2 = cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\t//CvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tCvMat *K1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tCvMat *K2 = cvCloneMat(vCamera[camera2].vK[idx2]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tCvMat *nx1 = cvCreateMat(cx1->rows, cx1->cols, CV_32FC1);\r\n\tCvMat *nx2 = cvCreateMat(cx2->rows, cx2->cols, CV_32FC1);\r\n\tPxx_inhomo(invK1, cx1, nx1);\r\n\tPxx_inhomo(invK2, cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, nx1, nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\t\r\n\tCvMat *cX = cvCreateMat(nx1->rows, 3, CV_32FC1);\r\n\r\n\tPrintMat(P);\r\n\tcvMatMul(K1, P0, P0);\r\n\tcvMatMul(K2, P, P);\r\n\r\n\tPrintMat(P);\r\n\t//LinearTriangulation(nx1, P0, nx2, P, cX);\r\n\tLinearTriangulation(cx1, P0, cx2, P, cX);\r\n\t//PrintMat(cX);\r\n\tcvSetZero(X);\r\n\tSetIndexedMatRowwise(X, visibleFeatureID, cX);\r\n\r\n\t\r\n\tfor (int i = 0; i < visibleFeatureID.size(); i++)\r\n\t{\r\n\t\tvFeature[visibleFeatureID[i]].isRegistered = true;\r\n\t}\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcvReleaseMat(&nx1);\r\n\tcvReleaseMat(&nx2);\r\n\tcvReleaseMat(&cX);\r\n\treturn vInlierID.size();\r\n}\r\n\r\nint BilinearCameraPoseEstimation_OPENCV_mem_fast_AD(vector<Feature> &vFeature, int initialFrame1, int initialFrame2, int max_nFrames, vector<Camera> vCamera, CvMat *P, CvMat *X, vector<vector<int> > &vvPointIndex)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tvector<int> visibleFeatureID;\r\n\tvector<vector<double> > cx1_vec, cx2_vec, nx1_vec, nx2_vec;\r\n\r\n\tVisibleIntersection_mem(vFeature, initialFrame1, initialFrame2, cx1_vec, cx2_vec, visibleFeatureID);\r\n\tCvMat *cx1 = cvCreateMat(cx1_vec.size(), 2, CV_32FC1);\r\n\tCvMat *cx2 = cvCreateMat(cx2_vec.size(), 2, CV_32FC1);\r\n\tSetCvMatFromVectors(cx1_vec, cx1);\r\n\tSetCvMatFromVectors(cx2_vec, cx2);\r\n\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1->rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(cx1, cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n\tPrintMat(F, \"Fundamental Matrix\");\r\n\t//for (int i = 0; i < cx1->rows; i++)\r\n\t//{\r\n\t//\tif (cvGetReal2D(status, 0, i) == 1)\r\n\t//\t{\r\n\t//\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t//\t}\r\n\t//}\r\n\r\n\tcout << n << endl;\r\n\r\n\tvector<int> vCX_indx;\r\n\tfor (int i = 0; i < cx1->rows; i++)\r\n\t{\r\n\t\tCvMat *xM2 = cvCreateMat(1,3,CV_32FC1);\r\n\t\tCvMat *xM1 = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *s = cvCreateMat(1,1, CV_32FC1);\r\n\t\tcvSetReal2D(xM2, 0, 0, cvGetReal2D(cx2, i, 0));\r\n\t\tcvSetReal2D(xM2, 0, 1, cvGetReal2D(cx2, i, 1));\r\n\t\tcvSetReal2D(xM2, 0, 2, 1);\r\n\t\tcvSetReal2D(xM1, 0, 0, cvGetReal2D(cx1, i, 0));\r\n\t\tcvSetReal2D(xM1, 1, 0, cvGetReal2D(cx1, i, 1));\r\n\t\tcvSetReal2D(xM1, 2, 0, 1);\r\n\t\tcvMatMul(xM2, F, xM2);\r\n\t\tcvMatMul(xM2, xM1, s);\t\t\t\r\n\r\n\t\tdouble l1 = cvGetReal2D(xM2, 0, 0);\r\n\t\tdouble l2 = cvGetReal2D(xM2, 0, 1);\r\n\t\tdouble l3 = cvGetReal2D(xM2, 0, 2);\r\n\r\n\t\tdouble dist = abs(cvGetReal2D(s, 0, 0))/sqrt(l1*l1+l2*l2);\r\n\r\n\t\tif (dist < 5)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t\tvCX_indx.push_back(i);\r\n\t\t}\r\n\r\n\t\tcvReleaseMat(&xM2);\r\n\t\tcvReleaseMat(&xM1);\r\n\t\tcvReleaseMat(&s);\r\n\t\t//if (cvGetReal2D(status, 0, i) == 1)\r\n\t\t//{\r\n\t\t//\tcvSetReal2D(tempCx1, temprow, 0, cvGetReal2D(cx1, i, 0));\r\n\t\t//\tcvSetReal2D(tempCx1, temprow, 1, cvGetReal2D(cx1, i, 1));\r\n\t\t//\tcvSetReal2D(tempCx2, temprow, 0, cvGetReal2D(cx2, i, 0));\r\n\t\t//\tcvSetReal2D(tempCx2, temprow, 1, cvGetReal2D(cx2, i, 1));\r\n\t\t//\ttemprow++;\r\n\t\t//}\r\n\t}\r\n\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierID.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(tempCx1, iInlier, 0, cvGetReal2D(cx1, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx1, iInlier, 1, cvGetReal2D(cx1, vCX_indx[iInlier], 1));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 0, cvGetReal2D(cx2, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 1, cvGetReal2D(cx2, vCX_indx[iInlier], 1));\r\n\t}\r\n\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcx1 = cvCloneMat(tempCx1);\r\n\tcx2 = cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\t//CvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tCvMat *K1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tCvMat *K2 = cvCloneMat(vCamera[camera2].vK[idx2]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tCvMat *nx1 = cvCreateMat(cx1->rows, cx1->cols, CV_32FC1);\r\n\tCvMat *nx2 = cvCreateMat(cx2->rows, cx2->cols, CV_32FC1);\r\n\tPxx_inhomo(invK1, cx1, nx1);\r\n\tPxx_inhomo(invK2, cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, nx1, nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\t\r\n\tCvMat *cX = cvCreateMat(nx1->rows, 3, CV_32FC1);\r\n\r\n\tPrintMat(P);\r\n\tcvMatMul(K1, P0, P0);\r\n\tcvMatMul(K2, P, P);\r\n\r\n\tPrintMat(P);\r\n\t//LinearTriangulation(nx1, P0, nx2, P, cX);\r\n\tLinearTriangulation(cx1, P0, cx2, P, cX);\r\n\t//PrintMat(cX);\r\n\tcvSetZero(X);\r\n\tSetIndexedMatRowwise(X, visibleFeatureID, cX);\r\n\tvvPointIndex.push_back(visibleFeatureID);\r\n\tvvPointIndex.push_back(visibleFeatureID);\r\n\t\r\n\tfor (int i = 0; i < visibleFeatureID.size(); i++)\r\n\t{\r\n\t\tvFeature[visibleFeatureID[i]].isRegistered = true;\r\n\t}\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcvReleaseMat(&nx1);\r\n\tcvReleaseMat(&nx2);\r\n\tcvReleaseMat(&cX);\r\n\treturn vInlierID.size();\r\n}\r\n\r\nint BilinearCameraPoseEstimation_OPENCV_OrientationRefinement(vector<Feature> &vFeature, int initialFrame1, int initialFrame2, int max_nFrames, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  vector<Camera> vCamera, CvMat *M, CvMat *m, vector<int> &vVisibleID)\r\n{\r\n\t//PrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tvector<int> visibleFeatureID;\r\n\tvector<vector<double> > cx1_vec, cx2_vec, nx1_vec, nx2_vec;\r\n\r\n\tVisibleIntersection_mem(vFeature, initialFrame1, initialFrame2, cx1_vec, cx2_vec, visibleFeatureID);\r\n\tif (visibleFeatureID.size() < 40)\r\n\t\treturn 0;\r\n\tCvMat *cx1 = cvCreateMat(cx1_vec.size(), 2, CV_32FC1);\r\n\tCvMat *cx2 = cvCreateMat(cx2_vec.size(), 2, CV_32FC1);\r\n\tSetCvMatFromVectors(cx1_vec, cx1);\r\n\tSetCvMatFromVectors(cx2_vec, cx2);\r\n\r\n\tif (visibleFeatureID.size() < 8)\r\n\t{\r\n\t\treturn visibleFeatureID.size();\r\n\t}\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tvector<int> vInlierID;\r\n\tCvMat *status = cvCreateMat(1,cx1->rows,CV_8UC1);\r\n\tint n = cvFindFundamentalMat(cx1, cx2, F, CV_FM_LMEDS , 1, 0.99, status);\r\n\r\n\t//cout << n << endl;\r\n\r\n\tvector<int> vCX_indx;\r\n\tfor (int i = 0; i < cx1->rows; i++)\r\n\t{\r\n\t\tCvMat *xM2 = cvCreateMat(1,3,CV_32FC1);\r\n\t\tCvMat *xM1 = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *s = cvCreateMat(1,1, CV_32FC1);\r\n\t\tcvSetReal2D(xM2, 0, 0, cvGetReal2D(cx2, i, 0));\r\n\t\tcvSetReal2D(xM2, 0, 1, cvGetReal2D(cx2, i, 1));\r\n\t\tcvSetReal2D(xM2, 0, 2, 1);\r\n\t\tcvSetReal2D(xM1, 0, 0, cvGetReal2D(cx1, i, 0));\r\n\t\tcvSetReal2D(xM1, 1, 0, cvGetReal2D(cx1, i, 1));\r\n\t\tcvSetReal2D(xM1, 2, 0, 1);\r\n\t\tcvMatMul(xM2, F, xM2);\r\n\t\tcvMatMul(xM2, xM1, s);\t\t\t\r\n\r\n\t\tdouble l1 = cvGetReal2D(xM2, 0, 0);\r\n\t\tdouble l2 = cvGetReal2D(xM2, 0, 1);\r\n\t\tdouble l3 = cvGetReal2D(xM2, 0, 2);\r\n\r\n\t\tdouble dist = abs(cvGetReal2D(s, 0, 0))/sqrt(l1*l1+l2*l2);\r\n\r\n\t\tif (dist < 5)\r\n\t\t{\r\n\t\t\tvInlierID.push_back(visibleFeatureID[i]);\r\n\t\t\tvCX_indx.push_back(i);\r\n\t\t}\r\n\r\n\t\tcvReleaseMat(&xM2);\r\n\t\tcvReleaseMat(&xM1);\r\n\t\tcvReleaseMat(&s);\r\n\t}\r\n\r\n\tvisibleFeatureID = vInlierID;\r\n\tCvMat *tempCx1 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tCvMat *tempCx2 = cvCreateMat(vCX_indx.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierID.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(tempCx1, iInlier, 0, cvGetReal2D(cx1, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx1, iInlier, 1, cvGetReal2D(cx1, vCX_indx[iInlier], 1));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 0, cvGetReal2D(cx2, vCX_indx[iInlier], 0));\r\n\t\tcvSetReal2D(tempCx2, iInlier, 1, cvGetReal2D(cx2, vCX_indx[iInlier], 1));\r\n\t}\r\n\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcx1 = cvCloneMat(tempCx1);\r\n\tcx2 = cvCloneMat(tempCx2);\r\n\tcvReleaseMat(&status);\r\n\tcvReleaseMat(&tempCx1);\r\n\tcvReleaseMat(&tempCx2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\t//CvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tCvMat *K1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tCvMat *K2 = cvCloneMat(vCamera[camera2].vK[idx2]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tCvMat *nx1 = cvCreateMat(cx1->rows, cx1->cols, CV_32FC1);\r\n\tCvMat *nx2 = cvCreateMat(cx2->rows, cx2->cols, CV_32FC1);\r\n\tPxx_inhomo(invK1, cx1, nx1);\r\n\tPxx_inhomo(invK2, cx2, nx2);\r\n\r\n\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\tGetExtrinsicParameterFromE(E, nx1, nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\t\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(M, i, j, cvGetReal2D(P, i, j));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tcvSetReal2D(m, i, 0, cvGetReal2D(P, i, 3));\r\n\t}\r\n\t\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n\tcvReleaseMat(&cx1);\r\n\tcvReleaseMat(&cx2);\r\n\tcvReleaseMat(&nx1);\r\n\tcvReleaseMat(&nx2);\r\n\tcvReleaseMat(&P);\r\n\tvVisibleID = vInlierID;\r\n\treturn vInlierID.size();\r\n}\r\n\r\nvoid BilinearCameraPoseEstimation(vector<Feature> vFeature, int initialFrame1, int initialFrame2, double ransacThreshold, int ransacMaxIter, int max_nFrames, vector<Camera> vCamera, CvMat &P, CvMat &X, vector<int> &visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Bilinear Camera Pose Estimation\");\r\n\tCvMat cx1, cx2, nx1, nx2;\r\n\tvector<int> visibleFeatureID;\r\n\tX = *cvCreateMat(vFeature.size(), 3, CV_32FC1);\r\n\tVisibleIntersection(vFeature, initialFrame1, initialFrame2, cx1, cx2, visibleFeatureID);\r\n\tcout << \"Visible intersection between 2 and 3: \" << visibleFeatureID.size() << endl;\r\n\tassert(visibleFeatureID.size() > 7);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tEightPointAlgorithm(&cx1, &cx2, F);\r\n\tScalarMul(F, 1/cvGetReal2D(F, 2,2), F);\r\n\tPrintMat(F, \"Fundamental Matrix\");\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t//Classifier classifier;\r\n\t//vector<int> visibleID;\r\n\t//classifier.SetRansacParam(ransacThreshold, ransacMaxIter);\r\n\t//classifier.SetCorrespondance(&cx1, &cx2, visibleFeatureID);\r\n\t//classifier.Classify();\r\n\t//vector<int> vInlierID, vOutlierID;\r\n\t//classifier.GetClassificationResultByFeatureID(vInlierID, vOutlierID);\r\n\t//visibleFeatureID = vInlierID;\r\n\t//F = cvCloneMat(classifier.F);\r\n\t//double F33 = cvGetReal2D(F, 2,2);\r\n\t//ScalarMul(F, 1/F33, F);\r\n\t//PrintMat(F, \"Fundamental Matrix\");\r\n\t//cx1 = *cvCreateMat(classifier.inlier1->rows, classifier.inlier1->cols, CV_32FC1);\r\n\t//cx2 = *cvCreateMat(classifier.inlier2->rows, classifier.inlier2->cols, CV_32FC1);\r\n\t//cx1 = *cvCloneMat(classifier.inlier1);\r\n\t//cx2 = *cvCloneMat(classifier.inlier2);\r\n\r\n\tCvMat *E = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *K1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *K2 = cvCreateMat(3,3,CV_32FC1);\r\n\tint camera1 = (int)((double)initialFrame1/max_nFrames);\r\n\tint camera2 = (int)((double)initialFrame2/max_nFrames);\r\n\tvector<int> ::const_iterator it1 = find(vCamera[camera1].vTakenFrame.begin(), vCamera[camera1].vTakenFrame.end(), initialFrame1%max_nFrames);\r\n\tvector<int> ::const_iterator it2 = find(vCamera[camera2].vTakenFrame.begin(), vCamera[camera2].vTakenFrame.end(), initialFrame2%max_nFrames);\r\n\tint idx1 = (int) (it1 - vCamera[camera1].vTakenFrame.begin());\r\n\tint idx2 = (int) (it2 - vCamera[camera2].vTakenFrame.begin());\r\n\tK1 = cvCloneMat(vCamera[camera1].vK[idx1]);\r\n\tK2 = cvCloneMat(vCamera[camera2].vK[idx1]);\r\n\r\n\tcvTranspose(K2, temp33);\r\n\tcvMatMul(temp33, F, temp33);\r\n\tcvMatMul(temp33, K1, E);\r\n\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K1, invK1);\r\n\tcvInvert(K2, invK2);\r\n\tPxx_inhomo(invK1, &cx1, nx1);\r\n\tPxx_inhomo(invK2, &cx2, nx2);\r\n\r\n\tGetExtrinsicParameterFromE(E, &nx1, &nx2, P);\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\tCvMat cX;\r\n\r\n\tLinearTriangulation(&nx1, P0, &nx2, &P, cX);\r\n\tcvSetZero(&X);\r\n\tSetIndexedMatRowwise(&X, visibleFeatureID, &cX);\r\n\tcvMatMul(K2, &P, temp34);\r\n\tP = *cvCloneMat(temp34);\r\n\r\n\tvisibleStructureID = visibleFeatureID;\r\n\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&E);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&K1);\r\n\tcvReleaseMat(&K2);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&P0);\t\r\n}\r\n\r\nvoid EightPointAlgorithm(CvMat *x1_8, CvMat *x2_8, CvMat *F_8)\r\n{\r\n\tCvMat *A = cvCreateMat(x1_8->rows, 9, CV_32FC1);\r\n\tCvMat *U = cvCreateMat(x1_8->rows, x1_8->rows, CV_32FC1);\r\n\tCvMat *D = cvCreateMat(x1_8->rows, 9, CV_32FC1);\r\n\tCvMat *V = cvCreateMat(9, 9, CV_32FC1);\r\n\tfor (int iIdx = 0; iIdx < x1_8->rows; iIdx++)\r\n\t{\r\n\t\tdouble x11 = cvGetReal2D(x1_8, iIdx, 0);\r\n\t\tdouble x12 = cvGetReal2D(x1_8, iIdx, 1);\r\n\t\tdouble x21 = cvGetReal2D(x2_8, iIdx, 0);\r\n\t\tdouble x22 = cvGetReal2D(x2_8, iIdx, 1);\r\n\t\tcvSetReal2D(A, iIdx, 0, x21*x11);\r\n\t\tcvSetReal2D(A, iIdx, 1, x21*x12);\r\n\t\tcvSetReal2D(A, iIdx, 2, x21);\r\n\t\tcvSetReal2D(A, iIdx, 3, x22*x11);\r\n\t\tcvSetReal2D(A, iIdx, 4, x22*x12);\r\n\t\tcvSetReal2D(A, iIdx, 5, x22);\r\n\t\tcvSetReal2D(A, iIdx, 6, x11);\r\n\t\tcvSetReal2D(A, iIdx, 7, x12);\r\n\t\tcvSetReal2D(A, iIdx, 8, 1);\r\n\t}\r\n\r\n\tcvSVD(A, D, U, V, 0);\r\n\tcvSetReal2D(F_8, 0, 0, cvGetReal2D(V, 0, 8));\tcvSetReal2D(F_8, 0, 1, cvGetReal2D(V, 1, 8));\tcvSetReal2D(F_8, 0, 2, cvGetReal2D(V, 2, 8));\r\n\tcvSetReal2D(F_8, 1, 0, cvGetReal2D(V, 3, 8));\tcvSetReal2D(F_8, 1, 1, cvGetReal2D(V, 4, 8));\tcvSetReal2D(F_8, 1, 2, cvGetReal2D(V, 5, 8));\r\n\tcvSetReal2D(F_8, 2, 0, cvGetReal2D(V, 6, 8));\tcvSetReal2D(F_8, 2, 1, cvGetReal2D(V, 7, 8));\tcvSetReal2D(F_8, 2, 2, cvGetReal2D(V, 8, 8));\r\n\r\n\tCvMat *UD, *Vt;\r\n\tU = cvCreateMat(3, 3, CV_32FC1);\r\n\tD = cvCreateMat(3, 3, CV_32FC1);\r\n\tV = cvCreateMat(3, 3, CV_32FC1);\r\n\tUD = cvCreateMat(U->rows, D->cols, CV_32FC1);\r\n\tVt = cvCreateMat(V->cols, V->rows, CV_32FC1);\r\n\r\n\tcvSVD(F_8, D, U, V, 0);\r\n\tcvSetReal2D(D, 2, 2, 0);\r\n\r\n\tcvMatMul(U, D, UD);\r\n\tcvTranspose(V, Vt);\r\n\tcvMatMul(UD, Vt, F_8);\r\n\r\n\tcvReleaseMat(&UD);\r\n\tcvReleaseMat(&Vt);\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&U);\r\n\tcvReleaseMat(&D);\r\n\tcvReleaseMat(&V);\r\n}\r\n\r\n\r\n\r\n\r\nvoid VisibleIntersection(vector<Feature> vFeature, int frame1, int frame2, CvMat &cx1, CvMat &cx2, vector<int> &visibleFeatureID)\r\n{\r\n\tvector<double> x1, y1, x2, y2;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()))\r\n\t\t{\r\n\t\t\tint idx = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx1.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\ty1.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\tidx = int(it2-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx2.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\ty2.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\tvisibleFeatureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tcout << \"# intersection: \" << visibleFeatureID.size() << endl;\r\n\tcx1 = *cvCreateMat(x1.size(), 2, CV_32FC1);\r\n\tcx2 = *cvCreateMat(x1.size(), 2, CV_32FC1);\r\n\tfor (int i = 0; i < x1.size(); i++)\r\n\t{\r\n\t\tcvSetReal2D(&cx1, i, 0, x1[i]);\t\tcvSetReal2D(&cx1, i, 1, y1[i]);\r\n\t\tcvSetReal2D(&cx2, i, 0, x2[i]);\t\tcvSetReal2D(&cx2, i, 1, y2[i]);\r\n\t}\r\n}\r\n\r\nvoid VisibleIntersection_mem(vector<Feature> &vFeature, int frame1, int frame2, vector<vector<double> > &cx1, vector<vector<double> > &cx2, vector<int> &visibleFeatureID)\r\n{\r\n\tvector<double> x1, y1, x2, y2;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()))\r\n\t\t{\r\n\t\t\tint idx = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx1.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\ty1.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\tidx = int(it2-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx2.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\ty2.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\tvisibleFeatureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\t//cout << \"# intersection: \" << visibleFeatureID.size() << endl;\r\n\tfor (int i = 0; i < x1.size(); i++)\r\n\t{\r\n\t\tvector<double> x1_vec, x2_vec;\r\n\t\tx1_vec.push_back(x1[i]);\r\n\t\tx1_vec.push_back(y1[i]);\r\n\r\n\t\tx2_vec.push_back(x2[i]);\r\n\t\tx2_vec.push_back(y2[i]);\r\n\r\n\t\tcx1.push_back(x1_vec);\r\n\t\tcx2.push_back(x2_vec);\r\n\t}\r\n}\r\n\r\nvoid VisibleIntersection_Simple(vector<Feature> vFeature, int frame1, int frame2, vector<int> &visibleFeatureID)\r\n{\r\n\tvector<double> x1, y1, x2, y2;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()))\r\n\t\t{\r\n\t\t\tvisibleFeatureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint VisibleIntersection23(vector<Feature> vFeature, int frame1, CvMat *X, vector<int> visibleStructureID, CvMat &cx, CvMat &cX, vector<int> &visibleID)\r\n{\r\n\tvector<double> x_, y_, X_, Y_, Z_;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != visibleStructureID.end()))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tint idx2 = int(it2-visibleStructureID.begin());\r\n\t\t\tx_.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\t\ty_.push_back(vFeature[iFeature].vy[idx1]);\r\n\t\t\tX_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 0));\r\n\t\t\tY_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 1));\r\n\t\t\tZ_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 2));\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tif (x_.size() < 1)\r\n\t\treturn 0;\r\n\tcx = *cvCreateMat(x_.size(), 2, CV_32FC1);\r\n\tcX = *cvCreateMat(x_.size(), 3, CV_32FC1);\r\n\tfor (int i = 0; i < x_.size(); i++)\r\n\t{\r\n\t\tcvSetReal2D(&cx, i, 0, x_[i]);\t\tcvSetReal2D(&cx, i, 1, y_[i]);\r\n\t\tcvSetReal2D(&cX, i, 0, X_[i]);\t\tcvSetReal2D(&cX, i, 1, Y_[i]);\t\tcvSetReal2D(&cX, i, 2, Z_[i]); \r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint VisibleIntersection23_mem(vector<Feature> vFeature, int frame1, CvMat *X, vector<int> visibleStructureID, vector<vector<double> > &cx, vector<vector<double> > &cX, vector<int> &visibleID)\r\n{\r\n\tvector<double> x_, y_, X_, Y_, Z_;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != visibleStructureID.end()))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tint idx2 = int(it2-visibleStructureID.begin());\r\n\t\t\tx_.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\t\ty_.push_back(vFeature[iFeature].vy[idx1]);\r\n\t\t\tX_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 0));\r\n\t\t\tY_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 1));\r\n\t\t\tZ_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 2));\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tif (x_.size() < 1)\r\n\t\treturn 0;\r\n\tfor (int i = 0; i < x_.size(); i++)\r\n\t{\r\n\t\tvector<double> cx_vec, cX_vec;\r\n\t\tcx_vec.push_back(x_[i]);\r\n\t\tcx_vec.push_back(y_[i]);\r\n\r\n\t\tcX_vec.push_back(X_[i]);\r\n\t\tcX_vec.push_back(Y_[i]);\r\n\t\tcX_vec.push_back(Z_[i]);\r\n\r\n\t\tcx.push_back(cx_vec);\r\n\t\tcX.push_back(cX_vec);\r\n\t}\r\n\treturn visibleID.size();\r\n}\r\n\r\nint VisibleIntersection23_mem_fast(vector<Feature> &vFeature, int frame1, CvMat *X, vector<vector<double> > &cx, vector<vector<double> > &cX, vector<int> &visibleID)\r\n{\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<double> cx_vec, cX_vec;\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (vFeature[iFeature].isRegistered))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\tcx_vec.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\t\tcx_vec.push_back(vFeature[iFeature].vy[idx1]);\r\n\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, vFeature[iFeature].id, 0));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, vFeature[iFeature].id, 1));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, vFeature[iFeature].id, 2));\r\n\r\n\t\t\tcx.push_back(cx_vec);\r\n\t\t\tcX.push_back(cX_vec);\r\n\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tif (cx.size() < 1)\r\n\t\treturn 0;\r\n\treturn visibleID.size();\r\n}\r\n\r\nint VisibleIntersection23_Simple(vector<Feature> &vFeature, int frame1, vector<int> visibleStructureID, vector<int> &visibleID)\r\n{\r\n\tvector<double> x_, y_, X_, Y_, Z_;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tif (it1 == vFeature[iFeature].vFrame.end())\r\n\t\t\tcontinue;\r\n\r\n\t\tvector<int>::iterator it2 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != visibleStructureID.end()))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tint idx2 = int(it2-visibleStructureID.begin());\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\tx_.clear();\r\n\ty_.clear();\r\n\tX_.clear();\r\n\tY_.clear();\r\n\tZ_.clear();\r\n\treturn visibleID.size();\r\n}\r\n\r\nint VisibleIntersection23_Simple_fast(vector<Feature> &vFeature, int frame1)\r\n{\r\n\tint count = 0;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tif (it1 == vFeature[iFeature].vFrame.end())\r\n\t\t\tcontinue;\r\n\t\telse if (vFeature[iFeature].isRegistered)\r\n\t\t\tcount++;\r\n\t}\r\n\treturn count;\r\n}\r\n\r\n//int VisibleIntersection23(vector<Feature> vFeature, int frame1, CvMat *X, vector<int> visibleStructureID, CvMat *x, vector<int> &visibleID)\r\n//{\r\n//\tvector<double> x_, y_, X_, Y_, Z_;\r\n//\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n//\t{\r\n//\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n//\t\tvector<int>::iterator it2 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n//\r\n//\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != visibleStructureID.end()))\r\n//\t\t{\r\n//\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n//\t\t\tint idx2 = int(it2-visibleStructureID.begin());\r\n//\t\t\tx_.push_back(vFeature[iFeature].vx[idx1]);\r\n//\t\t\ty_.push_back(vFeature[iFeature].vy[idx1]);\r\n//\t\t\tX_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 0));\r\n//\t\t\tY_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 1));\r\n//\t\t\tZ_.push_back(cvGetReal2D(X, vFeature[iFeature].id, 2));\r\n//\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tif (x_.size() < 1)\r\n//\t\treturn 0;\r\n//\tcx = *cvCreateMat(x_.size(), 2, CV_32FC1);\r\n//\tcX = *cvCreateMat(x_.size(), 3, CV_32FC1);\r\n//\tfor (int i = 0; i < x_.size(); i++)\r\n//\t{\r\n//\t\tcvSetReal2D(&cx, i, 0, x_[i]);\t\tcvSetReal2D(&cx, i, 1, y_[i]);\r\n//\t\tcvSetReal2D(&cX, i, 0, X_[i]);\t\tcvSetReal2D(&cX, i, 1, Y_[i]);\t\tcvSetReal2D(&cX, i, 2, Z_[i]); \r\n//\t}\r\n//\treturn 1;\r\n//}\r\n\r\nint VisibleIntersectionXOR3(vector<Feature> vFeature, int frame1, int frame2, vector<int> visibleStructureID, CvMat &cx1, CvMat &cx2, vector<int> &visibleID)\r\n{\r\n\tvector<double> x1_, y1_, x2_, y2_;\r\n\tvisibleID.clear();\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\t\tvector<int>::iterator it3 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()) && (it3 == visibleStructureID.end()))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tint idx2 = int(it2-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx1_.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\t\ty1_.push_back(vFeature[iFeature].vy[idx1]);\r\n\t\t\tx2_.push_back(vFeature[iFeature].vx[idx2]);\r\n\t\t\ty2_.push_back(vFeature[iFeature].vy[idx2]);\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tif (x1_.size() == 0)\r\n\t{\r\n\t\tvisibleID.clear();\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tcx1 = *cvCreateMat(x1_.size(), 2, CV_32FC1);\r\n\tcx2 = *cvCreateMat(x1_.size(), 2, CV_32FC1);\r\n\tfor (int i = 0; i < x1_.size(); i++)\r\n\t{\r\n\t\tcvSetReal2D(&cx1, i, 0, x1_[i]);\t\tcvSetReal2D(&cx1, i, 1, y1_[i]);\r\n\t\tcvSetReal2D(&cx2, i, 0, x2_[i]);\t\tcvSetReal2D(&cx2, i, 1, y2_[i]);\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint VisibleIntersectionXOR3_mem(vector<Feature> &vFeature, int frame1, int frame2, vector<int> visibleStructureID, vector<vector<double> > &cx1, vector<vector<double> > &cx2, vector<int> &visibleID)\r\n{\r\n\tvector<double> x1_, y1_, x2_, y2_;\r\n\tvisibleID.clear();\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\t\tvector<int>::iterator it3 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n\r\n\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()) && (it3 == visibleStructureID.end()))\r\n\t\t{\r\n\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\t\tint idx2 = int(it2-vFeature[iFeature].vFrame.begin());\r\n\t\t\tx1_.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\t\ty1_.push_back(vFeature[iFeature].vy[idx1]);\r\n\t\t\tx2_.push_back(vFeature[iFeature].vx[idx2]);\r\n\t\t\ty2_.push_back(vFeature[iFeature].vy[idx2]);\r\n\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tif (x1_.size() == 0)\r\n\t{\r\n\t\tvisibleID.clear();\r\n\t\treturn 0;\r\n\t}\r\n\tfor (int i = 0; i < x1_.size(); i++)\r\n\t{\r\n\t\tvector<double> cx1_vec, cx2_vec;\r\n\t\tcx1_vec.push_back(x1_[i]);\r\n\t\tcx1_vec.push_back(y1_[i]);\r\n\r\n\t\tcx2_vec.push_back(x2_[i]);\r\n\t\tcx2_vec.push_back(y2_[i]);\r\n\r\n\t\tcx1.push_back(cx1_vec);\r\n\t\tcx2.push_back(cx2_vec);\r\n\t}\r\n\treturn cx1.size();\r\n}\r\n\r\nint VisibleIntersectionXOR3_mem_fast(vector<Feature> &vFeature, int frame1, int frame2, vector<vector<double> > &cx1, vector<vector<double> > &cx2, vector<int> &visibleID)\r\n{\r\n\tvisibleID.clear();\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t\tcontinue;\r\n\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n\t\tif (it1 == vFeature[iFeature].vFrame.end())\r\n\t\t\tcontinue;\r\n\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n\t\tif (it2 == vFeature[iFeature].vFrame.end())\r\n\t\t\tcontinue;\r\n\r\n\t\tvector<double> cx1_vec, cx2_vec;\r\n\r\n\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n\t\tint idx2 = int(it2-vFeature[iFeature].vFrame.begin());\r\n\r\n\t\tcx1_vec.push_back(vFeature[iFeature].vx[idx1]);\r\n\t\tcx1_vec.push_back(vFeature[iFeature].vy[idx1]);\r\n\r\n\t\tcx2_vec.push_back(vFeature[iFeature].vx[idx2]);\r\n\t\tcx2_vec.push_back(vFeature[iFeature].vy[idx2]);\r\n\r\n\t\tcx1.push_back(cx1_vec);\r\n\t\tcx2.push_back(cx2_vec);\r\n\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n\t}\r\n\r\n\tif (visibleID.size() == 0)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\treturn cx1.size();\r\n}\r\n\r\n\r\n//int VisibleIntersectionXOR3(vector<Feature> vFeature, int frame1, int frame2, vector<int> visibleStructureID, vector<int> &visibleID)\r\n//{\r\n//\tvector<double> x1_, y1_, x2_, y2_;\r\n//\tvisibleID.clear();\r\n//\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n//\t{\r\n//\t\tvector<int>::iterator it1 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame1);\r\n//\t\tvector<int>::iterator it2 = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),frame2);\r\n//\t\tvector<int>::iterator it3 = find(visibleStructureID.begin(),visibleStructureID.end(),vFeature[iFeature].id);\r\n//\r\n//\t\tif ((it1 != vFeature[iFeature].vFrame.end()) && (it2 != vFeature[iFeature].vFrame.end()) && (it3 == visibleStructureID.end()))\r\n//\t\t{\r\n//\t\t\tint idx1 = int(it1-vFeature[iFeature].vFrame.begin());\r\n//\t\t\tint idx2 = int(it2-vFeature[iFeature].vFrame.begin());\r\n//\t\t\tx1_.push_back(vFeature[iFeature].vx[idx1]);\r\n//\t\t\ty1_.push_back(vFeature[iFeature].vy[idx1]);\r\n//\t\t\tx2_.push_back(vFeature[iFeature].vx[idx2]);\r\n//\t\t\ty2_.push_back(vFeature[iFeature].vy[idx2]);\r\n//\t\t\tvisibleID.push_back(vFeature[iFeature].id);\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tif (x1_.size() == 0)\r\n//\t{\r\n//\t\tvisibleID.clear();\r\n//\t\treturn 0;\r\n//\t}\r\n//\r\n//\tcx1 = *cvCreateMat(x1_.size(), 2, CV_32FC1);\r\n//\tcx2 = *cvCreateMat(x1_.size(), 2, CV_32FC1);\r\n//\tfor (int i = 0; i < x1_.size(); i++)\r\n//\t{\r\n//\t\tcvSetReal2D(&cx1, i, 0, x1_[i]);\t\tcvSetReal2D(&cx1, i, 1, y1_[i]);\r\n//\t\tcvSetReal2D(&cx2, i, 0, x2_[i]);\t\tcvSetReal2D(&cx2, i, 1, y2_[i]);\r\n//\t}\r\n//\treturn 1;\r\n//}\r\n\r\n//int ExcludeOutliers(CvMat *cx1, CvMat *cx2, double ransacThreshold, double ransacMaxIter, vector<int> visibleID, CvMat &ex1, CvMat &ex2, vector<int> &eVisibleID)\r\n//{\r\n//\tClassifier classifier;\r\n//\tclassifier.SetRansacParam(ransacThreshold, ransacMaxIter);\r\n//\tclassifier.SetCorrespondance(cx1, cx2, visibleID);\r\n//\tclassifier.Classify();\r\n//\tvector<int> vInlierID, vOutlierID;\r\n//\tclassifier.GetClassificationResultByFeatureID(vInlierID, vOutlierID);\r\n//\r\n//\tif (vInlierID.size() > 0)\r\n//\t{\r\n//\t\tex1 = *cvCreateMat(classifier.inlier1->rows, classifier.inlier1->cols, CV_32FC1);\r\n//\t\tex2 = *cvCreateMat(classifier.inlier1->rows, classifier.inlier1->cols, CV_32FC1);\r\n//\t\teVisibleID = vInlierID;\r\n//\t\tex1 = *cvCloneMat(classifier.inlier1);\r\n//\t\tex2 = *cvCloneMat(classifier.inlier2);\r\n//\t\treturn 1;\r\n//\t}\r\n//\telse\r\n//\t{\r\n//\t\treturn 0;\r\n//\t}\r\n//}\r\n\r\nint ExcludeOutliers(CvMat *cx1, CvMat *P1, CvMat *cx2, CvMat *P2, CvMat *K, double threshold, vector<int> visibleID, CvMat &ex1, CvMat &ex2, vector<int> &eVisibleID)\r\n{\r\n\t// Find epipole\r\n\tCvMat *e_homo = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetCameraParameter(P1, K, R, C);\r\n\tCvMat *C_homo = cvCreateMat(4,1,CV_32FC1);\r\n\tInhomo2HomoVec(C, C_homo);\r\n\tcvMatMul(P2, C_homo, e_homo);\r\n\r\n\tdouble enorm = NormL2(e_homo);\r\n\tScalarMul(e_homo, 1/enorm, e_homo);\r\n\tCvMat *pinvP1 = cvCreateMat(4,3,CV_32FC1);\r\n\tcvInvert(P1, pinvP1, CV_SVD);\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(P2, pinvP1, temp33);\r\n\tCvMat *skewE = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tVec2Skew(e_homo, skewE);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *FF = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(skewE, temp33, F);\r\n\tdouble Fnorm = NormL2(F);\r\n\tScalarMul(F, 1/Fnorm, F);\r\n\tcvTranspose(F, temp33);\r\n\tcvMatMul(temp33, F, FF);\r\n\r\n\tCvMat *D1=cvCreateMat(cx1->rows,1,CV_32FC1), *D2=cvCreateMat(cx1->rows,1,CV_32FC1), *D=cvCreateMat(cx1->rows,1,CV_32FC1);\r\n\txPy_inhomo(cx2, cx1, F, D1);\r\n\txPx_inhomo(cx1, FF, D2);\r\n\tfor (int iIdx = 0; iIdx < D2->rows; iIdx++)\r\n\t{\r\n\t\tcvSetReal2D(D2, iIdx, 0, sqrt(cvGetReal2D(D2, iIdx, 0)));\r\n\t}\r\n\tcvDiv(D1, D2, D);\r\n\tcvMul(D, D, D);\r\n\r\n\teVisibleID.clear();\r\n\tfor (int iIdx = 0; iIdx < cx1->rows; iIdx++)\r\n\t{\r\n\t\tif (abs(cvGetReal2D(D, iIdx, 0)) < threshold)\r\n\t\t{\r\n\t\t\teVisibleID.push_back(visibleID[iIdx]);\t\r\n\t\t}\r\n\t}\r\n\r\n\tif (eVisibleID.size() > 0)\r\n\t{\r\n\t\tex1 = *cvCreateMat(eVisibleID.size(), 2, CV_32FC1);\r\n\t\tex2 = *cvCreateMat(eVisibleID.size(), 2, CV_32FC1);\r\n\t\tint k = 0;\r\n\t\tfor (int iIdx = 0; iIdx < cx1->rows; iIdx++)\r\n\t\t{\r\n\t\t\tif (abs(cvGetReal2D(D, iIdx, 0)) < threshold)\r\n\t\t\t{\r\n\t\t\t\tcvSetReal2D(&ex1, k, 0, cvGetReal2D(cx1, iIdx, 0));\r\n\t\t\t\tcvSetReal2D(&ex1, k, 1, cvGetReal2D(cx1, iIdx, 1));\r\n\t\t\t\tcvSetReal2D(&ex2, k, 0, cvGetReal2D(cx2, iIdx, 0));\r\n\t\t\t\tcvSetReal2D(&ex2, k, 1, cvGetReal2D(cx2, iIdx, 1));\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcvReleaseMat(&e_homo);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&C_homo);\r\n\tcvReleaseMat(&pinvP1);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&skewE);\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&FF);\r\n\tcvReleaseMat(&D1);\r\n\tcvReleaseMat(&D2);\r\n\tcvReleaseMat(&D);\r\n\r\n\tif (eVisibleID.size() >0)\r\n\t\treturn 1;\r\n\telse \r\n\t\treturn 0;\r\n\r\n}\r\n\r\nint ExcludeOutliers_mem(CvMat *cx1, CvMat *P1, CvMat *cx2, CvMat *P2, CvMat *K, double threshold, vector<int> visibleID, vector<vector<double> > &ex1, vector<vector<double> > &ex2, vector<int> &eVisibleID)\r\n{\r\n\t// Find epipole\r\n\tCvMat *e_homo = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetCameraParameter(P1, K, R, C);\r\n\tCvMat *C_homo = cvCreateMat(4,1,CV_32FC1);\r\n\tInhomo2HomoVec(C, C_homo);\r\n\tcvMatMul(P2, C_homo, e_homo);\r\n\r\n\tdouble enorm = NormL2(e_homo);\r\n\tScalarMul(e_homo, 1/enorm, e_homo);\r\n\tCvMat *pinvP1 = cvCreateMat(4,3,CV_32FC1);\r\n\tcvInvert(P1, pinvP1, CV_SVD);\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(P2, pinvP1, temp33);\r\n\tCvMat *skewE = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tVec2Skew(e_homo, skewE);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *FF = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(skewE, temp33, F);\r\n\tdouble Fnorm = NormL2(F);\r\n\tScalarMul(F, 1/Fnorm, F);\r\n\tcvTranspose(F, temp33);\r\n\tcvMatMul(temp33, F, FF);\r\n\r\n\tCvMat *D1=cvCreateMat(cx1->rows,1,CV_32FC1), *D2=cvCreateMat(cx1->rows,1,CV_32FC1), *D=cvCreateMat(cx1->rows,1,CV_32FC1);\r\n\txPy_inhomo(cx2, cx1, F, D1);\r\n\txPx_inhomo(cx1, FF, D2);\r\n\tfor (int iIdx = 0; iIdx < D2->rows; iIdx++)\r\n\t{\r\n\t\tcvSetReal2D(D2, iIdx, 0, sqrt(cvGetReal2D(D2, iIdx, 0)));\r\n\t}\r\n\tcvDiv(D1, D2, D);\r\n\tcvMul(D, D, D);\r\n\r\n\teVisibleID.clear();\r\n\tfor (int iIdx = 0; iIdx < cx1->rows; iIdx++)\r\n\t{\r\n\t\tif (abs(cvGetReal2D(D, iIdx, 0)) < threshold)\r\n\t\t{\r\n\t\t\teVisibleID.push_back(visibleID[iIdx]);\t\r\n\t\t}\r\n\t}\r\n\r\n\tif (eVisibleID.size() > 0)\r\n\t{\r\n\t\t//ex1 = *cvCreateMat(eVisibleID.size(), 2, CV_32FC1);\r\n\t\t//ex2 = *cvCreateMat(eVisibleID.size(), 2, CV_32FC1);\r\n\t\tint k = 0;\r\n\t\tfor (int iIdx = 0; iIdx < cx1->rows; iIdx++)\r\n\t\t{\r\n\t\t\tif (abs(cvGetReal2D(D, iIdx, 0)) < threshold)\r\n\t\t\t{\r\n\t\t\t\tvector<double> ex1_vec, ex2_vec;\r\n\t\t\t\tex1_vec.push_back(cvGetReal2D(cx1, iIdx, 0));\r\n\t\t\t\tex1_vec.push_back(cvGetReal2D(cx1, iIdx, 1));\r\n\r\n\t\t\t\tex2_vec.push_back(cvGetReal2D(cx2, iIdx, 0));\r\n\t\t\t\tex2_vec.push_back(cvGetReal2D(cx2, iIdx, 1));\r\n\r\n\t\t\t\tex1.push_back(ex1_vec);\r\n\t\t\t\tex2.push_back(ex2_vec);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcvReleaseMat(&e_homo);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&C_homo);\r\n\tcvReleaseMat(&pinvP1);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&skewE);\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&FF);\r\n\tcvReleaseMat(&D1);\r\n\tcvReleaseMat(&D2);\r\n\tcvReleaseMat(&D);\r\n\r\n\tif (eVisibleID.size() >0)\r\n\t\treturn 1;\r\n\telse \r\n\t\treturn 0;\r\n\r\n}\r\n\r\nint ExcludeOutliers_mem_fast(CvMat *cx1, CvMat *P1, CvMat *cx2, CvMat *P2, CvMat *K, double threshold, vector<int> visibleID, vector<vector<double> > &ex1, vector<vector<double> > &ex2, vector<int> &eVisibleID)\r\n{\r\n\t// Find epipole\r\n\tCvMat *e_homo = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetCameraParameter(P1, K, R, C);\r\n\tCvMat *C_homo = cvCreateMat(4,1,CV_32FC1);\r\n\tInhomo2HomoVec(C, C_homo);\r\n\tcvMatMul(P2, C_homo, e_homo);\r\n\r\n\tdouble enorm = NormL2(e_homo);\r\n\tScalarMul(e_homo, 1/enorm, e_homo);\r\n\tCvMat *pinvP1 = cvCreateMat(4,3,CV_32FC1);\r\n\tcvInvert(P1, pinvP1, CV_SVD);\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(P2, pinvP1, temp33);\r\n\tCvMat *skewE = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tVec2Skew(e_homo, skewE);\r\n\tCvMat *F = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *FF = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(skewE, temp33, F);\r\n\tdouble Fnorm = NormL2(F);\r\n\tScalarMul(F, 1/Fnorm, F);\r\n\tcvTranspose(F, temp33);\r\n\tcvMatMul(temp33, F, FF);\r\n\r\n\t//CvMat *D1=cvCreateMat(cx1->rows,1,CV_32FC1), *D2=cvCreateMat(cx1->rows,1,CV_32FC1), *D=cvCreateMat(cx1->rows,1,CV_32FC1);\r\n\t//xPy_inhomo(cx2, cx1, F, D1);\r\n\t//xPx_inhomo(cx1, FF, D2);\r\n\t//for (int iIdx = 0; iIdx < D2->rows; iIdx++)\r\n\t//{\r\n\t//\tcvSetReal2D(D2, iIdx, 0, sqrt(cvGetReal2D(D2, iIdx, 0)));\r\n\t//}\r\n\t//cvDiv(D1, D2, D);\r\n\t//cvMul(D, D, D);\r\n\r\n\teVisibleID.clear();\r\n\tfor (int iIdx = 0; iIdx < cx1->rows; iIdx++)\r\n\t{\r\n\t\tCvMat *xM2 = cvCreateMat(1, 3, CV_32FC1);\r\n\t\tCvMat *xM1 = cvCreateMat(3, 1, CV_32FC1);\r\n\t\tCvMat *s = cvCreateMat(1, 1, CV_32FC1);\r\n\r\n\t\tcvSetReal2D(xM2, 0, 0, cvGetReal2D(cx2, iIdx, 0));\r\n\t\tcvSetReal2D(xM2, 0, 1, cvGetReal2D(cx2, iIdx, 1));\r\n\t\tcvSetReal2D(xM2, 0, 2, 1);\r\n\t\tcvSetReal2D(xM1, 0, 0, cvGetReal2D(cx1, iIdx, 0));\r\n\t\tcvSetReal2D(xM1, 1, 0, cvGetReal2D(cx2, iIdx, 1));\r\n\t\tcvSetReal2D(xM1, 2, 0, 1);\r\n\t\tcvMatMul(xM2, F, xM2);\r\n\t\tcvMatMul(xM2, xM1, s);\t\t\t\r\n\r\n\t\tdouble l1 = cvGetReal2D(xM2, 0, 0);\r\n\t\tdouble l2 = cvGetReal2D(xM2, 0, 1);\r\n\t\tdouble l3 = cvGetReal2D(xM2, 0, 2);\r\n\r\n\t\tdouble dist = abs(cvGetReal2D(s, 0, 0))/sqrt(l1*l1+l2*l2);\r\n\t\tcout << dist << endl;\r\n\r\n\t\tif (abs(dist) < threshold)\r\n\t\t{\r\n\t\t\tvector<double> ex1_vec, ex2_vec;\r\n\t\t\tex1_vec.push_back(cvGetReal2D(cx1, iIdx, 0));\r\n\t\t\tex1_vec.push_back(cvGetReal2D(cx1, iIdx, 1));\r\n\r\n\t\t\tex2_vec.push_back(cvGetReal2D(cx2, iIdx, 0));\r\n\t\t\tex2_vec.push_back(cvGetReal2D(cx2, iIdx, 1));\r\n\r\n\t\t\tex1.push_back(ex1_vec);\r\n\t\t\tex2.push_back(ex2_vec);\r\n\t\t\teVisibleID.push_back(visibleID[iIdx]);\t\r\n\t\t}\r\n\r\n\t\tcvReleaseMat(&xM2);\r\n\t\tcvReleaseMat(&xM1);\r\n\t\tcvReleaseMat(&s);\r\n\t}\r\n\r\n\tcvReleaseMat(&e_homo);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&C_homo);\r\n\tcvReleaseMat(&pinvP1);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&skewE);\r\n\tcvReleaseMat(&F);\r\n\tcvReleaseMat(&FF);\r\n\t//cvReleaseMat(&D1);\r\n\t//cvReleaseMat(&D2);\r\n\t//cvReleaseMat(&D);\r\n\r\n\tif (eVisibleID.size() > 0)\r\n\t\treturn 1;\r\n\telse \r\n\t\treturn 0;\r\n\r\n}\r\n\r\n\r\n\r\nvoid NonlinearTriangulation(CvMat *x1, CvMat *x2, CvMat *F, CvMat &xhat1, CvMat &xhat2)\r\n{\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tCvMat *T1 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *T2 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvSetZero(T1);\r\n\t\tcvSetReal2D(T1, 0, 0, 1.0);\r\n\t\tcvSetReal2D(T1, 1, 1, 1.0);\r\n\t\tcvSetReal2D(T1, 2, 2, 1.0);\r\n\r\n\t\tcvSetReal2D(T1, 0, 2, -cvGetReal2D(x1, ix, 0));\r\n\t\tcvSetReal2D(T1, 1, 2, -cvGetReal2D(x1, ix, 1));\r\n\t\t\r\n\t\tcvSetZero(T2);\r\n\t\tcvSetReal2D(T2, 0, 0, 1.0);\r\n\t\tcvSetReal2D(T2, 1, 1, 1.0);\r\n\t\tcvSetReal2D(T2, 2, 2, 1.0);\r\n\t\tcvSetReal2D(T2, 0, 2, -cvGetReal2D(x2, ix, 0));\r\n\t\tcvSetReal2D(T2, 1, 2, -cvGetReal2D(x2, ix, 1));\r\n\t\tCvMat *nF = cvCreateMat(3,3,CV_32FC1);\r\n\t\tnF = cvCloneMat(F);\r\n\t\tCvMat *FinvT1 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invT1 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invT2 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invT2t = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\t\tcvInvert(T1, invT1);\tcvInvert(T2, invT2);\tcvTranspose(invT2, invT2t);\r\n\t\tcvMatMul(nF, invT1, FinvT1);\r\n\t\tcvMatMul(invT2t, FinvT1, nF);\r\n\t\tCvMat *U = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *D = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *Vt = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvSVD(nF, D, U, Vt, CV_SVD_V_T);\t\tcvSetReal2D(D, 2, 2, 0);\r\n\t\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\tCvMat *temp33_1 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvMatMul(U, D, temp33);\r\n\t\tcvMatMul(temp33, Vt, nF);\r\n\t\r\n\t\tCvMat *e1 = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *e2 = cvCreateMat(3,1,CV_32FC1);\r\n\t\tdouble e11 = cvGetReal2D(Vt,2,0);\tdouble e12 = cvGetReal2D(Vt,2,1);\tdouble e13 = cvGetReal2D(Vt,2,2);\r\n\t\tCvMat *nFt = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvTranspose(nF, nFt);\r\n\t\tcvSVD(nFt, D, U, Vt, CV_SVD_V_T);\r\n\t\tdouble norm_e1 = sqrt(e11*e11+e12*e12);\r\n\t\tdouble e21 = cvGetReal2D(Vt,2,0);\tdouble e22 = cvGetReal2D(Vt,2,1);\tdouble e23 = cvGetReal2D(Vt,2,2);\r\n\t\tdouble norm_e2 = sqrt(e21*e21+e22*e22);\r\n\t\tcvSetReal2D(e1,0,0,e11/norm_e1);\tcvSetReal2D(e1,1,0,e12/norm_e1);\tcvSetReal2D(e1,2,0,e13/norm_e1);\t\r\n\t\tcvSetReal2D(e2,0,0,e21/norm_e2);\tcvSetReal2D(e2,1,0,e22/norm_e2);\tcvSetReal2D(e2,2,0,e23/norm_e2);\t\r\n\r\n\t\tCvMat *R1 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *R2 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvSetIdentity(R1);\t\tcvSetIdentity(R2);\r\n\t\tcvSetReal2D(R1, 0, 0, cvGetReal2D(e1, 0, 0));\tcvSetReal2D(R1, 0, 1, cvGetReal2D(e1, 1, 0));\t\r\n\t\tcvSetReal2D(R1, 1, 0, -cvGetReal2D(e1, 1, 0));\tcvSetReal2D(R1, 1, 1, cvGetReal2D(e1, 0, 0));\t\t\r\n\t\tcvSetReal2D(R2, 0, 0, cvGetReal2D(e2, 0, 0));\tcvSetReal2D(R2, 0, 1, cvGetReal2D(e2, 1, 0));\t\r\n\t\tcvSetReal2D(R2, 1, 0, -cvGetReal2D(e2, 1, 0));\tcvSetReal2D(R2, 1, 1, cvGetReal2D(e2, 0, 0));\t\r\n\r\n\t\tcvMatMul(R2, nF, temp33);\r\n\t\tcvTranspose(R1, temp33_1);\r\n\t\tcvMatMul(temp33, temp33_1, nF);\r\n\t\tdouble f1 = cvGetReal2D(e1, 2, 0);\r\n\t\tdouble f2 = cvGetReal2D(e2, 2, 0);\r\n\t\tdouble a = cvGetReal2D(nF, 1, 1);\r\n\t\tdouble b = cvGetReal2D(nF, 1, 2);\r\n\t\tdouble c = cvGetReal2D(nF, 2, 1);\r\n\t\tdouble d = cvGetReal2D(nF, 2, 2);\r\n\t\tdouble g1 = -(a*d-b*c)*f1*f1*f1*f1*a*c;\r\n\t\tdouble g2 = (a*a+f2*f2*c*c)*(a*a+f2*f2*c*c)-(a*d-b*c)*f1*f1*f1*f1*b*c-(a*d-b*c)*f1*f1*f1*f1*a*d;\r\n\t\tdouble g3 = (2*(2*b*a+2*f2*f2*d*c)*(a*a+f2*f2*c*c)-2*(a*d-b*c)*f1*f1*a*c-(a*d-b*c)*f1*f1*f1*f1*b*d);\r\n\t\tdouble g4 = (-2*(a*d-b*c)*f1*f1*b*c-2*(a*d-b*c)*f1*f1*a*d+2*(b*b+f2*f2*d*d)*(a*a+f2*f2*c*c)+(2*b*a+2*f2*f2*d*c)*(2*b*a+2*f2*f2*d*c));\r\n\t\tdouble g5 = (-(a*d-b*c)*a*c-2*(a*d-b*c)*f1*f1*b*d+2*(b*b+f2*f2*d*d)*(2*b*a+2*f2*f2*d*c));\r\n\t\tdouble g6 = ((b*b+f2*f2*d*d)*(b*b+f2*f2*d*d)-(a*d-b*c)*b*c-(a*d-b*c)*a*d);\r\n\t\tdouble g7 = -(a*d-b*c)*b*d;\r\n\r\n\t\tCvMat *G = cvCreateMat(7,1,CV_32FC1);\r\n\t\tCvMat *root = cvCreateMat(6,1, CV_32FC2);\r\n\t\tcvSetReal2D(G, 0, 0, g1);\r\n\t\tcvSetReal2D(G, 1, 0, g2);\r\n\t\tcvSetReal2D(G, 2, 0, g3);\r\n\t\tcvSetReal2D(G, 3, 0, g4);\r\n\t\tcvSetReal2D(G, 4, 0, g5);\r\n\t\tcvSetReal2D(G, 5, 0, g6);\r\n\t\tcvSetReal2D(G, 6, 0, g7);\r\n\r\n\t\tcvSolvePoly(G, root, 1e+3, 10);\r\n\t\tfor (int i = 0; i < 6; i++)\r\n\t\t{\r\n\t\t\tCvScalar r = cvGet2D(root, i, 0);\r\n\t\t\tcout << r.val[0] << \" \" << r.val[1]<< endl;\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\t//\te1 = null(F);   e1 = e1/sqrt(e1(1)^2+e1(2)^2);\r\n\t//e2 = null(F');  e2 = e2/sqrt(e2(1)^2+e2(2)^2);\r\n\t//\tR1 = [e1(1) e1(2) 0; -e1(2) e1(1) 0; 0 0 1];\r\n\t//R2 = [e2(1) e2(2) 0; -e2(2) e2(1) 0; 0 0 1];\r\n\t//F = R2*F*R1';\r\n\t//\tf1 = e1(3); f2 = e2(3);\r\n\t//a = F(2,2); b = F(2,3); c = F(3,2); d = F(3,3);\r\n\t//g = [-(a*d-b*c)*f1^4*a*c,...\r\n\t//\t(a^2+f2^2*c^2)^2-(a*d-b*c)*f1^4*b*c-(a*d-b*c)*f1^4*a*d,...\r\n\t//\t(2*(2*b*a+2*f2^2*d*c)*(a^2+f2^2*c^2)-2*(a*d-b*c)*f1^2*a*c-(a*d-b*c)*f1^4*b*d),...\r\n\t//\t(-2*(a*d-b*c)*f1^2*b*c-2*(a*d-b*c)*f1^2*a*d+2*(b^2+f2^2*d^2)*(a^2+f2^2*c^2)+(2*b*a+2*f2^2*d*c)^2),...\r\n\t//\t(-(a*d-b*c)*a*c-2*(a*d-b*c)*f1^2*b*d+2*(b^2+f2^2*d^2)*(2*b*a+2*f2^2*d*c)),...\r\n\t//\t((b^2+f2^2*d^2)^2-(a*d-b*c)*b*c-(a*d-b*c)*a*d),...\r\n\t//\t-(a*d-b*c)*b*d];\r\n\t//t = roots(g);\r\n\t//t = real(t);\r\n\t//s = t.^2./(1+f1^2*t.^2) + (c*t+d).^2./((a*t+b).^2 + f2^2*(c*t+d).^2);\r\n\t//s(end+1) = 1/f1^2+c^2/(a^2+f2^2*c^2);\r\n\t//[mins,minidx] = min(s);\r\n\t//if minidx <= length(t)\r\n\t//\tt = t(minidx);\r\n\t//else\r\n\t//\tt = 1e+6;\r\n\t//end\r\n\t//\tl1 = [t*f1, 1, -t];\r\n\t//l2 = F*[0; t; 1];\r\n\t//xhat1_t = [-l1(1)*l1(3); -l1(2)*l1(3); l1(1)^2+l1(2)^2];\r\n\t//xhat2_t = [-l2(1)*l2(3); -l2(2)*l2(3); l2(1)^2+l2(2)^2];\r\n\t//xhat1_t = inv(T1)*R1'*xhat1_t;\r\n\t//\txhat2_t = inv(T2)*R2'*xhat2_t;\r\n\t//\txhat1_t = xhat1_t/xhat1_t(3);\r\n\t//xhat2_t = xhat2_t/xhat2_t(3);\r\n\t//xhat1(i,:) = xhat1_t;\r\n\t//xhat2(i,:) = xhat2_t;\r\n\t//end\r\n\r\n}\r\n\r\nvoid GetExtrinsicParameterFromE(CvMat *E, CvMat *x1, CvMat *x2, CvMat &P)\r\n{\r\n\tCvMat *W = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *U = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *D = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *Vt = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *Wt = cvCreateMat(3, 3, CV_32FC1);\r\n\tcvSVD(E, D, U, Vt, CV_SVD_V_T);\r\n\r\n\t//cvSetReal2D(D, 1,1,cvGetReal2D(D,0,0));\r\n\t//cvMatMul(U, D, E);\r\n\t//cvMatMul(E, Vt, E);\r\n\t//cvSVD(E, D, U, Vt, CV_SVD_V_T);\r\n\r\n\tcvSetReal2D(W, 0, 0, 0);\tcvSetReal2D(W, 0, 1, -1);\tcvSetReal2D(W, 0, 2, 0);\r\n\tcvSetReal2D(W, 1, 0, 1);\tcvSetReal2D(W, 1, 1, 0);\tcvSetReal2D(W, 1, 2, 0);\r\n\tcvSetReal2D(W, 2, 0, 0);\tcvSetReal2D(W, 2, 1, 0);\tcvSetReal2D(W, 2, 2, 1);\r\n\tcvTranspose(W, Wt);\r\n\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\tP = *cvCreateMat(3, 4, CV_32FC1);\r\n\r\n\tCvMat *P1 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P2 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P3 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P4 = cvCreateMat(3, 4, CV_32FC1);\r\n\r\n\tCvMat *R1 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *R2 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *t1 = cvCreateMat(3, 1, CV_32FC1);\r\n\tCvMat *t2 = cvCreateMat(3, 1, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\r\n\tcvMatMul(U, W, temp33);\r\n\tcvMatMul(temp33, Vt, R1);\r\n\tcvMatMul(U, Wt, temp33);\r\n\tcvMatMul(temp33, Vt, R2);\r\n\t\r\n\tcvSetReal2D(t1, 0, 0, cvGetReal2D(U,0,2));\r\n\tcvSetReal2D(t1, 1, 0, cvGetReal2D(U,1,2));\r\n\tcvSetReal2D(t1, 2, 0, cvGetReal2D(U,2,2));\r\n\tScalarMul(t1, -1, t2);\r\n\r\n\tSetSubMat(P1, 0, 0, R1);\r\n\tSetSubMat(P1, 0, 3, t1);\r\n\tSetSubMat(P2, 0, 0, R1);\r\n\tSetSubMat(P2, 0, 3, t2);\r\n\tSetSubMat(P3, 0, 0, R2);\r\n\tSetSubMat(P3, 0, 3, t1);\r\n\tSetSubMat(P4, 0, 0, R2);\r\n\tSetSubMat(P4, 0, 3, t2);\r\n\tif (cvDet(R1) < 0)\r\n\t{\r\n\t\tScalarMul(P1, -1, P1);\t\t\r\n\t\tScalarMul(P2, -1, P2);\t\t\r\n\t}\r\n\r\n\tif (cvDet(R2) < 0)\r\n\t{\r\n\t\tScalarMul(P3, -1, P3);\t\t\r\n\t\tScalarMul(P4, -1, P4);\t\t\r\n\t}\r\n\tCvMat X1;\r\n\tLinearTriangulation(x1, P0, x2, P1, X1);\r\n\tCvMat X2;\r\n\tLinearTriangulation(x1, P0, x2, P2, X2);\r\n\tCvMat X3;\r\n\tLinearTriangulation(x1, P0, x2, P3, X3);\r\n\tCvMat X4;\r\n\tLinearTriangulation(x1, P0, x2, P4, X4);\r\n\r\n\tint x1neg = 0, x2neg = 0, x3neg = 0, x4neg = 0;\r\n\tCvMat *H1 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH1 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat HX1;\r\n\tcvSetIdentity(H1);\r\n\tSetSubMat(H1, 0, 0, P1);\r\n\tcvInvert(H1, invH1);\r\n\tPxx_inhomo(H1, &X1, HX1);\r\n\r\n\tCvMat *H2 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH2 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat HX2;\r\n\tcvSetIdentity(H2);\r\n\tSetSubMat(H2, 0, 0, P2);\r\n\tcvInvert(H2, invH2);\r\n\tPxx_inhomo(H2, &X2, HX2);\r\n\tCvMat *H3 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH3 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat HX3;\r\n\tcvSetIdentity(H3);\r\n\tSetSubMat(H3, 0, 0, P3);\r\n\tcvInvert(H3, invH3);\r\n\tPxx_inhomo(H3, &X3, HX3);\r\n\tCvMat *H4 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH4 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat HX4;\r\n\tcvSetIdentity(H4);\r\n\tSetSubMat(H4, 0, 0, P4);\r\n\tcvInvert(H4, invH4);\r\n\tPxx_inhomo(H4, &X4, HX4);\r\n\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tif ((cvGetReal2D(&X1, ix, 2)<0) || (cvGetReal2D(&HX1, ix, 2)<0))\r\n\t\t\tx1neg++;\r\n\t\tif ((cvGetReal2D(&X2, ix, 2)<0) || (cvGetReal2D(&HX2, ix, 2)<0))\r\n\t\t\tx2neg++;\r\n\t\tif ((cvGetReal2D(&X3, ix, 2)<0) || (cvGetReal2D(&HX3, ix, 2)<0))\r\n\t\t\tx3neg++;\r\n\t\tif ((cvGetReal2D(&X4, ix, 2)<0) || (cvGetReal2D(&HX4, ix, 2)<0))\r\n\t\t\tx4neg++;\r\n\t}\r\n\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\tif ((x1neg <= x2neg) && (x1neg <= x3neg) && (x1neg <= x4neg))\r\n\t\tP = *cvCloneMat(P1);\r\n\telse if ((x2neg <= x1neg) && (x2neg <= x3neg) && (x2neg <= x4neg))\r\n\t\tP = *cvCloneMat(P2);\r\n\telse if ((x3neg <= x1neg) && (x3neg <= x2neg) && (x3neg <= x4neg))\r\n\t\tP = *cvCloneMat(P3);\r\n\telse\r\n\t\tP = *cvCloneMat(P4);\r\n\r\n\tcvReleaseMat(&W);\r\n\tcvReleaseMat(&U);\r\n\tcvReleaseMat(&D);\r\n\tcvReleaseMat(&Vt);\r\n\tcvReleaseMat(&Wt);\r\n\tcvReleaseMat(&P0);\r\n\tcvReleaseMat(&P1);\r\n\tcvReleaseMat(&P2);\r\n\tcvReleaseMat(&P3);\r\n\tcvReleaseMat(&P4);\r\n\tcvReleaseMat(&R1);\r\n\tcvReleaseMat(&R2);\r\n\tcvReleaseMat(&t1);\r\n\tcvReleaseMat(&t2);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&H1);\r\n\tcvReleaseMat(&invH1);\r\n\tcvReleaseMat(&H2);\r\n\tcvReleaseMat(&invH2);\r\n\tcvReleaseMat(&H3);\r\n\tcvReleaseMat(&invH3);\r\n\tcvReleaseMat(&H4);\r\n\tcvReleaseMat(&invH4);\r\n}\r\n\r\nvoid GetExtrinsicParameterFromE(CvMat *E, CvMat *x1, CvMat *x2, CvMat *P)\r\n{\r\n\tCvMat *W = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *U = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *D = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *Vt = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *Wt = cvCreateMat(3, 3, CV_32FC1);\r\n\tcvSVD(E, D, U, Vt, CV_SVD_V_T);\r\n\r\n\t//cvSetReal2D(D, 1,1,cvGetReal2D(D,0,0));\r\n\t//cvMatMul(U, D, E);\r\n\t//cvMatMul(E, Vt, E);\r\n\t//cvSVD(E, D, U, Vt, CV_SVD_V_T);\r\n\r\n\tcvSetReal2D(W, 0, 0, 0);\tcvSetReal2D(W, 0, 1, -1);\tcvSetReal2D(W, 0, 2, 0);\r\n\tcvSetReal2D(W, 1, 0, 1);\tcvSetReal2D(W, 1, 1, 0);\tcvSetReal2D(W, 1, 2, 0);\r\n\tcvSetReal2D(W, 2, 0, 0);\tcvSetReal2D(W, 2, 1, 0);\tcvSetReal2D(W, 2, 2, 1);\r\n\tcvTranspose(W, Wt);\r\n\r\n\tCvMat *P0 = cvCreateMat(3, 4, CV_32FC1);\r\n\tcvSetIdentity(P0);\r\n\r\n\tCvMat *P1 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P2 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P3 = cvCreateMat(3, 4, CV_32FC1);\r\n\tCvMat *P4 = cvCreateMat(3, 4, CV_32FC1);\r\n\r\n\tCvMat *R1 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *R2 = cvCreateMat(3, 3, CV_32FC1);\r\n\tCvMat *t1 = cvCreateMat(3, 1, CV_32FC1);\r\n\tCvMat *t2 = cvCreateMat(3, 1, CV_32FC1);\r\n\tCvMat *temp33 = cvCreateMat(3, 3, CV_32FC1);\r\n\r\n\tcvMatMul(U, W, temp33);\r\n\tcvMatMul(temp33, Vt, R1);\r\n\tcvMatMul(U, Wt, temp33);\r\n\tcvMatMul(temp33, Vt, R2);\r\n\r\n\tcvSetReal2D(t1, 0, 0, cvGetReal2D(U,0,2));\r\n\tcvSetReal2D(t1, 1, 0, cvGetReal2D(U,1,2));\r\n\tcvSetReal2D(t1, 2, 0, cvGetReal2D(U,2,2));\r\n\tScalarMul(t1, -1, t2);\r\n\r\n\tSetSubMat(P1, 0, 0, R1);\r\n\tSetSubMat(P1, 0, 3, t1);\r\n\tSetSubMat(P2, 0, 0, R1);\r\n\tSetSubMat(P2, 0, 3, t2);\r\n\tSetSubMat(P3, 0, 0, R2);\r\n\tSetSubMat(P3, 0, 3, t1);\r\n\tSetSubMat(P4, 0, 0, R2);\r\n\tSetSubMat(P4, 0, 3, t2);\r\n\tif (cvDet(R1) < 0)\r\n\t{\r\n\t\tScalarMul(P1, -1, P1);\t\t\r\n\t\tScalarMul(P2, -1, P2);\t\t\r\n\t}\r\n\r\n\tif (cvDet(R2) < 0)\r\n\t{\r\n\t\tScalarMul(P3, -1, P3);\t\t\r\n\t\tScalarMul(P4, -1, P4);\t\t\r\n\t}\r\n\tCvMat *X1 = cvCreateMat(x1->rows, 3, CV_32FC1);\r\n\tLinearTriangulation(x1, P0, x2, P1, X1);\r\n\tCvMat *X2 = cvCreateMat(x1->rows, 3, CV_32FC1);;\r\n\tLinearTriangulation(x1, P0, x2, P2, X2);\r\n\tCvMat *X3 = cvCreateMat(x1->rows, 3, CV_32FC1);;\r\n\tLinearTriangulation(x1, P0, x2, P3, X3);\r\n\tCvMat *X4 = cvCreateMat(x1->rows, 3, CV_32FC1);;\r\n\tLinearTriangulation(x1, P0, x2, P4, X4);\r\n\r\n\tint x1neg = 0, x2neg = 0, x3neg = 0, x4neg = 0;\r\n\tCvMat *H1 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH1 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat *HX1 = cvCreateMat(X1->rows, X1->cols, CV_32FC1);\r\n\tcvSetIdentity(H1);\r\n\tSetSubMat(H1, 0, 0, P1);\r\n\tcvInvert(H1, invH1);\r\n\tPxx_inhomo(H1, X1, HX1);\r\n\r\n\tCvMat *H2 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH2 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat *HX2 = cvCreateMat(X1->rows, X1->cols, CV_32FC1);\r\n\tcvSetIdentity(H2);\r\n\tSetSubMat(H2, 0, 0, P2);\r\n\tcvInvert(H2, invH2);\r\n\tPxx_inhomo(H2, X2, HX2);\r\n\tCvMat *H3 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH3 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat *HX3 = cvCreateMat(X1->rows, X1->cols, CV_32FC1);\r\n\tcvSetIdentity(H3);\r\n\tSetSubMat(H3, 0, 0, P3);\r\n\tcvInvert(H3, invH3);\r\n\tPxx_inhomo(H3, X3, HX3);\r\n\tCvMat *H4 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH4 = cvCreateMat(4, 4, CV_32FC1);\t\tCvMat *HX4 = cvCreateMat(X1->rows, X1->cols, CV_32FC1);\r\n\tcvSetIdentity(H4);\r\n\tSetSubMat(H4, 0, 0, P4);\r\n\tcvInvert(H4, invH4);\r\n\tPxx_inhomo(H4, X4, HX4);\r\n\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tif ((cvGetReal2D(X1, ix, 2)<0) || (cvGetReal2D(HX1, ix, 2)<0))\r\n\t\t\tx1neg++;\r\n\t\tif ((cvGetReal2D(X2, ix, 2)<0) || (cvGetReal2D(HX2, ix, 2)<0))\r\n\t\t\tx2neg++;\r\n\t\tif ((cvGetReal2D(X3, ix, 2)<0) || (cvGetReal2D(HX3, ix, 2)<0))\r\n\t\t\tx3neg++;\r\n\t\tif ((cvGetReal2D(X4, ix, 2)<0) || (cvGetReal2D(HX4, ix, 2)<0))\r\n\t\t\tx4neg++;\r\n\t}\r\n\r\n\tCvMat *temp34 = cvCreateMat(3, 4, CV_32FC1);\r\n\tif ((x1neg <= x2neg) && (x1neg <= x3neg) && (x1neg <= x4neg))\r\n\t\tSetSubMat(P, 0, 0, P1);\r\n\telse if ((x2neg <= x1neg) && (x2neg <= x3neg) && (x2neg <= x4neg))\r\n\t\tSetSubMat(P, 0, 0, P2);\r\n\telse if ((x3neg <= x1neg) && (x3neg <= x2neg) && (x3neg <= x4neg))\r\n\t\tSetSubMat(P, 0, 0, P3);\r\n\telse\r\n\t\tSetSubMat(P, 0, 0, P4);\r\n\r\n\t//cout << x1neg << \" \" << x2neg << \" \" << \" \" << x3neg << \" \" << x4neg << endl;\r\n\tcvReleaseMat(&W);\r\n\tcvReleaseMat(&U);\r\n\tcvReleaseMat(&D);\r\n\tcvReleaseMat(&Vt);\r\n\tcvReleaseMat(&Wt);\r\n\tcvReleaseMat(&P0);\r\n\tcvReleaseMat(&P1);\r\n\tcvReleaseMat(&P2);\r\n\tcvReleaseMat(&P3);\r\n\tcvReleaseMat(&P4);\r\n\tcvReleaseMat(&R1);\r\n\tcvReleaseMat(&R2);\r\n\tcvReleaseMat(&t1);\r\n\tcvReleaseMat(&t2);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&H1);\r\n\tcvReleaseMat(&invH1);\r\n\tcvReleaseMat(&H2);\r\n\tcvReleaseMat(&invH2);\r\n\tcvReleaseMat(&H3);\r\n\tcvReleaseMat(&invH3);\r\n\tcvReleaseMat(&H4);\r\n\tcvReleaseMat(&invH4);\r\n\tcvReleaseMat(&X1);\r\n\tcvReleaseMat(&X2);\r\n\tcvReleaseMat(&X3);\r\n\tcvReleaseMat(&X4);\r\n\r\n\tcvReleaseMat(&HX1);\r\n\tcvReleaseMat(&HX2);\r\n\tcvReleaseMat(&HX3);\r\n\tcvReleaseMat(&HX4);\r\n}\r\n\r\nvoid LinearTriangulation(CvMat *x1, CvMat *P1, CvMat *x2, CvMat *P2, CvMat &X)\r\n{\r\n\tX = *cvCreateMat(x1->rows, 3, CV_32FC1);\r\n\tcvSetZero(&X);\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tCvMat *A = cvCreateMat(4, 4, CV_32FC1);\r\n\t\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A4 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tGetSubMatRowwise(P1, 0, 0, P1_1);\r\n\t\tGetSubMatRowwise(P1, 1, 1, P1_2);\r\n\t\tGetSubMatRowwise(P1, 2, 2, P1_3);\r\n\t\tGetSubMatRowwise(P2, 0, 0, P2_1);\r\n\t\tGetSubMatRowwise(P2, 1, 1, P2_2);\r\n\t\tGetSubMatRowwise(P2, 2, 2, P2_3);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P1_1, A1);\r\n\t\t\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P1_2, A2);\r\n\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P2_1, A3);\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P2_2, A4);\r\n\t\tSetSubMat(A, 0, 0, A1);\r\n\t\tSetSubMat(A, 1, 0, A2);\r\n\t\tSetSubMat(A, 2, 0, A3);\r\n\t\tSetSubMat(A, 3, 0, A4);\r\n\r\n\t\tCvMat x;\r\n\t\tLS_homogeneous(A, x);\r\n\t\tdouble v = cvGetReal2D(&x, 3, 0);\r\n\t\tcvSetReal2D(&X, ix, 0, cvGetReal2D(&x, 0, 0)/v);\r\n\t\tcvSetReal2D(&X, ix, 1, cvGetReal2D(&x, 1, 0)/v);\r\n\t\tcvSetReal2D(&X, ix, 2, cvGetReal2D(&x, 2, 0)/v);\r\n\r\n\t\tcvReleaseMat(&A);\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A3);\r\n\t\tcvReleaseMat(&A4);\r\n\t\tcvReleaseMat(&P1_1);\r\n\t\tcvReleaseMat(&P1_2);\r\n\t\tcvReleaseMat(&P1_3);\r\n\t\tcvReleaseMat(&P2_1);\r\n\t\tcvReleaseMat(&P2_2);\r\n\t\tcvReleaseMat(&P2_3);\r\n\t\tcvReleaseMat(&temp14_1);\r\n\t}\r\n}\r\n\r\nvoid LinearTriangulation(CvMat *x1, CvMat *P1, CvMat *x2, CvMat *P2, CvMat *X)\r\n{\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tCvMat *A = cvCreateMat(4, 4, CV_32FC1);\r\n\t\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A4 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tGetSubMatRowwise(P1, 0, 0, P1_1);\r\n\t\tGetSubMatRowwise(P1, 1, 1, P1_2);\r\n\t\tGetSubMatRowwise(P1, 2, 2, P1_3);\r\n\t\tGetSubMatRowwise(P2, 0, 0, P2_1);\r\n\t\tGetSubMatRowwise(P2, 1, 1, P2_2);\r\n\t\tGetSubMatRowwise(P2, 2, 2, P2_3);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P1_1, A1);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P1_2, A2);\r\n\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P2_1, A3);\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P2_2, A4);\r\n\t\tSetSubMat(A, 0, 0, A1);\r\n\t\tSetSubMat(A, 1, 0, A2);\r\n\t\tSetSubMat(A, 2, 0, A3);\r\n\t\tSetSubMat(A, 3, 0, A4);\r\n\r\n\t\tCvMat *x = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\t\tLS_homogeneous(A, x);\r\n\t\tdouble v = cvGetReal2D(x, 3, 0);\r\n\t\tcvSetReal2D(X, ix, 0, cvGetReal2D(x, 0, 0)/v);\r\n\t\tcvSetReal2D(X, ix, 1, cvGetReal2D(x, 1, 0)/v);\r\n\t\tcvSetReal2D(X, ix, 2, cvGetReal2D(x, 2, 0)/v);\r\n\r\n\t\tcvReleaseMat(&A);\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A3);\r\n\t\tcvReleaseMat(&A4);\r\n\t\tcvReleaseMat(&P1_1);\r\n\t\tcvReleaseMat(&P1_2);\r\n\t\tcvReleaseMat(&P1_3);\r\n\t\tcvReleaseMat(&P2_1);\r\n\t\tcvReleaseMat(&P2_2);\r\n\t\tcvReleaseMat(&P2_3);\r\n\t\tcvReleaseMat(&temp14_1);\r\n\t\tcvReleaseMat(&x);\r\n\t}\r\n}\r\n\r\n\r\nint LinearTriangulation(CvMat *x1, CvMat *P1, CvMat *x2, CvMat *P2, vector<int> featureID, CvMat &X, vector<int> &filteredFeatureID)\r\n{\r\n\t//X = *cvCreateMat(x1->rows, 3, CV_32FC1);\r\n\t//cvSetZero(&X);\r\n\tvector<double> X1, X2, X3;\r\n\tfilteredFeatureID.clear();\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tCvMat *A = cvCreateMat(4, 4, CV_32FC1);\r\n\t\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A4 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tGetSubMatRowwise(P1, 0, 0, P1_1);\r\n\t\tGetSubMatRowwise(P1, 1, 1, P1_2);\r\n\t\tGetSubMatRowwise(P1, 2, 2, P1_3);\r\n\t\tGetSubMatRowwise(P2, 0, 0, P2_1);\r\n\t\tGetSubMatRowwise(P2, 1, 1, P2_2);\r\n\t\tGetSubMatRowwise(P2, 2, 2, P2_3);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P1_1, A1);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P1_2, A2);\r\n\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P2_1, A3);\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P2_2, A4);\r\n\t\tSetSubMat(A, 0, 0, A1);\r\n\t\tSetSubMat(A, 1, 0, A2);\r\n\t\tSetSubMat(A, 2, 0, A3);\r\n\t\tSetSubMat(A, 3, 0, A4);\r\n\r\n\t\tCvMat x;\r\n\t\tLS_homogeneous(A, x);\r\n\t\t\r\n\t\tdouble v = cvGetReal2D(&x, 3, 0);\r\n\t\t//cout << v  << \" \" << abs(v)<< endl;\r\n\t\tif (abs(v) < POINT_AT_INFINITY_ZERO)\r\n\t\t\tcontinue;\r\n\t\tX1.push_back(cvGetReal2D(&x, 0, 0)/v);\r\n\t\tX2.push_back(cvGetReal2D(&x, 1, 0)/v);\r\n\t\tX3.push_back(cvGetReal2D(&x, 2, 0)/v);\r\n\t\tfilteredFeatureID.push_back(featureID[ix]);\r\n\r\n\t\tcvReleaseMat(&A);\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A3);\r\n\t\tcvReleaseMat(&A4);\r\n\t\tcvReleaseMat(&P1_1);\r\n\t\tcvReleaseMat(&P1_2);\r\n\t\tcvReleaseMat(&P1_3);\r\n\t\tcvReleaseMat(&P2_1);\r\n\t\tcvReleaseMat(&P2_2);\r\n\t\tcvReleaseMat(&P2_3);\r\n\t\tcvReleaseMat(&temp14_1);\r\n\t}\r\n\r\n\tif (X1.size() == 0)\r\n\t\treturn 0;\r\n\r\n\tX = *cvCreateMat(X1.size(), 3, CV_32FC1);\r\n\tfor (int i = 0; i < X1.size(); i++)\r\n\t{\r\n\t\tcvSetReal2D(&X, i, 0, X1[i]);\r\n\t\tcvSetReal2D(&X, i, 1, X2[i]);\r\n\t\tcvSetReal2D(&X, i, 2, X3[i]);\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint LinearTriangulation_mem(CvMat *x1, CvMat *P1, CvMat *x2, CvMat *P2, vector<int> featureID, vector<vector<double> > &X, vector<int> &filteredFeatureID)\r\n{\r\n\tvector<double> X1, X2, X3;\r\n\tfilteredFeatureID.clear();\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tCvMat *A = cvCreateMat(4, 4, CV_32FC1);\r\n\t\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A4 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *P2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\t\tGetSubMatRowwise(P1, 0, 0, P1_1);\r\n\t\tGetSubMatRowwise(P1, 1, 1, P1_2);\r\n\t\tGetSubMatRowwise(P1, 2, 2, P1_3);\r\n\t\tGetSubMatRowwise(P2, 0, 0, P2_1);\r\n\t\tGetSubMatRowwise(P2, 1, 1, P2_2);\r\n\t\tGetSubMatRowwise(P2, 2, 2, P2_3);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P1_1, A1);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P1_2, A2);\r\n\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P2_1, A3);\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P2_2, A4);\r\n\t\tSetSubMat(A, 0, 0, A1);\r\n\t\tSetSubMat(A, 1, 0, A2);\r\n\t\tSetSubMat(A, 2, 0, A3);\r\n\t\tSetSubMat(A, 3, 0, A4);\r\n\r\n\t\tCvMat *x = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\t\tLS_homogeneous(A, x);\r\n\r\n\t\tdouble v = cvGetReal2D(x, 3, 0);\r\n\t\tif (abs(v) < POINT_AT_INFINITY_ZERO)\r\n\t\t{\r\n\t\t\tcvReleaseMat(&A);\r\n\t\t\tcvReleaseMat(&A1);\r\n\t\t\tcvReleaseMat(&A2);\r\n\t\t\tcvReleaseMat(&A3);\r\n\t\t\tcvReleaseMat(&A4);\r\n\t\t\tcvReleaseMat(&P1_1);\r\n\t\t\tcvReleaseMat(&P1_2);\r\n\t\t\tcvReleaseMat(&P1_3);\r\n\t\t\tcvReleaseMat(&P2_1);\r\n\t\t\tcvReleaseMat(&P2_2);\r\n\t\t\tcvReleaseMat(&P2_3);\r\n\t\t\tcvReleaseMat(&temp14_1);\r\n\t\t\tcvReleaseMat(&x);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tX1.push_back(cvGetReal2D(x, 0, 0)/v);\r\n\t\tX2.push_back(cvGetReal2D(x, 1, 0)/v);\r\n\t\tX3.push_back(cvGetReal2D(x, 2, 0)/v);\r\n\t\tfilteredFeatureID.push_back(featureID[ix]);\r\n\r\n\t\tcvReleaseMat(&A);\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A3);\r\n\t\tcvReleaseMat(&A4);\r\n\t\tcvReleaseMat(&P1_1);\r\n\t\tcvReleaseMat(&P1_2);\r\n\t\tcvReleaseMat(&P1_3);\r\n\t\tcvReleaseMat(&P2_1);\r\n\t\tcvReleaseMat(&P2_2);\r\n\t\tcvReleaseMat(&P2_3);\r\n\t\tcvReleaseMat(&temp14_1);\r\n\t\tcvReleaseMat(&x);\r\n\t}\r\n\r\n\tif (X1.size() == 0)\r\n\t\treturn 0;\r\n\r\n\tfor (int i = 0; i < X1.size(); i++)\r\n\t{\r\n\t\tvector<double> X_vec;\r\n\t\tX_vec.push_back(X1[i]);\r\n\t\tX_vec.push_back(X2[i]);\r\n\t\tX_vec.push_back(X3[i]);\r\n\t\tX.push_back(X_vec);\r\n\t}\r\n\treturn X.size();\r\n}\r\n\r\nint LinearTriangulation_mem_fast(CvMat *x1, CvMat *P1, CvMat *x2, CvMat *P2, vector<int> &featureID, vector<vector<double> > &X, vector<int> &filteredFeatureID)\r\n{\r\n\tfilteredFeatureID.clear();\r\n\tCvMat *A = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *A3 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *A4 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P1_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P2_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\r\n\tfor (int ix = 0; ix < x1->rows; ix++)\r\n\t{\r\n\t\tGetSubMatRowwise(P1, 0, 0, P1_1);\r\n\t\tGetSubMatRowwise(P1, 1, 1, P1_2);\r\n\t\tGetSubMatRowwise(P1, 2, 2, P1_3);\r\n\t\tGetSubMatRowwise(P2, 0, 0, P2_1);\r\n\t\tGetSubMatRowwise(P2, 1, 1, P2_2);\r\n\t\tGetSubMatRowwise(P2, 2, 2, P2_3);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P1_1, A1);\r\n\r\n\t\tScalarMul(P1_3, cvGetReal2D(x1, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P1_2, A2);\r\n\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 0), temp14_1);\r\n\t\tcvSub(temp14_1, P2_1, A3);\r\n\t\tScalarMul(P2_3, cvGetReal2D(x2, ix, 1), temp14_1);\r\n\t\tcvSub(temp14_1, P2_2, A4);\r\n\t\tSetSubMat(A, 0, 0, A1);\r\n\t\tSetSubMat(A, 1, 0, A2);\r\n\t\tSetSubMat(A, 2, 0, A3);\r\n\t\tSetSubMat(A, 3, 0, A4);\r\n\r\n\t\tLS_homogeneous(A, x);\r\n\r\n\t\tdouble v = cvGetReal2D(x, 3, 0);\r\n\t\tif (abs(v) < POINT_AT_INFINITY_ZERO)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvector<double> X_vec;\r\n\t\tX_vec.push_back(cvGetReal2D(x, 0, 0)/v);\r\n\t\tX_vec.push_back(cvGetReal2D(x, 1, 0)/v);\r\n\t\tX_vec.push_back(cvGetReal2D(x, 2, 0)/v);\r\n\t\tX.push_back(X_vec);\r\n\t\tfilteredFeatureID.push_back(featureID[ix]);\r\n\t}\r\n\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&A1);\r\n\tcvReleaseMat(&A2);\r\n\tcvReleaseMat(&A3);\r\n\tcvReleaseMat(&A4);\r\n\tcvReleaseMat(&P1_1);\r\n\tcvReleaseMat(&P1_2);\r\n\tcvReleaseMat(&P1_3);\r\n\tcvReleaseMat(&P2_1);\r\n\tcvReleaseMat(&P2_2);\r\n\tcvReleaseMat(&P2_3);\r\n\tcvReleaseMat(&temp14_1);\r\n\tcvReleaseMat(&x);\r\n\r\n\tif (filteredFeatureID.size() == 0)\r\n\t\treturn 0;\r\n\r\n\treturn X.size();\r\n}\r\n\r\nbool LinearTriangulation(vector<CvMat *> vP, vector<double> vx, vector<double> vy, double &X, double &Y, double &Z)\r\n{\r\n\tif (vP.size() < 2)\r\n\t\treturn false;\r\n\r\n\tCvMat *A = cvCreateMat(2*vP.size(), 4, CV_32FC1);\r\n\tCvMat *A1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *A2 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *P_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\r\n\tCvMat *temp14_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\t\r\n\tfor (int iP = 0; iP < vP.size(); iP++)\r\n\t{\r\n\t\tGetSubMatRowwise(vP[iP], 0, 0, P_1);\r\n\t\tGetSubMatRowwise(vP[iP], 1, 1, P_2);\r\n\t\tGetSubMatRowwise(vP[iP], 2, 2, P_3);\r\n\r\n\t\tScalarMul(P_3, vx[iP], temp14_1);\r\n\t\tcvSub(temp14_1, P_1, A1);\r\n\r\n\t\tScalarMul(P_3, vy[iP], temp14_1);\r\n\t\tcvSub(temp14_1, P_2, A2);\r\n\r\n\t\tSetSubMat(A, 2*iP, 0, A1);\r\n\t\tSetSubMat(A, 2*iP+1, 0, A2);\r\n\t}\r\n\r\n\tLS_homogeneous(A, x);\r\n\r\n\tCvMat *Ax = cvCreateMat(A->rows, 1, CV_32FC1);\r\n\tcvMatMul(A, x, Ax);\r\n\t//PrintMat(Ax);\r\n\r\n\tdouble v = cvGetReal2D(x, 3, 0);\r\n\tif (abs(v) < POINT_AT_INFINITY_ZERO)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tX = cvGetReal2D(x, 0, 0)/v;\r\n\tY = cvGetReal2D(x, 1, 0)/v;\r\n\tZ = cvGetReal2D(x, 2, 0)/v;\r\n\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&A1);\r\n\tcvReleaseMat(&A2);\r\n\tcvReleaseMat(&P_1);\r\n\tcvReleaseMat(&P_2);\r\n\tcvReleaseMat(&P_3);\r\n\tcvReleaseMat(&temp14_1);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\nint DLT_ExtrinsicCameraParamEstimation(CvMat *X, CvMat *x, CvMat *K, CvMat *P)\r\n{\r\n\tif (X->rows < 6)\r\n\t\treturn 0;\r\n\r\n\tCvMat *Xtilde = cvCreateMat(X->rows, 3, CV_32FC1);\r\n\tCvMat *xtilde = cvCreateMat(x->rows, 2, CV_32FC1);\r\n\tCvMat *U = cvCreateMat(4,4, CV_32FC1);\r\n\tCvMat *T = cvCreateMat(3,3, CV_32FC1);\r\n\r\n\tNormalization3D(X, Xtilde, U);\r\n\tNormalization(x, xtilde, T);\r\n\r\n\r\n\tCvMat *A = cvCreateMat(X->rows*2,12,CV_32FC1);\r\n\tfor (int iX = 0; iX < X->rows; iX++)\r\n\t{\r\n\t\tCvMat *A1 = cvCreateMat(1, 12, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 12, CV_32FC1);\r\n\t\tcvSetZero(A1);\tcvSetZero(A2);\r\n\t\tCvMat *A1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\t// A1_2\r\n\t\tcvSetReal2D(A1_2, 0, 0, -cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A1_2, 0, 1, -cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A1_2, 0, 2, -cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A1_2, 0, 3, -1);\r\n\t\t\r\n\t\t// A1_3\r\n\t\tcvSetReal2D(A1_3, 0, 0, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A1_3, 0, 1, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A1_3, 0, 2, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A1_3, 0, 3, cvGetReal2D(xtilde, iX, 1));\r\n\r\n\t\t// A2_1\r\n\t\tcvSetReal2D(A2_1, 0, 0, cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A2_1, 0, 1, cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A2_1, 0, 2, cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A2_1, 0, 3, 1);\r\n\t\t// A1_3\r\n\t\tcvSetReal2D(A2_3, 0, 0, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A2_3, 0, 1, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A2_3, 0, 2, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A2_3, 0, 3, -cvGetReal2D(xtilde, iX, 0));\r\n\t\tSetSubMat(A1, 0, 4, A1_2);\tSetSubMat(A1, 0, 8, A1_3);\r\n\t\tSetSubMat(A2, 0, 0, A2_1);\tSetSubMat(A2, 0, 8, A2_3);\r\n\t\t\r\n\t\tSetSubMat(A, 2*iX, 0, A1);\r\n\t\tSetSubMat(A, 2*iX+1, 0, A2);\r\n\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A1_2);\r\n\t\tcvReleaseMat(&A1_3);\r\n\t\tcvReleaseMat(&A2_1);\r\n\t\tcvReleaseMat(&A2_3);\r\n\t}\r\n\tCvMat *p = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\tLS_homogeneous(A, p);\r\n\r\n\tcvSetReal2D(P, 0, 0, cvGetReal2D(p, 0, 0));\tcvSetReal2D(P, 0, 1, cvGetReal2D(p, 1, 0));\tcvSetReal2D(P, 0, 2, cvGetReal2D(p, 2, 0));\tcvSetReal2D(P, 0, 3, cvGetReal2D(p, 3, 0));\r\n\tcvSetReal2D(P, 1, 0, cvGetReal2D(p, 4, 0));\tcvSetReal2D(P, 1, 1, cvGetReal2D(p, 5, 0));\tcvSetReal2D(P, 1, 2, cvGetReal2D(p, 6, 0));\tcvSetReal2D(P, 1, 3, cvGetReal2D(p, 7, 0));\r\n\tcvSetReal2D(P, 2, 0, cvGetReal2D(p, 8, 0));\tcvSetReal2D(P, 2, 1, cvGetReal2D(p, 9, 0));\tcvSetReal2D(P, 2, 2, cvGetReal2D(p, 10, 0));\tcvSetReal2D(P, 2, 3, cvGetReal2D(p, 11, 0));\r\n\r\n\tCvMat *temp34 = cvCreateMat(3,4,CV_32FC1);\r\n\tCvMat *invT = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(T, invT);\r\n\tcvMatMul(invT, P, temp34);\r\n\tcvMatMul(temp34, U, P);\r\n\r\n\tCvMat *P_ = cvCreateMat(3,4, CV_32FC1);\r\n\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K, invK);\r\n\tcvMatMul(invK, P, P_);\r\n\tCvMat *P1 = cvCreateMat(3,1,CV_32FC1);\r\n\tGetSubMatColwise(P_, 0, 0, P1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tGetSubMatColwise(P_, 0, 2, R);\r\n\tdouble norm = NormL2(P1);\r\n\tdouble determinant = cvDet(R);\r\n\tdouble sign = 1;\r\n\tif (determinant < 0)\r\n\t\tsign = -1;\r\n\tScalarMul(P_,sign/norm, P);\r\n\tcvMatMul(K, P, P);\r\n\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&invT);\r\n\tcvReleaseMat(&P_);\r\n\tcvReleaseMat(&invK);\r\n\tcvReleaseMat(&P1);\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&Xtilde);\r\n\tcvReleaseMat(&xtilde);\r\n\tcvReleaseMat(&U);\r\n\tcvReleaseMat(&T);\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&p);\r\n\treturn 1;\r\n}\r\n\r\nint EPNP_ExtrinsicCameraParamEstimation(CvMat *X, CvMat *x, CvMat *K, CvMat *P)\r\n{\r\n\tepnp PnP;\r\n\r\n\tPnP.set_internal_parameters(cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2), cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1));\r\n\tPnP.set_maximum_number_of_correspondences(X->rows);\r\n\tPnP.reset_correspondences();\r\n\tfor(int i = 0; i < X->rows; i++) {\r\n\t\tPnP.add_correspondence(cvGetReal2D(X, i, 0), cvGetReal2D(X, i, 1), cvGetReal2D(X, i, 2), cvGetReal2D(x, i, 0), cvGetReal2D(x, i, 1));\r\n\t}\r\n\r\n\tdouble R_est[3][3], t_est[3];\r\n\tdouble err2 = PnP.compute_pose(R_est, t_est);\r\n\r\n\tcvSetReal2D(P, 0, 3, t_est[0]);\r\n\tcvSetReal2D(P, 1, 3, t_est[1]);\r\n\tcvSetReal2D(P, 2, 3, t_est[2]);\r\n\r\n\tcvSetReal2D(P, 0, 0, R_est[0][0]);\t\tcvSetReal2D(P, 0, 1, R_est[0][1]);\t\tcvSetReal2D(P, 0, 2, R_est[0][2]);\r\n\tcvSetReal2D(P, 1, 0, R_est[1][0]);\t\tcvSetReal2D(P, 1, 1, R_est[1][1]);\t\tcvSetReal2D(P, 1, 2, R_est[1][2]);\r\n\tcvSetReal2D(P, 2, 0, R_est[2][0]);\t\tcvSetReal2D(P, 2, 1, R_est[2][1]);\t\tcvSetReal2D(P, 2, 2, R_est[2][2]);\r\n\tcvMatMul(K, P, P);\r\n\r\n\treturn 1;\r\n}\r\n\r\n\r\n\r\n\r\nint DLT_ExtrinsicCameraParamEstimation_KRT(CvMat *X, CvMat *x, CvMat *K, CvMat *P)\r\n{\r\n\tif (X->rows < 6)\r\n\t\treturn 0;\r\n\r\n\tCvMat *Xtilde = cvCreateMat(X->rows, 3, CV_32FC1);\r\n\tCvMat *xtilde = cvCreateMat(x->rows, 2, CV_32FC1);\r\n\tCvMat *U = cvCreateMat(4,4, CV_32FC1);\r\n\tCvMat *T = cvCreateMat(3,3, CV_32FC1);\r\n\r\n\tNormalization3D(X, Xtilde, U);\r\n\tNormalization(x, xtilde, T);\r\n\r\n\r\n\tCvMat *A = cvCreateMat(X->rows*2,12,CV_32FC1);\r\n\tfor (int iX = 0; iX < X->rows; iX++)\r\n\t{\r\n\t\tCvMat *A1 = cvCreateMat(1, 12, CV_32FC1);\r\n\t\tCvMat *A2 = cvCreateMat(1, 12, CV_32FC1);\r\n\t\tcvSetZero(A1);\tcvSetZero(A2);\r\n\t\tCvMat *A1_2 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A1_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2_1 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\tCvMat *A2_3 = cvCreateMat(1, 4, CV_32FC1);\r\n\t\t// A1_2\r\n\t\tcvSetReal2D(A1_2, 0, 0, -cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A1_2, 0, 1, -cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A1_2, 0, 2, -cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A1_2, 0, 3, -1);\r\n\r\n\t\t// A1_3\r\n\t\tcvSetReal2D(A1_3, 0, 0, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A1_3, 0, 1, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A1_3, 0, 2, cvGetReal2D(xtilde, iX, 1)*cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A1_3, 0, 3, cvGetReal2D(xtilde, iX, 1));\r\n\r\n\t\t// A2_1\r\n\t\tcvSetReal2D(A2_1, 0, 0, cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A2_1, 0, 1, cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A2_1, 0, 2, cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A2_1, 0, 3, 1);\r\n\t\t// A1_3\r\n\t\tcvSetReal2D(A2_3, 0, 0, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 0));\t\r\n\t\tcvSetReal2D(A2_3, 0, 1, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 1));\r\n\t\tcvSetReal2D(A2_3, 0, 2, -cvGetReal2D(xtilde, iX, 0)*cvGetReal2D(Xtilde, iX, 2));\r\n\t\tcvSetReal2D(A2_3, 0, 3, -cvGetReal2D(xtilde, iX, 0));\r\n\t\tSetSubMat(A1, 0, 4, A1_2);\tSetSubMat(A1, 0, 8, A1_3);\r\n\t\tSetSubMat(A2, 0, 0, A2_1);\tSetSubMat(A2, 0, 8, A2_3);\r\n\r\n\t\tSetSubMat(A, 2*iX, 0, A1);\r\n\t\tSetSubMat(A, 2*iX+1, 0, A2);\r\n\r\n\t\tcvReleaseMat(&A1);\r\n\t\tcvReleaseMat(&A2);\r\n\t\tcvReleaseMat(&A1_2);\r\n\t\tcvReleaseMat(&A1_3);\r\n\t\tcvReleaseMat(&A2_1);\r\n\t\tcvReleaseMat(&A2_3);\r\n\t}\r\n\tCvMat *p = cvCreateMat(A->cols, 1, CV_32FC1);\r\n\tLS_homogeneous(A, p);\r\n\r\n\tcvSetReal2D(P, 0, 0, cvGetReal2D(p, 0, 0));\tcvSetReal2D(P, 0, 1, cvGetReal2D(p, 1, 0));\tcvSetReal2D(P, 0, 2, cvGetReal2D(p, 2, 0));\tcvSetReal2D(P, 0, 3, cvGetReal2D(p, 3, 0));\r\n\tcvSetReal2D(P, 1, 0, cvGetReal2D(p, 4, 0));\tcvSetReal2D(P, 1, 1, cvGetReal2D(p, 5, 0));\tcvSetReal2D(P, 1, 2, cvGetReal2D(p, 6, 0));\tcvSetReal2D(P, 1, 3, cvGetReal2D(p, 7, 0));\r\n\tcvSetReal2D(P, 2, 0, cvGetReal2D(p, 8, 0));\tcvSetReal2D(P, 2, 1, cvGetReal2D(p, 9, 0));\tcvSetReal2D(P, 2, 2, cvGetReal2D(p, 10, 0));\tcvSetReal2D(P, 2, 3, cvGetReal2D(p, 11, 0));\r\n\r\n\t//for (int i = 0; i < X->rows; i++)\r\n\t//{\r\n\t//\tCvMat *tX = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tcvSetReal2D(tX, 0, 0, cvGetReal2D(Xtilde, i, 0));\r\n\t//\tcvSetReal2D(tX, 1, 0, cvGetReal2D(Xtilde, i, 1));\r\n\t//\tcvSetReal2D(tX, 2, 0, cvGetReal2D(Xtilde, i, 2));\r\n\t//\tcvSetReal2D(tX, 3, 0, 1);\r\n\t//\tCvMat *tx = cvCreateMat(3,1, CV_32FC1);\r\n\t//\tcvMatMul(P, tX, tx);\r\n\t//\tScalarMul(tx, 1/cvGetReal2D(tx, 2, 0), tx);\r\n\t//\tPrintMat(tx, \"tx\");\r\n\t//\tCvMat *ttx = cvCreateMat(2,1,CV_32FC1);\r\n\t//\tcvSetReal2D(ttx, 0, 0, cvGetReal2D(xtilde, i, 0));\r\n\t//\tcvSetReal2D(ttx, 1, 0, cvGetReal2D(xtilde, i, 1));\r\n\t//\tPrintMat(ttx, \"ttx\");\r\n\t//}\r\n\r\n\tCvMat *temp34 = cvCreateMat(3,4,CV_32FC1);\r\n\tCvMat *invT = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(T, invT);\r\n\tcvMatMul(invT, P, temp34);\r\n\tcvMatMul(temp34, U, P);\r\n\r\n\tScalarMul(P, 1/cvGetReal2D(P, 2, 3), P);\r\n\t\r\n\tCvMat *R = cvCreateMat(3,3, CV_32FC1);\r\n\tCvMat *C = cvCreateMat(4,1, CV_32FC1);\r\n\t//ScalarMul(P, -1, P);\r\n\tcvDecomposeProjectionMatrix(P, K, R, C);\r\n\t//cout << \"det \" << cvDet(R) << endl;\r\n\t//PrintMat(C, \"C\");\r\n\r\n\t//CvMat *P_ = cvCreateMat(3,4, CV_32FC1);\r\n\t//CvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvInvert(K, invK);\r\n\t//cvMatMul(invK, P, P_);\r\n\t//CvMat *P1 = cvCreateMat(3,1,CV_32FC1);\r\n\t//GetSubMatColwise(P_, 0, 0, P1);\r\n\t//CvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t//GetSubMatColwise(P_, 0, 2, R);\r\n\t//double norm = NormL2(P1);\r\n\t//double determinant = cvDet(R);\r\n\t//double sign = 1;\r\n\t//if (determinant < 0)\r\n\t//\tsign = -1;\r\n\t//ScalarMul(P_,sign/norm, P);\r\n\t//cvMatMul(K, P, P);\r\n\r\n\tcvReleaseMat(&temp34);\r\n\tcvReleaseMat(&invT);\r\n\t//cvReleaseMat(&P_);\r\n\t//cvReleaseMat(&invK);\r\n\t//cvReleaseMat(&P1);\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&Xtilde);\r\n\tcvReleaseMat(&xtilde);\r\n\tcvReleaseMat(&U);\r\n\tcvReleaseMat(&T);\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&p);\r\n\tcvReleaseMat(&C);\r\n\treturn 1;\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac(CvMat *X, CvMat *x, CvMat *K, CvMat &P, double ransacThreshold, int ransacMaxIter)\r\n{\r\n\tint min_set = 5;\r\n\tif (X->rows < min_set)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vInlierIndex, vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\t\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tint nIter = 0;\r\n\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\r\n\t\tnIter++;\r\n\t\tif (nIter > 1e+4)\r\n\t\t\treturn 0;\r\n\t\tint *randIdx = (int *) malloc(min_set * sizeof(int));\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tCvMat *randx = cvCreateMat(min_set, 2, CV_32FC1);\r\n\t\tCvMat *randX = cvCreateMat(min_set, 3, CV_32FC1);\r\n\t\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\tfree(randIdx);\r\n\r\n\t\tDLT_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\r\n\t\tCvMat *H = cvCreateMat(4, 4, CV_32FC1); CvMat *HX = cvCreateMat(randX->rows, randX->cols, CV_32FC1);\r\n\t\tcvSetIdentity(H);\r\n\t\tSetSubMat(H, 0, 0, randP);\r\n\t\tPxx_inhomo(H, randX, HX);\r\n\r\n\t\tbool isFront = true;\r\n\t\tfor (int i = 0; i < min_set; i++)\r\n\t\t{\r\n\t\t\tif (cvGetReal2D(HX, i, 2) < 0)\r\n\t\t\t\tisFront = false;\r\n\t\t}\r\n\t\tcvReleaseMat(&H);\r\n\t\tcvReleaseMat(&HX);\r\n\r\n\t\tif (!isFront)\r\n\t\t{\r\n\t\t\tcvReleaseMat(&randx);\r\n\t\t\tcvReleaseMat(&randX);\r\n\t\t\tcvReleaseMat(&randP);\r\n\t\t\tiRansacIter--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\tfor (int ip = 0; ip < X->rows; ip++)\r\n\t\t{\r\n\t\t\tCvMat *reproj = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tCvMat *homo_X = cvCreateMat(4,1,CV_32FC1);\r\n\t\t\tcvSetReal2D(homo_X, 0, 0, cvGetReal2D(X, ip, 0));\r\n\t\t\tcvSetReal2D(homo_X, 1, 0, cvGetReal2D(X, ip, 1));\r\n\t\t\tcvSetReal2D(homo_X, 2, 0, cvGetReal2D(X, ip, 2));\r\n\t\t\tcvSetReal2D(homo_X, 3, 0, 1);\r\n\r\n\t\t\tcvMatMul(randP, homo_X, reproj);\r\n\t\t\tdouble u = cvGetReal2D(reproj, 0, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble v = cvGetReal2D(reproj, 1, 0)/cvGetReal2D(reproj, 2, 0);\r\n\r\n\t\t\t//if ((ip == randIdx[0]) || (ip == randIdx[1]) || (ip == randIdx[2]) || (ip == randIdx[3]))\r\n\t\t\t//\tcout << cvGetReal2D(x, ip, 0) << \" \" << u << \" \" << cvGetReal2D(x, ip, 1) << \" \" << v << endl;\r\n\t\t\tdouble dist = (u-cvGetReal2D(x, ip, 0))*(u-cvGetReal2D(x, ip, 0))+(v-cvGetReal2D(x, ip, 1))*(v-cvGetReal2D(x, ip, 1));\r\n\t\t\tif (dist < ransacThreshold)\r\n\t\t\t{\r\n\t\t\t\tvInlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvOutlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\tcvReleaseMat(&reproj);\r\n\t\t\tcvReleaseMat(&homo_X);\r\n\t\t}\r\n\r\n\r\n\t\t// Distance function\r\n\t\t//CvMat *x_ = cvCreateMat(3, X->rows, CV_32FC1);\r\n\t\t//CvMat *e = cvCreateMat(3, X->rows, CV_32FC1);\r\n\t\t//cvMatMul(randP, X_homoT, x_);\r\n\t\t//NormalizingByRow(x_, 2);\r\n\t\t//cvSub(x_homoT, x_, e);\r\n\t\t//for (int ie = 0; ie < e->cols; ie++)\r\n\t\t//{\r\n\t\t//\tCvMat *ei = cvCreateMat(3,1,CV_32FC1);\r\n\t\t//\tCvMat *xi = cvCreateMat(3,1, CV_32FC1);\r\n\t\t//\tGetSubMatColwise(x_homoT, ie, ie, xi);\r\n\t\t//\tGetSubMatColwise(e, ie, ie, ei);\r\n\t\t//\tdouble norm = NormL2(ei);\r\n\t\t//\tdouble denorm = NormL2(xi);\r\n\t\t//\tdouble d = norm;\r\n\t\t//\tif (d < ransacThreshold)\r\n\t\t//\t\tvInlier.push_back(ie);\r\n\t\t//\telse\r\n\t\t//\t\tvOutlier.push_back(ie);\r\n\t\t//\tcvReleaseMat(&ei);\r\n\t\t//\tcvReleaseMat(&xi);\r\n\t\t//}\r\n\r\n\t\t//if (vInlier.size() > maxInlier)\r\n\t\t//{\r\n\t\t//\tmaxInlier = vInlier.size();\r\n\t\t//\tP = *cvCloneMat(randP);\r\n\t\t//\tvInlierIndex = vInlier;\r\n\t\t//\tvOutlierIndex = vOutlier;\r\n\t\t//}\r\n\t\t//cvReleaseMat(&x_);\r\n\t\t//cvReleaseMat(&e);\r\n\t\tcvReleaseMat(&randx);\r\n\t\tcvReleaseMat(&randX);\r\n\t\tcvReleaseMat(&randP);\r\n\t}\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tif (vInlierIndex.size() < min_set)\r\n\t\treturn 0;\r\n\tcout << \"Number of features to do DLT camera pose estimation: \" << vInlierIndex.size() << endl;\r\n\treturn 1;\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_EPNP(CvMat *X, CvMat *x, CvMat *K, CvMat &P, double ransacThreshold, int ransacMaxIter)\r\n{\r\n\tint min_set = 4;\r\n\tif (X->rows < min_set)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vInlierIndex, vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\r\n\t\tint *randIdx = (int *) malloc(min_set * sizeof(int));\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tCvMat *randx = cvCreateMat(min_set, 2, CV_32FC1);\r\n\t\tCvMat *randX = cvCreateMat(min_set, 3, CV_32FC1);\r\n\t\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\t\r\n\r\n\t\t//DLT_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\t\tEPNP_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\tfor (int ip = 0; ip < X->rows; ip++)\r\n\t\t{\r\n\t\t\tCvMat *reproj = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tCvMat *homo_X = cvCreateMat(4,1,CV_32FC1);\r\n\t\t\tcvSetReal2D(homo_X, 0, 0, cvGetReal2D(X, ip, 0));\r\n\t\t\tcvSetReal2D(homo_X, 1, 0, cvGetReal2D(X, ip, 1));\r\n\t\t\tcvSetReal2D(homo_X, 2, 0, cvGetReal2D(X, ip, 2));\r\n\t\t\tcvSetReal2D(homo_X, 3, 0, 1);\r\n\r\n\t\t\tcvMatMul(randP, homo_X, reproj);\r\n\t\t\tdouble u = cvGetReal2D(reproj, 0, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble v = cvGetReal2D(reproj, 1, 0)/cvGetReal2D(reproj, 2, 0);\r\n\r\n\t\t\t//if ((ip == randIdx[0]) || (ip == randIdx[1]) || (ip == randIdx[2]) || (ip == randIdx[3]))\r\n\t\t\t//\tcout << cvGetReal2D(x, ip, 0) << \" \" << u << \" \" << cvGetReal2D(x, ip, 1) << \" \" << v << endl;\r\n\t\t\tdouble dist = (u-cvGetReal2D(x, ip, 0))*(u-cvGetReal2D(x, ip, 0))+(v-cvGetReal2D(x, ip, 1))*(v-cvGetReal2D(x, ip, 1));\r\n\t\t\tif (dist < ransacThreshold)\r\n\t\t\t{\r\n\t\t\t\tvInlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvOutlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\tcvReleaseMat(&reproj);\r\n\t\t\tcvReleaseMat(&homo_X);\r\n\t\t}\r\n\t\tfree(randIdx);\r\n\r\n\t\tif (vInlier.size() > maxInlier)\r\n\t\t{\r\n\t\t\tmaxInlier = vInlier.size();\r\n\t\t\tP = *cvCloneMat(randP);\r\n\t\t\tvInlierIndex = vInlier;\r\n\t\t\tvOutlierIndex = vOutlier;\r\n\t\t}\r\n\t\tcvReleaseMat(&randx);\r\n\t\tcvReleaseMat(&randX);\r\n\t\tcvReleaseMat(&randP);\r\n\t}\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tif (vInlierIndex.size() < 20)\r\n\t\treturn 0;\r\n\tcout << \"Number of features to do DLT camera pose estimation: \" << vInlierIndex.size() << endl;\r\n\treturn 1;\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_EPNP_mem(CvMat *X, CvMat *x, CvMat *K, CvMat *P, double ransacThreshold, int ransacMaxIter)\r\n{\r\n\tint min_set = 4;\r\n\tif (X->rows < min_set)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vInlierIndex, vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tCvMat *randx = cvCreateMat(min_set, 2, CV_32FC1);\r\n\tCvMat *randX = cvCreateMat(min_set, 3, CV_32FC1);\r\n\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\tint *randIdx = (int *) malloc(min_set * sizeof(int));\r\n\r\n\tCvMat *reproj = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *homo_X = cvCreateMat(4,1,CV_32FC1);\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\t\t\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\tEPNP_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\tfor (int ip = 0; ip < X->rows; ip++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(homo_X, 0, 0, cvGetReal2D(X, ip, 0));\r\n\t\t\tcvSetReal2D(homo_X, 1, 0, cvGetReal2D(X, ip, 1));\r\n\t\t\tcvSetReal2D(homo_X, 2, 0, cvGetReal2D(X, ip, 2));\r\n\t\t\tcvSetReal2D(homo_X, 3, 0, 1);\r\n\r\n\t\t\tcvMatMul(randP, homo_X, reproj);\r\n\t\t\tdouble u = cvGetReal2D(reproj, 0, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble v = cvGetReal2D(reproj, 1, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble dist = sqrt((u-cvGetReal2D(x, ip, 0))*(u-cvGetReal2D(x, ip, 0))+(v-cvGetReal2D(x, ip, 1))*(v-cvGetReal2D(x, ip, 1)));\r\n\t\t\tif (dist < ransacThreshold)\r\n\t\t\t{\r\n\t\t\t\tvInlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvOutlier.push_back(ip);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\r\n\t\tif (vInlier.size() > maxInlier)\r\n\t\t{\r\n\t\t\tmaxInlier = vInlier.size();\r\n\t\t\tSetSubMat(P, 0, 0, randP);\r\n\t\t\tvInlierIndex = vInlier;\r\n\t\t\tvOutlierIndex = vOutlier;\r\n\t\t}\r\n\r\n\t\tif (vInlier.size() > X->rows * 0.8)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tCvMat *Xin = cvCreateMat(vInlierIndex.size(), 3, CV_32FC1);\r\n\tCvMat *xin = cvCreateMat(vInlierIndex.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierIndex.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(Xin, iInlier, 0, cvGetReal2D(X, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(Xin, iInlier, 1, cvGetReal2D(X, vInlierIndex[iInlier], 1));\r\n\t\tcvSetReal2D(Xin, iInlier, 2, cvGetReal2D(X, vInlierIndex[iInlier], 2));\r\n\r\n\t\tcvSetReal2D(xin, iInlier, 0, cvGetReal2D(x, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(xin, iInlier, 1, cvGetReal2D(x, vInlierIndex[iInlier], 1));\r\n\t}\r\n\tEPNP_ExtrinsicCameraParamEstimation(Xin, xin, K, P);\r\n\r\n\tcvReleaseMat(&Xin);\r\n\tcvReleaseMat(&xin);\r\n\tcvReleaseMat(&reproj);\r\n\tcvReleaseMat(&homo_X);\r\n\tfree(randIdx);\r\n\tcvReleaseMat(&randx);\r\n\tcvReleaseMat(&randX);\r\n\tcvReleaseMat(&randP);\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&x_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tif (vInlierIndex.size() < 40)\r\n\t\treturn 0;\r\n\tcout << \"Number of features ePnP: \" << vInlierIndex.size() << endl;\r\n\treturn vInlierIndex.size();\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_EPNP_mem_AD(CvMat *X, CvMat *x, CvMat *K, CvMat *P, double ransacThreshold, int ransacMaxIter, vector<int> &vInlier1)\r\n{\r\n\tint min_set = 4;\r\n\tif (X->rows < min_set)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vInlierIndex, vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tCvMat *randx = cvCreateMat(min_set, 2, CV_32FC1);\r\n\tCvMat *randX = cvCreateMat(min_set, 3, CV_32FC1);\r\n\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\tint *randIdx = (int *) malloc(min_set * sizeof(int));\r\n\r\n\tCvMat *reproj = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *homo_X = cvCreateMat(4,1,CV_32FC1);\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\t\t\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\tEPNP_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\tfor (int ip = 0; ip < X->rows; ip++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(homo_X, 0, 0, cvGetReal2D(X, ip, 0));\r\n\t\t\tcvSetReal2D(homo_X, 1, 0, cvGetReal2D(X, ip, 1));\r\n\t\t\tcvSetReal2D(homo_X, 2, 0, cvGetReal2D(X, ip, 2));\r\n\t\t\tcvSetReal2D(homo_X, 3, 0, 1);\r\n\r\n\t\t\tcvMatMul(randP, homo_X, reproj);\r\n\t\t\tdouble u = cvGetReal2D(reproj, 0, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble v = cvGetReal2D(reproj, 1, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble dist = sqrt((u-cvGetReal2D(x, ip, 0))*(u-cvGetReal2D(x, ip, 0))+(v-cvGetReal2D(x, ip, 1))*(v-cvGetReal2D(x, ip, 1)));\r\n\t\t\tif (dist < ransacThreshold)\r\n\t\t\t{\r\n\t\t\t\tvInlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvOutlier.push_back(ip);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\r\n\t\tif (vInlier.size() > maxInlier)\r\n\t\t{\r\n\t\t\tmaxInlier = vInlier.size();\r\n\t\t\tSetSubMat(P, 0, 0, randP);\r\n\t\t\tvInlierIndex = vInlier;\r\n\t\t\tvOutlierIndex = vOutlier;\r\n\t\t}\r\n\r\n\t\tif (vInlier.size() > X->rows * 0.8)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tCvMat *Xin = cvCreateMat(vInlierIndex.size(), 3, CV_32FC1);\r\n\tCvMat *xin = cvCreateMat(vInlierIndex.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierIndex.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(Xin, iInlier, 0, cvGetReal2D(X, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(Xin, iInlier, 1, cvGetReal2D(X, vInlierIndex[iInlier], 1));\r\n\t\tcvSetReal2D(Xin, iInlier, 2, cvGetReal2D(X, vInlierIndex[iInlier], 2));\r\n\r\n\t\tcvSetReal2D(xin, iInlier, 0, cvGetReal2D(x, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(xin, iInlier, 1, cvGetReal2D(x, vInlierIndex[iInlier], 1));\r\n\t}\r\n\tEPNP_ExtrinsicCameraParamEstimation(Xin, xin, K, P);\r\n\r\n\tcvReleaseMat(&Xin);\r\n\tcvReleaseMat(&xin);\r\n\tcvReleaseMat(&reproj);\r\n\tcvReleaseMat(&homo_X);\r\n\tfree(randIdx);\r\n\tcvReleaseMat(&randx);\r\n\tcvReleaseMat(&randX);\r\n\tcvReleaseMat(&randP);\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&x_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tvInlier1 = vInlierIndex;\r\n\tif (vInlierIndex.size() < 40)\r\n\t\treturn 0;\r\n\tcout << \"Number of features ePnP: \" << vInlierIndex.size() << endl;\r\n\treturn vInlierIndex.size();\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_EPNP_mem_abs(CvMat *X, CvMat *x, CvMat *K, CvMat *P, double ransacThreshold, int ransacMaxIter, vector<int> &vInlierIndex)\r\n{\r\n\tint min_set = 4;\r\n\tif (X->rows < min_set)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tCvMat *randx = cvCreateMat(min_set, 2, CV_32FC1);\r\n\tCvMat *randX = cvCreateMat(min_set, 3, CV_32FC1);\r\n\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\tint *randIdx = (int *) malloc(min_set * sizeof(int));\r\n\r\n\tCvMat *reproj = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *homo_X = cvCreateMat(4,1,CV_32FC1);\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\t\t\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tfor (int iIdx = 0; iIdx < min_set; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\tEPNP_ExtrinsicCameraParamEstimation(randX, randx, K, randP);\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\tfor (int ip = 0; ip < X->rows; ip++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(homo_X, 0, 0, cvGetReal2D(X, ip, 0));\r\n\t\t\tcvSetReal2D(homo_X, 1, 0, cvGetReal2D(X, ip, 1));\r\n\t\t\tcvSetReal2D(homo_X, 2, 0, cvGetReal2D(X, ip, 2));\r\n\t\t\tcvSetReal2D(homo_X, 3, 0, 1);\r\n\r\n\t\t\tcvMatMul(randP, homo_X, reproj);\r\n\t\t\tdouble u = cvGetReal2D(reproj, 0, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble v = cvGetReal2D(reproj, 1, 0)/cvGetReal2D(reproj, 2, 0);\r\n\t\t\tdouble dist = sqrt((u-cvGetReal2D(x, ip, 0))*(u-cvGetReal2D(x, ip, 0))+(v-cvGetReal2D(x, ip, 1))*(v-cvGetReal2D(x, ip, 1)));\r\n\t\t\tif (dist < ransacThreshold)\r\n\t\t\t{\r\n\t\t\t\tvInlier.push_back(ip);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvOutlier.push_back(ip);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\r\n\t\tif (vInlier.size() > maxInlier)\r\n\t\t{\r\n\t\t\tmaxInlier = vInlier.size();\r\n\t\t\tSetSubMat(P, 0, 0, randP);\r\n\t\t\tvInlierIndex = vInlier;\r\n\t\t\tvOutlierIndex = vOutlier;\r\n\t\t}\r\n\r\n\t\t//if (vInlier.size() > X->rows * 0.8)\r\n\t\t//{\r\n\t\t//\tbreak;\r\n\t\t//}\r\n\t}\r\n\r\n\tCvMat *Xin = cvCreateMat(vInlierIndex.size(), 3, CV_32FC1);\r\n\tCvMat *xin = cvCreateMat(vInlierIndex.size(), 2, CV_32FC1);\r\n\tfor (int iInlier = 0; iInlier < vInlierIndex.size(); iInlier++)\r\n\t{\r\n\t\tcvSetReal2D(Xin, iInlier, 0, cvGetReal2D(X, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(Xin, iInlier, 1, cvGetReal2D(X, vInlierIndex[iInlier], 1));\r\n\t\tcvSetReal2D(Xin, iInlier, 2, cvGetReal2D(X, vInlierIndex[iInlier], 2));\r\n\r\n\t\tcvSetReal2D(xin, iInlier, 0, cvGetReal2D(x, vInlierIndex[iInlier], 0));\r\n\t\tcvSetReal2D(xin, iInlier, 1, cvGetReal2D(x, vInlierIndex[iInlier], 1));\r\n\t}\r\n\tEPNP_ExtrinsicCameraParamEstimation(Xin, xin, K, P);\r\n\r\n\tcvReleaseMat(&Xin);\r\n\tcvReleaseMat(&xin);\r\n\tcvReleaseMat(&reproj);\r\n\tcvReleaseMat(&homo_X);\r\n\tfree(randIdx);\r\n\tcvReleaseMat(&randx);\r\n\tcvReleaseMat(&randX);\r\n\tcvReleaseMat(&randP);\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&x_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\t//if (vInlierIndex.size() < 20)\r\n\t//\treturn 0;\r\n\tcout << \"Number of features to do ePNP camera pose estimation: \" << vInlierIndex.size() << endl;\r\n\treturn vInlierIndex.size();\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_EPNP_face(CvMat *X, CvMat *x, CvMat *K, CvMat &P)\r\n{\r\n\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\tEPNP_ExtrinsicCameraParamEstimation(X, x, K, P_);\r\n\tP = *cvCloneMat(P_);\r\n\tcvReleaseMat(&P_);\r\n\treturn 1;\r\n}\r\n\r\n\r\nint DLT_ExtrinsicCameraParamEstimationWRansac_KRT(CvMat *X, CvMat *x, CvMat *K, CvMat &P, double ransacThreshold, int ransacMaxIter)\r\n{\r\n\tif (X->rows < 6)\r\n\t\treturn 0;\r\n\r\n\t/////////////////////////////////////////////////////////////////\r\n\t// Ransac\r\n\tvector<int> vInlierIndex, vOutlierIndex;\r\n\tvInlierIndex.clear();\r\n\tvOutlierIndex.clear();\r\n\r\n\tvector<int> vInlier, vOutlier;\r\n\tint maxInlier = 0;\r\n\r\n\tCvMat *X_homoT = cvCreateMat(4, X->rows, CV_32FC1);\r\n\tCvMat *X_homo = cvCreateMat(X->rows, 4, CV_32FC1);\r\n\tCvMat *x_homoT = cvCreateMat(3, x->rows, CV_32FC1);\r\n\tCvMat *x_homo = cvCreateMat(x->rows, 3, CV_32FC1);\r\n\tInhomo2Homo(X, X_homo);\r\n\tcvTranspose(X_homo, X_homoT);\r\n\tInhomo2Homo(x, x_homo);\r\n\tcvTranspose(x_homo, x_homoT);\r\n\r\n\tfor (int iRansacIter = 0; iRansacIter < ransacMaxIter; iRansacIter++)\r\n\t{\r\n\t\tint *randIdx = (int *) malloc(6 * sizeof(int));\r\n\t\tfor (int iIdx = 0; iIdx < 6; iIdx++)\r\n\t\t\trandIdx[iIdx] = rand()%X->rows;\r\n\r\n\t\tCvMat *randx = cvCreateMat(6, 2, CV_32FC1);\r\n\t\tCvMat *randX = cvCreateMat(6, 3, CV_32FC1);\r\n\t\tCvMat *randP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tfor (int iIdx = 0; iIdx < 6; iIdx++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(randx, iIdx, 0, cvGetReal2D(x, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randx, iIdx, 1, cvGetReal2D(x, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 0, cvGetReal2D(X, randIdx[iIdx], 0));\r\n\t\t\tcvSetReal2D(randX, iIdx, 1, cvGetReal2D(X, randIdx[iIdx], 1));\r\n\t\t\tcvSetReal2D(randX, iIdx, 2, cvGetReal2D(X, randIdx[iIdx], 2));\r\n\t\t}\r\n\t\tfree(randIdx);\r\n\r\n\t\tCvMat *K_ = cvCreateMat(3,3,CV_32FC1);\r\n\t\tDLT_ExtrinsicCameraParamEstimation_KRT(randX, randx, K_, randP);\r\n\t\tdouble k33 = cvGetReal2D(K_, 2, 2);\r\n\t\tScalarMul(K_, 1/k33, K_);\r\n\r\n\t\tCvMat *H = cvCreateMat(4, 4, CV_32FC1); CvMat *HX = cvCreateMat(randX->rows, randX->cols, CV_32FC1);\r\n\t\tcvSetIdentity(H);\r\n\t\tSetSubMat(H, 0, 0, randP);\r\n\t\tPxx_inhomo(H, randX, HX);\r\n\r\n\t\tbool isFront = true;\r\n\t\tfor (int i = 0; i < 6; i++)\r\n\t\t{\r\n\t\t\tif (cvGetReal2D(HX, i, 2) < 0)\r\n\t\t\t\tisFront = false;\r\n\t\t}\r\n\t\tcvReleaseMat(&H);\r\n\t\tcvReleaseMat(&HX);\r\n\r\n\t\tif ((!isFront) || (cvGetReal2D(K, 0,0) < 0))\r\n\t\t{\r\n\t\t\tcvReleaseMat(&randx);\r\n\t\t\tcvReleaseMat(&randX);\r\n\t\t\tcvReleaseMat(&randP);\r\n\t\t\tiRansacIter--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvInlier.clear();\r\n\t\tvOutlier.clear();\r\n\t\t// Distance function\r\n\t\tCvMat *x_ = cvCreateMat(3, X->rows, CV_32FC1);\r\n\t\tCvMat *e = cvCreateMat(3, X->rows, CV_32FC1);\r\n\t\tcvMatMul(randP, X_homoT, x_);\r\n\t\tNormalizingByRow(x_, 2);\r\n\t\tcvSub(x_homoT, x_, e);\r\n\t\tfor (int ie = 0; ie < e->cols; ie++)\r\n\t\t{\r\n\t\t\tCvMat *ei = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tCvMat *xi = cvCreateMat(3,1, CV_32FC1);\r\n\t\t\tGetSubMatColwise(x_homoT, ie, ie, xi);\r\n\t\t\tGetSubMatColwise(e, ie, ie, ei);\r\n\t\t\tdouble norm = NormL2(ei);\r\n\t\t\tdouble denorm = NormL2(xi);\r\n\t\t\tdouble d = norm;\r\n\t\t\tif (d < ransacThreshold)\r\n\t\t\t\tvInlier.push_back(ie);\r\n\t\t\telse\r\n\t\t\t\tvOutlier.push_back(ie);\r\n\t\t\tcvReleaseMat(&ei);\r\n\t\t\tcvReleaseMat(&xi);\r\n\t\t}\r\n\r\n\t\tif (vInlier.size() > maxInlier)\r\n\t\t{\r\n\t\t\tmaxInlier = vInlier.size();\r\n\t\t\tP = *cvCloneMat(randP);\r\n\t\t\tK = cvCloneMat(K_);\r\n\t\t\tvInlierIndex = vInlier;\r\n\t\t\tvOutlierIndex = vOutlier;\r\n\t\t}\r\n\t\tcvReleaseMat(&x_);\r\n\t\tcvReleaseMat(&e);\r\n\t\tcvReleaseMat(&randx);\r\n\t\tcvReleaseMat(&randX);\r\n\t\tcvReleaseMat(&randP);\r\n\t\tcvReleaseMat(&K_);\r\n\t}\r\n\r\n\tcvReleaseMat(&X_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tcvReleaseMat(&x_homoT);\r\n\tcvReleaseMat(&X_homo);\r\n\tif (vInlierIndex.size() < 10)\r\n\t\treturn 0;\r\n\tcout << \"Number of features to do DLT camera pose estimation: \" << vInlierIndex.size() << endl;\r\n\treturn 1;\r\n}\r\n\r\nint DLT_ExtrinsicCameraParamEstimation_KRT(CvMat *X, CvMat *x, CvMat *K, CvMat &P)\r\n{\r\n\tif (X->rows < 6)\r\n\t\treturn 0;\r\n\r\n\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\tDLT_ExtrinsicCameraParamEstimation_KRT(X, x, K, P_);\r\n\tP = *cvCloneMat(P_);\r\n\treturn 1;\r\n}\r\n\r\n\r\n\r\nvoid SparseBundleAdjustment_MOT(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, CvMat *K, vector<int> visibleStructureID)\r\n{\r\n\t//PrintAlgorithm(\"Sparse bundle adjustment motion only\");\r\n\t//vector<double> cameraParameter, feature2DParameter;\r\n\t//vector<char> vMask;\r\n\t//double *dCovFeatures = 0;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//double intrinsic[4];\r\n\t//intrinsic[0] = cvGetReal2D(K, 0, 0);\r\n\t//intrinsic[1] = cvGetReal2D(K, 1, 1);\r\n\t//intrinsic[2] = cvGetReal2D(K, 0, 2);\r\n\t//intrinsic[3] = cvGetReal2D(K, 1, 2);\r\n\t//adata.intrinsic = intrinsic;\r\n\r\n\t//GetParameterForSBA(vFeature, vUsedFrame, cP, X, K, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\t//double nCameraParam = 7;\r\n\t//int nFeatures = vFeature.size(); \r\n\t//int nFrames = vUsedFrame.size(); \r\n\t//char *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\t//double *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\t//\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < vMask.size(); i++)\r\n\t//\tdVMask[i] = vMask[i];\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\t//adata.XYZ = &(dCameraParameter[7*vUsedFrame.size()]);\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-3;\r\n\t//opt[1] = 1e-12;\r\n\t//opt[2] = 1e-12;\r\n\t//opt[3] = 1e-12;\r\n\t//opt[4] = 0;\r\n\t//double info[12];\r\n\t//sba_mot_levmar(visibleStructureID.size(), vUsedFrame.size(), 1, dVMask,  dCameraParameter, 7, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOT, NULL, &adata,\r\n\t//\t\t\t\t1e+3, 0, opt, info);\r\n\t//PrintSBAInfo(info);\r\n\t//RetrieveParameterFromSBA(dCameraParameter, K, cP, X, visibleStructureID);\r\n\t//free(dVMask);\r\n\t//free(dFeature2DParameter);\r\n\t//free(dCameraParameter);\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, CvMat *K, vector<int> visibleStructureID)\r\n{\r\n\t//PrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\t//vector<double> cameraParameter, feature2DParameter;\r\n\t//vector<char> vMask;\r\n\t//double *dCovFeatures = 0;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//double intrinsic[4];\r\n\t//intrinsic[0] = cvGetReal2D(K, 0, 0);\r\n\t//intrinsic[1] = cvGetReal2D(K, 1, 1);\r\n\t//intrinsic[2] = cvGetReal2D(K, 0, 2);\r\n\t//intrinsic[3] = cvGetReal2D(K, 1, 2);\r\n\t//adata.intrinsic = intrinsic;\r\n\r\n\t//GetParameterForSBA(vFeature, vUsedFrame, cP, X, K, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\t//int NZ = 0;\r\n\t//for (int i = 0; i < vMask.size(); i++)\r\n\t//{\r\n\t//\tif (vMask[i])\r\n\t//\t\tNZ++;\r\n\t//}\r\n\t//double nCameraParam = 7;\r\n\t//int nFeatures = vFeature.size(); \r\n\t//int nFrames = vUsedFrame.size(); \r\n\t//char *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\t//double *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < vMask.size(); i++)\r\n\t//\tdVMask[i] = vMask[i];\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-3;\r\n\t//opt[1] = 1e-5;//1e-12;\r\n\t//opt[2] = 1e-5;//1e-12;\r\n\t//opt[3] = 1e-5;//1e-12;\r\n\t//opt[4] = 0;\r\n\t//double info[12];\r\n\t//sba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR, NULL, &adata,\r\n\t//\t1e+3, 0, opt, info);\r\n\t//PrintSBAInfo(info);\r\n\t//RetrieveParameterFromSBA(dCameraParameter, K, cP, X, visibleStructureID);\r\n\r\n\t//free(dVMask);\r\n\t//free(dFeature2DParameter);\r\n\t//free(dCameraParameter);\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tdouble *intrinsic = (double *) malloc(4 * sizeof(double));\r\n\t\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t\tadata.vIntrinsic.push_back(intrinsic);\r\n\t}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tcout << \"kk\" << endl;\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\tfree(dCovFeatures);\r\n\tcout << \"kk\" << endl;\r\n\tfor (int i = 0; i < adata.vIntrinsic.size(); i++)\r\n\t{\r\n\t\tfree(adata.vIntrinsic[i]);\r\n\t}\r\n\tcout << \"kk\" << endl;\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR_mem(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tdouble *intrinsic = (double *) malloc(4 * sizeof(double));\r\n\t\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t\tadata.vIntrinsic.push_back(intrinsic);\r\n\t}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tPrintMat(cP[1]);\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR_fast, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA_mem(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tPrintMat(cP[1]);\r\n\tcout << \"----------------\" << endl;\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\tfree(dCovFeatures);\r\n\tfor (int i = 0; i < adata.vIntrinsic.size(); i++)\r\n\t{\r\n\t\tfree(adata.vIntrinsic[i]);\r\n\t}\r\n\tadata.vIntrinsic.clear();\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR_mem_fast(vector<Feature> &vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<int> visibleStructureID;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tvisibleStructureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tfor (int iFrame = 0; iFrame < vCamera[0].vTakenFrame.size(); iFrame++)\r\n\t{\r\n\t\tdouble *intrinsic = (double *) malloc(4 * sizeof(double));\r\n\t\tintrinsic[0] = cvGetReal2D(vCamera[0].vK[iFrame], 0, 0);\r\n\t\tintrinsic[1] = cvGetReal2D(vCamera[0].vK[iFrame], 1, 1);\r\n\t\tintrinsic[2] = cvGetReal2D(vCamera[0].vK[iFrame], 0, 2);\r\n\t\tintrinsic[3] = cvGetReal2D(vCamera[0].vK[iFrame], 1, 2);\r\n\t\tadata.vIntrinsic.push_back(intrinsic);\r\n\t}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR_fast, NULL, &adata,\r\n\t\t1e+2, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA_mem(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\tfree(dCovFeatures);\r\n\tfor (int i = 0; i < adata.vIntrinsic.size(); i++)\r\n\t{\r\n\t\tfree(adata.vIntrinsic[i]);\r\n\t}\r\n\tadata.vIntrinsic.clear();\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR_mem_fast_Distortion(vector<Feature> &vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, double omega)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<int> visibleStructureID;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tvisibleStructureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tdouble *intrinsic = (double *) malloc(6 * sizeof(double));\r\n\t\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t\tintrinsic[4] = omega;\r\n\t\tintrinsic[5] = 2*tan(omega/2);\r\n\r\n\t\tadata.vIntrinsic.push_back(intrinsic);\r\n\t}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA_Distortion(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR_fast_Distortion, NULL, &adata,\r\n\t\t1e+2, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA_mem(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\tfree(dCovFeatures);\r\n\tfor (int i = 0; i < adata.vIntrinsic.size(); i++)\r\n\t{\r\n\t\tfree(adata.vIntrinsic[i]);\r\n\t}\r\n\tadata.vIntrinsic.clear();\r\n}\r\n\r\nvoid SparseBundleAdjustment_MOTSTR_mem_fast_Distortion_ObstacleDetection(vector<Feature> &vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera,\r\n\tdouble omega, double princ_x1, double princ_y1)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<int> visibleStructureID;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tvisibleStructureID.push_back(vFeature[iFeature].id);\r\n\t\t}\r\n\t}\r\n\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tdouble *intrinsic = (double *) malloc(8 * sizeof(double));\r\n\t\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t\tintrinsic[4] = omega;\r\n\t\tintrinsic[5] = 2*tan(omega/2);\r\n\t\tintrinsic[6] = princ_x1;\r\n\t\tintrinsic[7] = princ_y1;\r\n\t\tadata.vIntrinsic.push_back(intrinsic);\r\n\t}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\t//cout << \"OK\" << endl;\r\n\t//for (int i = 0; i < cP.size(); i++)\r\n\t//{\r\n\t//\tPrintMat(cP[i]);\r\n\t//}\r\n\t//for (int i = 0; i < visibleStructureID.size(); i++)\r\n\t//{\r\n\t//\tcout << cvGetReal2D(X, visibleStructureID[i], 0) << \" \" <<cvGetReal2D(X, visibleStructureID[i], 1) << \" \" <<cvGetReal2D(X, visibleStructureID[i], 2) << \" \" << endl; \r\n\t//}\r\n\t\r\n\tGetParameterForSBA_Distortion(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tcout << \"OK\" << endl;\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\t\r\n\tdouble nCameraParam = 7;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tcout << \"OK\" << endl;\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_MOTSTR_fast_Distortion_ObstacleDetection, NULL, &adata,\r\n\t\t1e+2, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA_mem(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\tfree(dCovFeatures);\r\n\tfor (int i = 0; i < adata.vIntrinsic.size(); i++)\r\n\t{\r\n\t\tfree(adata.vIntrinsic[i]);\r\n\t}\r\n\tadata.vIntrinsic.clear();\r\n}\r\n\r\n\r\nvoid SparseBundleAdjustment_KMOTSTR(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//for (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t//{\r\n\t//\tdouble *intrinsic = (double *) malloc(4 * sizeof(double));\r\n\t//\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t//\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t//\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t//\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t//\tadata.vIntrinsic.push_back(intrinsic);\r\n\t//}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA_KRT(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7+4;\r\n\tint nFeatures = visibleStructureID.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tdVMask[i] = vMask[i];\r\n\t}\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_KMOTSTR, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info, feature2DParameter.size()/2);\r\n\tRetrieveParameterFromSBA_KRT(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n}\r\n\r\nvoid SparseBundleAdjustment_KMOTSTR_x(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//for (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t//{\r\n\t//\tdouble *intrinsic = (double *) malloc(4 * sizeof(double));\r\n\t//\tintrinsic[0] = cvGetReal2D(vCamera[iCamera].K, 0, 0);\r\n\t//\tintrinsic[1] = cvGetReal2D(vCamera[iCamera].K, 1, 1);\r\n\t//\tintrinsic[2] = cvGetReal2D(vCamera[iCamera].K, 0, 2);\r\n\t//\tintrinsic[3] = cvGetReal2D(vCamera[iCamera].K, 1, 2);\r\n\t//\tadata.vIntrinsic.push_back(intrinsic);\r\n\t//}\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA_KRT(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7+4;\r\n\tint nFeatures = visibleStructureID.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tdVMask[i] = vMask[i];\r\n\t}\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_KMOTSTR, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info);\r\n\tRetrieveParameterFromSBA_KRT(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n}\r\n\r\n\r\nvoid SparseBundleAdjustment_KDMOTSTR(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion and structure\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA_KDRT(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\tint NZ = 0;\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t{\r\n\t\tif (vMask[i])\r\n\t\t\tNZ++;\r\n\t}\r\n\tdouble nCameraParam = 7+4+2;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(visibleStructureID.size(), 0, vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_KDMOTSTR, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info);\r\n\tRetrieveParameterFromSBA_KDRT(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n}\r\n\r\nvoid PatchTriangulationRefinement(CvMat *K, vector<CvMat *> vC, vector<CvMat *> vR, \r\n\t\t\t\t\t\t\t\t  vector<double> vx11, vector<double> vy11, \r\n\t\t\t\t\t\t\t\t  vector<double> vx12, vector<double> vy12,\r\n\t\t\t\t\t\t\t\t  vector<double> vx21, vector<double> vy21,\r\n\t\t\t\t\t\t\t\t  vector<double> vx22, vector<double> vy22,\r\n\t\t\t\t\t\t\t\t  double X, double Y, double Z, \r\n\t\t\t\t\t\t\t\t  CvMat *X11, CvMat *X12, CvMat *X21, CvMat *X22, CvMat *pi)\r\n{\r\n\tPrintAlgorithm(\"Patch Triangulation Refinement\");\r\n\tvector<CvMat *> vP;\r\n\tfor (int i = 0; i < vC.size(); i++)\r\n\t{\r\n\t\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tScalarMul(vC[i], -1, t); \r\n\t\tcvSetIdentity(P);\r\n\t\tSetSubMat(P, 0, 3, t);\r\n\t\tcvMatMul(vR[i], P, P);\r\n\t\tcvMatMul(K, P, P);\r\n\t\tvP.push_back(P);\r\n\t}\r\n\tAdditionalData adata;\r\n\tadata.vP = vP;\r\n\tadata.X = X;\tadata.Y = Y;\tadata.Z = Z;\r\n\r\n\tvector<double> XParameter, feature2DParameter;\r\n\tXParameter.push_back(cvGetReal2D(pi, 0, 0));\r\n\tXParameter.push_back(cvGetReal2D(pi, 1, 0));\r\n\tXParameter.push_back(cvGetReal2D(pi, 2, 0));\r\n\tXParameter.push_back(cvGetReal2D(X11, 0, 0));\r\n\tXParameter.push_back(cvGetReal2D(X11, 1, 0));\r\n\tXParameter.push_back(cvGetReal2D(X12, 0, 0));\r\n\tXParameter.push_back(cvGetReal2D(X12, 1, 0));\r\n\tXParameter.push_back(cvGetReal2D(X21, 0, 0));\r\n\tXParameter.push_back(cvGetReal2D(X21, 1, 0));\r\n\tXParameter.push_back(cvGetReal2D(X22, 0, 0));\r\n\tXParameter.push_back(cvGetReal2D(X22, 1, 0));\r\n\t\r\n\tfor (int iFeature = 0; iFeature < vx11.size(); iFeature++)\r\n\t{\r\n\t\tfeature2DParameter.push_back(vx11[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy11[iFeature]);\r\n\t\tfeature2DParameter.push_back(vx12[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy12[iFeature]);\r\n\t\tfeature2DParameter.push_back(vx21[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy21[iFeature]);\r\n\t\tfeature2DParameter.push_back(vx22[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy22[iFeature]);\r\n\t}\r\n\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//{\r\n\t//\tcout << feature2DParameter[i] << \" \";\r\n\t//}\r\n\t//cout << endl;\r\n\r\n\r\n\tint nFeatures = vx11.size(); \r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dXParameter = (double *) malloc(XParameter.size() * sizeof(double));\r\n\t\r\n\tfor (int i = 0; i < XParameter.size(); i++)\r\n\t\tdXParameter[i] = XParameter[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\r\n\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(XParameter.size(), feature2DParameter.size())+XParameter.size()*XParameter.size())*sizeof(double));\r\n\tif(!work)\r\n\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\tint ret = dlevmar_dif(Projection3Donto2D_Patch, dXParameter, dFeature2DParameter, XParameter.size(), feature2DParameter.size(),\r\n\t\t\t\t\t\t  1e+3, opt, info, work, NULL, &adata);\r\n\r\n\tdouble pi1 = dXParameter[0];\r\n\tdouble pi2 = dXParameter[1];\r\n\tdouble pi3 = dXParameter[2];\r\n\tdouble pi4 = -pi1*X-pi2*Y-pi3*Z;\r\n\r\n\tcvSetReal2D(pi, 0, 0, dXParameter[0]);\r\n\tcvSetReal2D(pi, 1, 0, dXParameter[1]);\r\n\tcvSetReal2D(pi, 2, 0, dXParameter[2]);\r\n\tcvSetReal2D(pi, 3, 0, pi4);\r\n\r\n\tcvSetReal2D(X11, 0, 0, dXParameter[3]);\r\n\tcvSetReal2D(X11, 1, 0, dXParameter[4]);\r\n\tdouble Z11 = (-pi4-pi1*cvGetReal2D(X11, 0, 0)-pi2*cvGetReal2D(X11, 1, 0))/pi3;\r\n\tcvSetReal2D(X11, 2, 0, Z11);\r\n\r\n\tcvSetReal2D(X12, 0, 0, dXParameter[5]);\r\n\tcvSetReal2D(X12, 1, 0, dXParameter[6]);\r\n\tdouble Z12 = (-pi4-pi1*cvGetReal2D(X12, 0, 0)-pi2*cvGetReal2D(X12, 1, 0))/pi3;\r\n\tcvSetReal2D(X12, 2, 0, Z12);\r\n\r\n\tcvSetReal2D(X21, 0, 0, dXParameter[7]);\r\n\tcvSetReal2D(X21, 1, 0, dXParameter[8]);\r\n\tdouble Z21 = (-pi4-pi1*cvGetReal2D(X21, 0, 0)-pi2*cvGetReal2D(X21, 1, 0))/pi3;\r\n\tcvSetReal2D(X21, 2, 0, Z21);\r\n\r\n\tcvSetReal2D(X22, 0, 0, dXParameter[9]);\r\n\tcvSetReal2D(X22, 1, 0, dXParameter[10]);\r\n\tdouble Z22 = (-pi4-pi1*cvGetReal2D(X22, 0, 0)-pi2*cvGetReal2D(X22, 1, 0))/pi3;\r\n\tcvSetReal2D(X22, 2, 0, Z22);\r\n\r\n\tPrintSBAInfo(info, feature2DParameter.size());\r\n\tfree(dFeature2DParameter);\r\n\tfree(dXParameter);\r\n\tfree(work);\r\n\r\n\tfor (int i = 0; i < vP.size(); i++)\r\n\t{\r\n\t\tcvReleaseMat(&vP[i]);\r\n\t}\r\n}\r\n\r\nvoid TriangulationRefinement(CvMat *K, double omega, vector<CvMat *> vP, vector<double> vx, vector<double> vy, double &X, double &Y, double &Z)\r\n{\r\n\tPrintAlgorithm(\"Point Triangulation Refinement\");\r\n\tAdditionalData adata;\r\n\tdouble intrinsic[5] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2), omega};\r\n\tadata.vIntrinsic.push_back(intrinsic);\r\n\tadata.vP = vP;\r\n\r\n\tvector<double> XParameter, feature2DParameter;\r\n\tXParameter.push_back(X);\r\n\tXParameter.push_back(Y);\r\n\tXParameter.push_back(Z);\r\n\t\r\n\tfor (int iFeature = 0; iFeature < vx.size(); iFeature++)\r\n\t{\r\n\t\tfeature2DParameter.push_back(vx[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy[iFeature]);\r\n\t}\r\n\r\n\tint nFeatures = vx.size(); \r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dXParameter = (double *) malloc(XParameter.size() * sizeof(double));\r\n\t\r\n\tfor (int i = 0; i < XParameter.size(); i++)\r\n\t\tdXParameter[i] = XParameter[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\r\n\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(XParameter.size(), feature2DParameter.size())+XParameter.size()*XParameter.size())*sizeof(double));\r\n\tif(!work)\r\n\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\tint ret = dlevmar_dif(Projection3Donto2D_STR_fast_SO, dXParameter, dFeature2DParameter, XParameter.size(), feature2DParameter.size(),\r\n\t\t\t\t\t\t  1e+3, opt, info, work, NULL, &adata);\r\n\r\n\tX = dXParameter[0];\r\n\tY = dXParameter[1];\r\n\tZ = dXParameter[2];\r\n\tPrintSBAInfo(info, feature2DParameter.size());\r\n\tfree(dFeature2DParameter);\r\n\tfree(dXParameter);\r\n\tfree(work);\r\n\r\n\t//for (int i = 0; i < adata.vP.size(); i++)\r\n\t//{\r\n\t//\tcvReleaseMat(&adata.vP[i]);\r\n\t//}\r\n}\r\n\r\nvoid TriangulationRefinement_NoDistortion(CvMat *K, vector<CvMat *> vP, vector<double> vx, vector<double> vy, double &X, double &Y, double &Z)\r\n{\r\n\tPrintAlgorithm(\"Point Triangulation Refinement\");\r\n\tAdditionalData adata;\r\n\tdouble intrinsic[4] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2)};\r\n\tadata.vIntrinsic.push_back(intrinsic);\r\n\tadata.vP = vP;\r\n\r\n\tvector<double> XParameter, feature2DParameter;\r\n\tXParameter.push_back(X);\r\n\tXParameter.push_back(Y);\r\n\tXParameter.push_back(Z);\r\n\t\r\n\tfor (int iFeature = 0; iFeature < vx.size(); iFeature++)\r\n\t{\r\n\t\tfeature2DParameter.push_back(vx[iFeature]);\r\n\t\tfeature2DParameter.push_back(vy[iFeature]);\r\n\t}\r\n\r\n\tint nFeatures = vx.size(); \r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dXParameter = (double *) malloc(XParameter.size() * sizeof(double));\r\n\t\r\n\tfor (int i = 0; i < XParameter.size(); i++)\r\n\t\tdXParameter[i] = XParameter[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\r\n\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(XParameter.size(), feature2DParameter.size())+XParameter.size()*XParameter.size())*sizeof(double));\r\n\tif(!work)\r\n\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\tint ret = dlevmar_dif(Projection3Donto2D_STR_fast_SO_NoDistortion, dXParameter, dFeature2DParameter, XParameter.size(), feature2DParameter.size(),\r\n\t\t\t\t\t\t  1e+3, opt, info, work, NULL, &adata);\r\n\r\n\tX = dXParameter[0];\r\n\tY = dXParameter[1];\r\n\tZ = dXParameter[2];\r\n\tPrintSBAInfo(info, feature2DParameter.size());\r\n\tfree(dFeature2DParameter);\r\n\tfree(dXParameter);\r\n\tfree(work);\r\n\r\n\t//for (int i = 0; i < adata.vP.size(); i++)\r\n\t//{\r\n\t//\tcvReleaseMat(&adata.vP[i]);\r\n\t//}\r\n}\r\n\r\n\r\nvoid AbsoluteCameraPoseRefinement(CvMat *X, CvMat *x, CvMat *P, CvMat *K)\r\n{\r\n\tPrintAlgorithm(\"Absolute Camera Pose Refinement\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\tdouble intrinsic[4] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2)};\r\n\tadata.vIntrinsic.push_back(intrinsic);\r\n\r\n\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\tGetSubMatColwise(P, 0, 2, R);\r\n\tGetSubMatColwise(P, 3, 3, t);\r\n\tcvInvert(K, invK);\r\n\tcvMatMul(invK, R, R);\r\n\tcvInvert(R, invR);\r\n\tcvMatMul(invK, t, t);\r\n\tcvMatMul(invR, t, t);\r\n\tScalarMul(t, -1, t);\r\n\tRotation2Quaternion(R, q);\r\n\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\t\r\n\tfor (int iFeature = 0; iFeature < X->rows; iFeature++)\r\n\t{\r\n\t\tfeature2DParameter.push_back(cvGetReal2D(x, iFeature, 0));\r\n\t\tfeature2DParameter.push_back(cvGetReal2D(x, iFeature, 1));\r\n\t}\r\n\r\n\tint nCameraParam = 7;\r\n\tint nFeatures = X->rows; \r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\tdouble *dXParameter = (double *) malloc(X->rows * 3 * sizeof(double));\r\n\t\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tdXParameter[3*i] = cvGetReal2D(X, i, 0);\r\n\t\tdXParameter[3*i+1] = cvGetReal2D(X, i, 1);\r\n\t\tdXParameter[3*i+2] = cvGetReal2D(X, i, 2);\r\n\t}\r\n\r\n\tadata.XYZ = dXParameter;\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\r\n\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), feature2DParameter.size())+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n\tif(!work)\r\n\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\tint ret = dlevmar_dif(Projection3Donto2D_MOT_fast, dCameraParameter, dFeature2DParameter, cameraParameter.size(), feature2DParameter.size(),\r\n\t\t\t\t\t\t  1e+3, opt, info, work, NULL, &adata);\r\n\r\n\tcvSetIdentity(P);\r\n\tcvSetReal2D(P, 0, 3, -dCameraParameter[4]);\r\n\tcvSetReal2D(P, 1, 3, -dCameraParameter[5]);\r\n\tcvSetReal2D(P, 2, 3, -dCameraParameter[6]);\r\n\r\n\tcvSetReal2D(q, 0, 0, dCameraParameter[0]);\r\n\tcvSetReal2D(q, 1, 0, dCameraParameter[1]);\r\n\tcvSetReal2D(q, 2, 0, dCameraParameter[2]);\r\n\tcvSetReal2D(q, 3, 0, dCameraParameter[3]);\r\n\r\n\tQuaternion2Rotation(q, R);\r\n\tcvMatMul(K, R, R);\r\n\tcvMatMul(R, P, P);\r\n\r\n\t//cout << ret << endl;\r\n\tPrintSBAInfo(info, X->rows);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n\r\n\tcvReleaseMat(&R);\r\n\tcvReleaseMat(&t);\r\n\tcvReleaseMat(&q);\r\n\tcvReleaseMat(&invK);\r\n\tcvReleaseMat(&invR);\r\n}\r\n\r\nvoid Projection3Donto2D_Patch(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\t// Set intrinsic parameter\r\n\tdouble X = ((AdditionalData *) adata)->X;\r\n\tdouble Y = ((AdditionalData *) adata)->Y;\r\n\tdouble Z = ((AdditionalData *) adata)->Z;\r\n\r\n\tdouble pi1 = rt[0];\r\n\tdouble pi2 = rt[1];\r\n\tdouble pi3 = rt[2];\r\n\tdouble pi4 = -pi1*X - pi2*Y - pi3*Z;\r\n\r\n\tdouble X11 = rt[3];\r\n\tdouble Y11 = rt[4];\r\n\tdouble Z11 = (-pi4-pi1*X11-pi2*Y11)/pi3;\r\n\r\n\tdouble X12 = rt[5];\r\n\tdouble Y12 = rt[6];\r\n\tdouble Z12 = (-pi4-pi1*X12-pi2*Y12)/pi3;\r\n\r\n\tdouble X21 = rt[7];\r\n\tdouble Y21 = rt[8];\r\n\tdouble Z21 = (-pi4-pi1*X21-pi2*Y21)/pi3;\r\n\r\n\tdouble X22 = rt[9];\r\n\tdouble Y22 = rt[10];\r\n\tdouble Z22 = (-pi4-pi1*X22-pi2*Y22)/pi3;\r\n\tfor (int iP = 0; iP < ((AdditionalData *) adata)->vP.size(); iP++)\r\n\t{\r\n\t\tdouble P11 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 0);\r\n\t\tdouble P12 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 1);\r\n\t\tdouble P13 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 2);\r\n\t\tdouble P14 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 3);\r\n\r\n\t\tdouble P21 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 0);\r\n\t\tdouble P22 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 1);\r\n\t\tdouble P23 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 2);\r\n\t\tdouble P24 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 3);\r\n\r\n\t\tdouble P31 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 0);\r\n\t\tdouble P32 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 1);\r\n\t\tdouble P33 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 2);\r\n\t\tdouble P34 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 3);\r\n\r\n\t\tdouble x11 = P11*X11+P12*Y11+P13*Z11+P14;\r\n\t\tdouble y11 = P21*X11+P22*Y11+P23*Z11+P24;\r\n\t\tdouble z11 = P31*X11+P32*Y11+P33*Z11+P34;\r\n\r\n\t\tdouble x12 = P11*X12+P12*Y12+P13*Z12+P14;\r\n\t\tdouble y12 = P21*X12+P22*Y12+P23*Z12+P24;\r\n\t\tdouble z12 = P31*X12+P32*Y12+P33*Z12+P34;\r\n\r\n\t\tdouble x21 = P11*X21+P12*Y21+P13*Z21+P14;\r\n\t\tdouble y21 = P21*X21+P22*Y21+P23*Z21+P24;\r\n\t\tdouble z21 = P31*X21+P32*Y21+P33*Z21+P34;\r\n\r\n\t\tdouble x22 = P11*X22+P12*Y22+P13*Z22+P14;\r\n\t\tdouble y22 = P21*X22+P22*Y22+P23*Z22+P24;\r\n\t\tdouble z22 = P31*X22+P32*Y22+P33*Z22+P34;\r\n\r\n\t\thx[8*iP] = x11/z11;\r\n\t\thx[8*iP+1] = y11/z11;\r\n\r\n\t\thx[8*iP+2] = x12/z12;\r\n\t\thx[8*iP+3] = y12/z12;\r\n\r\n\t\thx[8*iP+4] = x21/z21;\r\n\t\thx[8*iP+5] = y21/z21;\r\n\r\n\t\thx[8*iP+6] = x22/z22;\r\n\t\thx[8*iP+7] = y22/z22;\r\n\r\n\t\t//cout << x11/z11 << \" \" << y11/z11 << \" \";\r\n\t\t//cout << x12/z12 << \" \" << y12/z12 << \" \";\r\n\t\t//cout << x21/z21 << \" \" << y21/z21 << \" \";\r\n\t\t//cout << x22/z22 << \" \" << y22/z22 << endl;\r\n\t}\r\n\r\n}\r\n\r\n\r\nvoid Projection3Donto2D_STR_fast_SO(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[0])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[0])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[0])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[0])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\tdouble omega = ((((AdditionalData *) adata)->vIntrinsic)[0])[4];\r\n\r\n\tdouble tan_omega_half_2 = 2*tan(omega/2); \r\n\r\n\tdouble X = rt[0];\r\n\tdouble Y = rt[1];\r\n\tdouble Z = rt[2];\r\n\tfor (int iP = 0; iP < ((AdditionalData *) adata)->vP.size(); iP++)\r\n\t{\r\n\t\tdouble P11 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 0);\r\n\t\tdouble P12 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 1);\r\n\t\tdouble P13 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 2);\r\n\t\tdouble P14 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 3);\r\n\r\n\t\tdouble P21 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 0);\r\n\t\tdouble P22 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 1);\r\n\t\tdouble P23 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 2);\r\n\t\tdouble P24 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 3);\r\n\r\n\t\tdouble P31 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 0);\r\n\t\tdouble P32 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 1);\r\n\t\tdouble P33 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 2);\r\n\t\tdouble P34 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 3);\r\n\r\n\t\tdouble x = P11*X+P12*Y+P13*Z+P14;\r\n\t\tdouble y = P21*X+P22*Y+P23*Z+P24;\r\n\t\tdouble z = P31*X+P32*Y+P33*Z+P34;\r\n\r\n\t\tx /= z;\r\n\t\ty /= z;\r\n\r\n\t\tdouble u_n = x/K11 - K13/K11;\r\n\t\tdouble v_n = y/K22 - K23/K22;\r\n\r\n\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\tdouble u_d = u_d_n*K11 + K13;\r\n\t\tdouble v_d = v_d_n*K22 + K23;\r\n\r\n\t\thx[2*iP] = u_d;\r\n\t\thx[2*iP+1] = v_d;\r\n\t}\r\n\r\n}\r\n\r\nvoid Projection3Donto2D_STR_fast_SO_NoDistortion(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[0])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[0])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[0])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[0])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\t//double omega = ((((AdditionalData *) adata)->vIntrinsic)[0])[4];\r\n\r\n\t//double tan_omega_half_2 = 2*tan(omega/2); \r\n\r\n\tdouble X = rt[0];\r\n\tdouble Y = rt[1];\r\n\tdouble Z = rt[2];\r\n\tfor (int iP = 0; iP < ((AdditionalData *) adata)->vP.size(); iP++)\r\n\t{\r\n\t\tdouble P11 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 0);\r\n\t\tdouble P12 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 1);\r\n\t\tdouble P13 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 2);\r\n\t\tdouble P14 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 0, 3);\r\n\r\n\t\tdouble P21 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 0);\r\n\t\tdouble P22 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 1);\r\n\t\tdouble P23 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 2);\r\n\t\tdouble P24 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 1, 3);\r\n\r\n\t\tdouble P31 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 0);\r\n\t\tdouble P32 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 1);\r\n\t\tdouble P33 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 2);\r\n\t\tdouble P34 = cvGetReal2D(((AdditionalData *) adata)->vP[iP], 2, 3);\r\n\r\n\t\tdouble x = P11*X+P12*Y+P13*Z+P14;\r\n\t\tdouble y = P21*X+P22*Y+P23*Z+P24;\r\n\t\tdouble z = P31*X+P32*Y+P33*Z+P34;\r\n\r\n\t\tx /= z;\r\n\t\ty /= z;\r\n\r\n\t\t//double u_n = x/K11 - K13/K11;\r\n\t\t//double v_n = y/K22 - K23/K22;\r\n\r\n\t\t//double r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t//double r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t//double u_d_n = r_d/r_u * u_n;\r\n\t\t//double v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t//double u_d = u_d_n*K11 + K13;\r\n\t\t//double v_d = v_d_n*K22 + K23;\r\n\r\n\t\thx[2*iP] = x;\r\n\t\thx[2*iP+1] = y;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nvoid Projection3Donto2D_MOT_fast(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[0])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[0])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[0])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[0])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\t// Set orientation\r\n\tdouble qw = rt[0];\r\n\tdouble qx = rt[1];\r\n\tdouble qy = rt[2];\r\n\tdouble qz = rt[3];\r\n\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\tqw /= q_norm;\r\n\tqx /= q_norm;\r\n\tqy /= q_norm;\r\n\tqz /= q_norm;\r\n\t\r\n\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\r\n\t// Set translation\r\n\tdouble C1 = rt[4];\r\n\tdouble C2 = rt[5];\r\n\tdouble C3 = rt[6];\r\n\t\r\n\tfor (int iPoint = 0; iPoint < n/2; iPoint++)\r\n\t{\r\n\t\tdouble X1 = ((AdditionalData *) adata)->XYZ[3*iPoint];\r\n\t\tdouble X2 = ((AdditionalData *) adata)->XYZ[3*iPoint+1];\r\n\t\tdouble X3 = ((AdditionalData *) adata)->XYZ[3*iPoint+2];\r\n\r\n\t\t// Building projection \r\n\t\tdouble RX1 = R11*X1+R12*X2+R13*X3;\r\n\t\tdouble RX2 = R21*X1+R22*X2+R23*X3;\r\n\t\tdouble RX3 = R31*X1+R32*X2+R33*X3;\r\n\r\n\t\tdouble KRX1 = K11*RX1+K12*RX2+K13*RX3;\r\n\t\tdouble KRX2 = K21*RX1+K22*RX2+K23*RX3;\r\n\t\tdouble KRX3 = K31*RX1+K32*RX2+K33*RX3;\r\n\r\n\t\tdouble RC1 = R11*C1+R12*C2+R13*C3;\r\n\t\tdouble RC2 = R21*C1+R22*C2+R23*C3;\r\n\t\tdouble RC3 = R31*C1+R32*C2+R33*C3;\r\n\r\n\t\tdouble KRC1 = K11*RC1+K12*RC2+K13*RC3;\r\n\t\tdouble KRC2 = K21*RC1+K22*RC2+K23*RC3;\r\n\t\tdouble KRC3 = K31*RC1+K32*RC2+K33*RC3;\r\n\r\n\t\tdouble proj1 = KRX1-KRC1;\r\n\t\tdouble proj2 = KRX2-KRC2;\r\n\t\tdouble proj3 = KRX3-KRC3;\r\n\r\n\t\thx[2*iPoint] = proj1/proj3;\r\n\t\thx[2*iPoint+1] = proj2/proj3;\r\n\t}\r\n}\r\n\r\nvoid ObjectiveOrientationRefinement(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\tint nFrames = (((AdditionalData *) adata)->nFrames);\r\n\r\n\tvector<double> vR11, vR12, vR13, vR21, vR22, vR23, vR31, vR32, vR33;\r\n\tvector<double> vm1, vm2, vm3;\r\n\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\t// Set orientation\r\n\t\tdouble qw = rt[7*iFrame+0];\r\n\t\tdouble qx = rt[7*iFrame+1];\r\n\t\tdouble qy = rt[7*iFrame+2];\r\n\t\tdouble qz = rt[7*iFrame+3];\r\n\t\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\t\tqw /= q_norm;\r\n\t\tqx /= q_norm;\r\n\t\tqy /= q_norm;\r\n\t\tqz /= q_norm;\r\n\r\n\t\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\t\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\t\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\t\tvR11.push_back(R11);\t\tvR12.push_back(R12);\t\tvR13.push_back(R13);\r\n\t\tvR21.push_back(R21);\t\tvR22.push_back(R22);\t\tvR23.push_back(R23);\r\n\t\tvR31.push_back(R31);\t\tvR32.push_back(R32);\t\tvR33.push_back(R33);\r\n\r\n\t\tvm1.push_back(rt[7*iFrame+4]);\r\n\t\tvm2.push_back(rt[7*iFrame+5]);\r\n\t\tvm3.push_back(rt[7*iFrame+6]);\r\n\r\n\t\t//cout << R11 << \" \" << R12 << \" \" << R13 << endl;\r\n\t\t//cout << R21 << \" \" << R22 << \" \" << R23 << endl;\r\n\t\t//cout << R31 << \" \" << R32 << \" \" << R33 << endl;\r\n \t}\r\n\r\n\t//vector<CvMat *> vP = (((AdditionalData *) adata)->vP);\r\n\r\n\tdouble R11 = 1;\t\tdouble R12 = 0;\t\tdouble R13 = 0;\r\n\tdouble R21 = 0;\t\tdouble R22 = 1;\t\tdouble R23 = 0;\r\n\tdouble R31 = 0;\t\tdouble R32 = 0;\t\tdouble R33 = 1;\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tdouble R11_t, R12_t, R13_t, R21_t, R22_t, R23_t, R31_t, R32_t, R33_t; \r\n\t\tR11_t = vR11[iFrame]*R11 + vR12[iFrame]*R21 + vR13[iFrame]*R31;\r\n\t\tR12_t = vR11[iFrame]*R12 + vR12[iFrame]*R22 + vR13[iFrame]*R32;\r\n\t\tR13_t = vR11[iFrame]*R13 + vR12[iFrame]*R23 + vR13[iFrame]*R33;\r\n\r\n\t\tR21_t = vR21[iFrame]*R11 + vR22[iFrame]*R21 + vR23[iFrame]*R31;\r\n\t\tR22_t = vR21[iFrame]*R12 + vR22[iFrame]*R22 + vR23[iFrame]*R32;\r\n\t\tR23_t = vR21[iFrame]*R13 + vR22[iFrame]*R23 + vR23[iFrame]*R33;\r\n\r\n\t\tR31_t = vR31[iFrame]*R11 + vR32[iFrame]*R21 + vR33[iFrame]*R31;\r\n\t\tR32_t = vR31[iFrame]*R12 + vR32[iFrame]*R22 + vR33[iFrame]*R32;\r\n\t\tR33_t = vR31[iFrame]*R13 + vR32[iFrame]*R23 + vR33[iFrame]*R33;\r\n\r\n\t\tR11 = R11_t;\t\tR12 = R12_t;\t\tR13 = R13_t;\r\n\t\tR21 = R21_t;\t\tR22 = R22_t;\t\tR23 = R23_t;\r\n\t\tR31 = R31_t;\t\tR32 = R32_t;\t\tR33 = R33_t;\r\n\t}\r\n\t\r\n\tdouble qw = sqrt(abs(1.0+R11+R22+R33))/2;\r\n\tdouble qx, qy, qz;\r\n\tif (qw > QW_ZERO)\r\n\t{\r\n\t\tqx = (R32-R23)/4/qw;\r\n\t\tqy = (R13-R31)/4/qw;\r\n\t\tqz = (R21-R12)/4/qw;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdouble d = sqrt((R12*R12*R13*R13+R12*R12*R23*R23+R13*R13*R23*R23));\r\n\t\tqx = R12*R13/d;\r\n\t\tqy = R12*R23/d;\r\n\t\tqz = R13*R23/d;\r\n\t}\r\n\r\n\tdouble norm_q = sqrt(qx*qx+qy*qy+qz*qz+qw*qw);\r\n\thx[0] = qw/norm_q;\r\n\thx[1] = qx/norm_q;\r\n\thx[2] = qy/norm_q;\r\n\thx[3] = qz/norm_q;\r\n\r\n\t//cout << qw/norm_q << \" \" << qx/norm_q << \" \" << qy/norm_q << \" \" << qz/norm_q << endl;\r\n\tvector<CvMat *> *vx1 = (((AdditionalData *) adata)->vx1);\r\n\tvector<CvMat *> *vx2 = (((AdditionalData *) adata)->vx2);\r\n\r\n\tint idx = 4;\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tdouble E11 = -vm3[iFrame]*vR21[iFrame] + vm2[iFrame]*vR31[iFrame];\r\n\t\tdouble E12 = -vm3[iFrame]*vR22[iFrame] + vm2[iFrame]*vR32[iFrame];\r\n\t\tdouble E13 = -vm3[iFrame]*vR23[iFrame] + vm2[iFrame]*vR33[iFrame];\r\n\r\n\t\tdouble E21 = vm3[iFrame]*vR11[iFrame] - vm1[iFrame]*vR31[iFrame];\r\n\t\tdouble E22 = vm3[iFrame]*vR12[iFrame] - vm1[iFrame]*vR32[iFrame];\r\n\t\tdouble E23 = vm3[iFrame]*vR13[iFrame] - vm1[iFrame]*vR33[iFrame];\r\n\r\n\t\tdouble E31 = -vm2[iFrame]*vR11[iFrame] + vm1[iFrame]*vR21[iFrame];\r\n\t\tdouble E32 = -vm2[iFrame]*vR12[iFrame] + vm1[iFrame]*vR22[iFrame];\r\n\t\tdouble E33 = -vm2[iFrame]*vR13[iFrame] + vm1[iFrame]*vR23[iFrame];\r\n\r\n\t\tdouble out = 0;\r\n\t\tif ((*vx1)[iFrame]->rows == 1)\r\n\t\t\tcontinue;\r\n\t\tfor (int ix = 0; ix < (*vx1)[iFrame]->rows; ix++)\r\n\t\t{\r\n\t\t\tdouble x1 = cvGetReal2D((*vx1)[iFrame], ix, 0);\r\n\t\t\tdouble x2 = cvGetReal2D((*vx1)[iFrame], ix, 1);\r\n\t\t\tdouble x3 = 1;\r\n\r\n\t\t\tdouble xp1 = cvGetReal2D((*vx2)[iFrame], ix, 0);\r\n\t\t\tdouble xp2 = cvGetReal2D((*vx2)[iFrame], ix, 1);\r\n\t\t\tdouble xp3 = 1;\r\n\r\n\t\t\tdouble Ex1 = E11*x1 + E12*x2 + E13*x3;\r\n\t\t\tdouble Ex2 = E21*x1 + E22*x2 + E23*x3;\r\n\t\t\tdouble Ex3 = E31*x1 + E32*x2 + E33*x3;\r\n\r\n\t\t\tdouble Etxp1 = E11*xp1 + E21*xp2 + E31*xp3;\r\n\t\t\tdouble Etxp2 = E12*xp1 + E22*xp2 + E32*xp3;\r\n\t\t\tdouble Etxp3 = E13*xp1 + E23*xp2 + E33*xp3;\r\n\r\n\t\t\tdouble xpEx = xp1*Ex1 + xp2*Ex2 + xp3*Ex3;\r\n\r\n\t\t\tdouble dist = xpEx*xpEx * (1/(Ex1*Ex1+Ex2*Ex2)+1/(Etxp1*Etxp1+Etxp2*Etxp2));\r\n\r\n\t\t\tout += sqrt(dist)/(*vx1)[iFrame]->rows;\r\n\t\t\t//hx[idx] = dist;\r\n\t\t\t//idx++;\r\n\t\t}\t\r\n\t\tfor (int j = 0; j < 10; j++)\r\n\t\t{\r\n\t\t\tidx++;\r\n\t\t\thx[idx] = 0.1*out;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid ObjectiveOrientationRefinement1(double *rt, double *hx, int m, int n, void *adata)\r\n{\r\n\t// Set orientation\r\n\tdouble qw = (((AdditionalData *) adata)->qw);\r\n\tdouble qx = (((AdditionalData *) adata)->qx);\r\n\tdouble qy = (((AdditionalData *) adata)->qy);\r\n\tdouble qz = (((AdditionalData *) adata)->qz);\r\n\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\tqw /= q_norm;\r\n\tqx /= q_norm;\r\n\tqy /= q_norm;\r\n\tqz /= q_norm;\r\n\r\n\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\r\n\tdouble m1 = rt[0];\r\n\tdouble m2 = rt[1];\r\n\tdouble m3 = rt[2];\r\n\r\n\tdouble norm_m = sqrt(m1*m1+m2*m2+m3*m3);\r\n\tm1 /= norm_m;\r\n\tm2 /= norm_m;\r\n\tm3 /= norm_m;\r\n\r\n\tvector<double> *vx1 = (((AdditionalData *) adata)->vx1_a);\r\n\tvector<double> *vy1 = (((AdditionalData *) adata)->vy1_a);\r\n\r\n\tvector<double> *vx2 = (((AdditionalData *) adata)->vx2_a);\r\n\tvector<double> *vy2 = (((AdditionalData *) adata)->vy2_a);\r\n\r\n\tdouble E11 = -m3*R21 + m2*R31;\r\n\tdouble E12 = -m3*R22 + m2*R32;\r\n\tdouble E13 = -m3*R23 + m2*R33;\r\n\r\n\tdouble E21 = m3*R11 - m1*R31;\r\n\tdouble E22 = m3*R12 - m1*R32;\r\n\tdouble E23 = m3*R13 - m1*R33;\r\n\r\n\tdouble E31 = -m2*R11 + m1*R21;\r\n\tdouble E32 = -m2*R12 + m1*R22;\r\n\tdouble E33 = -m2*R13 + m1*R23;\r\n\r\n\tfor (int ix = 0; ix < (*vx1).size(); ix++)\r\n\t{\r\n\t\tdouble x1 = (*vx1)[ix];\r\n\t\tdouble x2 = (*vy1)[ix];\r\n\t\tdouble x3 = 1;\r\n\r\n\t\tdouble xp1 = (*vx2)[ix];\r\n\t\tdouble xp2 = (*vy2)[ix];\r\n\t\tdouble xp3 = 1;\r\n\r\n\t\tdouble Ex1 = E11*x1 + E12*x2 + E13*x3;\r\n\t\tdouble Ex2 = E21*x1 + E22*x2 + E23*x3;\r\n\t\tdouble Ex3 = E31*x1 + E32*x2 + E33*x3;\r\n\r\n\t\tdouble Etxp1 = E11*xp1 + E21*xp2 + E31*xp3;\r\n\t\tdouble Etxp2 = E12*xp1 + E22*xp2 + E32*xp3;\r\n\t\tdouble Etxp3 = E13*xp1 + E23*xp2 + E33*xp3;\r\n\r\n\t\tdouble xpEx = xp1*Ex1 + xp2*Ex2 + xp3*Ex3;\r\n\r\n\t\tdouble dist = xpEx*xpEx * (1/(Ex1*Ex1+Ex2*Ex2)+1/(Etxp1*Etxp1+Etxp2*Etxp2));\r\n\r\n\t\thx[ix] = 100*dist;\r\n\t}\t\r\n}\r\n\r\nvoid CameraCenterInterpolationWithDegree(CvMat *R_1, vector<int> vFrame1, vector<int> vFrame2, vector<CvMat *> vM, vector<CvMat *> vm,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t vector<int> vFrame1_r, vector<int> vFrame2_r, vector<CvMat *> vM_r, vector<CvMat *> vm_r, \r\n\t\t\t\t\t\t\t\t\t\t vector<CvMat *> vC_c, vector<CvMat *> vR_c, vector<int> vFrame_c, vector<CvMat *> &vC, vector<CvMat *> &vR, double weight)\r\n{\r\n\t// Frame normalization\r\n\tint first = vFrame1[0];\r\n\tfor (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n\t{\r\n\t\tvFrame1[iFrame] = vFrame1[iFrame] - first;\r\n\t\tvFrame2[iFrame] = vFrame2[iFrame] - first;\r\n\t\tdouble m1 = cvGetReal2D(vm[iFrame], 0, 0);\r\n\t\tdouble m2 = cvGetReal2D(vm[iFrame], 1, 0);\r\n\t\tdouble m3 = cvGetReal2D(vm[iFrame], 2, 0);\r\n\t\tdouble norm_m = sqrt(m1*m1+m2*m2+m3*m3);\r\n\t\tScalarMul(vm[iFrame], 1/norm_m, vm[iFrame]);\r\n\t}\r\n\r\n\tfor (int iFrame = 0; iFrame < vFrame1_r.size(); iFrame++)\r\n\t{\r\n\t\tvFrame1_r[iFrame] = vFrame1_r[iFrame] - first;\r\n\t\tvFrame2_r[iFrame] = vFrame2_r[iFrame] - first;\r\n\t\tdouble m1 = cvGetReal2D(vm_r[iFrame], 0, 0);\r\n\t\tdouble m2 = cvGetReal2D(vm_r[iFrame], 1, 0);\r\n\t\tdouble m3 = cvGetReal2D(vm_r[iFrame], 2, 0);\r\n\t\tdouble norm_m = sqrt(m1*m1+m2*m2+m3*m3);\r\n\t\tScalarMul(vm_r[iFrame], 1/norm_m, vm_r[iFrame]);\r\n\t}\r\n\r\n\tfor (int iFrame = 0; iFrame < vFrame_c.size(); iFrame++)\r\n\t{\r\n\t\tvFrame_c[iFrame] = vFrame_c[iFrame] - first;\r\n\t}\r\n\tint nFrames = vFrame_c[vFrame_c.size()-1] - vFrame_c[0]+1;\r\n\tvR.resize(nFrames);\r\n\tvector<bool> vIsR(nFrames, false);\r\n\tfor (int ic = 0; ic < vFrame_c.size(); ic++)\r\n\t{\r\n\t\tvR[vFrame_c[ic]] = cvCloneMat(vR_c[ic]);\r\n\t\tvIsR[vFrame_c[ic]] = true;\r\n\t}\r\n\tfor (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n\t{\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tint j = 0;\r\n\t\tif (!vIsR[vFrame1[iFrame]-j])\r\n\t\t{\r\n\t\t\twhile (!vIsR[vFrame1[iFrame]-j])\r\n\t\t\t{\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t\tfor (int i = j-1; i >= 0; i--)\r\n\t\t\t{\r\n\t\t\t\tvR[vFrame1[iFrame]-i] = cvCloneMat(vR[vFrame1[iFrame]-j]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcvMatMul(vM[iFrame], vR[vFrame1[iFrame]], R);\r\n\t\tvR[vFrame2[iFrame]] = cvCloneMat(R);\r\n\t\tvIsR[vFrame2[iFrame]] = true;\r\n\t\tcvReleaseMat(&R);\r\n\t}\r\n\r\n\tfor (int ic = 0; ic < vFrame_c.size(); ic++)\r\n\t{\r\n\t\tvR[vFrame_c[ic]] = cvCloneMat(vR_c[ic]);\r\n\t}\r\n\t\r\n\tint nBasis = floor((double)nFrames/3); \r\n\tCvMat *theta_all = cvCreateMat(nFrames, nFrames, CV_32FC1);\r\n\tGetIDCTMappingMatrix(theta_all, nFrames);\r\n\tCvMat *theta_i = cvCreateMat(1, nBasis, CV_32FC1);\r\n\tCvMat *Theta_i = cvCreateMat(3, 3*nBasis, CV_32FC1);\r\n\r\n\tCvMat *A = cvCreateMat(3*vM.size(), 3*nBasis, CV_32FC1);\r\n\tCvMat *b = cvCreateMat(3*vM.size(), 1, CV_32FC1);\r\n\tcvSetZero(b);\r\n\r\n\tfor (int im = 0; im < vM.size(); im++)\r\n\t{\r\n\t\tfor (int ith = 0; ith < nBasis; ith++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(theta_i, 0, ith, cvGetReal2D(theta_all, vFrame1[im], ith)-cvGetReal2D(theta_all, vFrame2[im], ith));\r\n\t\t}\r\n\t\tSetSubMat(Theta_i, 0, 0, theta_i);\r\n\t\tSetSubMat(Theta_i, 1, nBasis, theta_i);\r\n\t\tSetSubMat(Theta_i, 2, 2*nBasis, theta_i);\r\n\r\n\t\tCvMat *skewm = cvCreateMat(3,3,CV_32FC1);\r\n\t\tVec2Skew(vm[im], skewm);\r\n\t\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvMatMul(skewm, vR[vFrame2[im]], temp33);\r\n\t\tCvMat *temp3nBasis = cvCreateMat(3, 3*nBasis, CV_32FC1);\r\n\t\tcvMatMul(temp33, Theta_i, temp3nBasis);\r\n\t\tSetSubMat(A, 3*im, 0, temp3nBasis);\t\t\r\n\t\tcvReleaseMat(&skewm);\r\n\t\tcvReleaseMat(&temp33);\r\n\t\tcvReleaseMat(&temp3nBasis);\r\n\t}\r\n\r\n\tCvMat *A_r = cvCreateMat(3*vM_r.size(), 3*nBasis, CV_32FC1);\r\n\tCvMat *b_r = cvCreateMat(3*vM_r.size(), 1, CV_32FC1);\r\n\tcvSetZero(b_r);\r\n\r\n\tfor (int im = 0; im < vM_r.size(); im++)\r\n\t{\r\n\t\tfor (int ith = 0; ith < nBasis; ith++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(theta_i, 0, ith, cvGetReal2D(theta_all, vFrame1_r[im], ith)-cvGetReal2D(theta_all, vFrame2_r[im], ith));\r\n\t\t}\r\n\t\tSetSubMat(Theta_i, 0, 0, theta_i);\r\n\t\tSetSubMat(Theta_i, 1, nBasis, theta_i);\r\n\t\tSetSubMat(Theta_i, 2, 2*nBasis, theta_i);\r\n\r\n\t\tCvMat *skewm = cvCreateMat(3,3,CV_32FC1);\r\n\t\tVec2Skew(vm_r[im], skewm);\r\n\t\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvMatMul(skewm, vR[vFrame2_r[im]], temp33);\r\n\t\tCvMat *temp3nBasis = cvCreateMat(3, 3*nBasis, CV_32FC1);\r\n\t\tcvMatMul(temp33, Theta_i, temp3nBasis);\r\n\t\tSetSubMat(A_r, 3*im, 0, temp3nBasis);\t\r\n\t\tcvReleaseMat(&skewm);\r\n\t\tcvReleaseMat(&temp33);\r\n\t\tcvReleaseMat(&temp3nBasis);\r\n\t}\r\n\r\n\tCvMat *A_c = cvCreateMat(3*vFrame_c.size(), 3*nBasis, CV_32FC1);\r\n\tCvMat *b_c = cvCreateMat(3*vFrame_c.size(), 1, CV_32FC1);\r\n\r\n\tfor (int ic = 0; ic < vFrame_c.size(); ic++)\r\n\t{\r\n\t\tfor (int ith = 0; ith < nBasis; ith++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(theta_i, 0, ith, cvGetReal2D(theta_all, vFrame_c[ic], ith));\r\n\t\t}\r\n\t\tSetSubMat(Theta_i, 0, 0, theta_i);\r\n\t\tSetSubMat(Theta_i, 1, nBasis, theta_i);\r\n\t\tSetSubMat(Theta_i, 2, 2*nBasis, theta_i);\r\n\t\tSetSubMat(A_c, 3*ic, 0, Theta_i);\r\n\t\tSetSubMat(b_c, 3*ic, 0, vC_c[ic]);\r\n\t}\r\n\tScalarMul(A_c, weight, A_c);\r\n\tScalarMul(b_c, weight, b_c);\r\n\r\n\tCvMat *At = cvCreateMat(A->rows+A_r->rows+A_c->rows, A->cols, CV_32FC1);\r\n\tCvMat *bt = cvCreateMat(A->rows+A_r->rows+A_c->rows, 1, CV_32FC1);\t\r\n\r\n\tSetSubMat(At, 0, 0, A);\r\n\tSetSubMat(bt, 0, 0, b);\r\n\r\n\tSetSubMat(At, A->rows, 0, A_r);\r\n\tSetSubMat(bt, A->rows, 0, b_r);\r\n\r\n\tSetSubMat(At, A->rows+A_r->rows, 0, A_c);\r\n\tSetSubMat(bt, A->rows+A_r->rows, 0, b_c);\r\n\r\n\tCvMat *beta = cvCreateMat(3*nBasis, 1, CV_32FC1);\r\n\tcvSolve(At, bt, beta);\r\n\r\n\t//cvSolve(A_c, b_c, beta);\r\n\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tfor (int ith = 0; ith < nBasis; ith++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(theta_i, 0, ith, cvGetReal2D(theta_all, iFrame, ith));\r\n\t\t}\r\n\t\tSetSubMat(Theta_i, 0, 0, theta_i);\r\n\t\tSetSubMat(Theta_i, 1, nBasis, theta_i);\r\n\t\tSetSubMat(Theta_i, 2, 2*nBasis, theta_i);\r\n\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvMatMul(Theta_i, beta, C);\r\n\t\tvC.push_back(C);\r\n\t}\r\n\tcvReleaseMat(&beta);\r\n\tcvReleaseMat(&At);\r\n\tcvReleaseMat(&bt);\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&b);\r\n\tcvReleaseMat(&A_r);\r\n\tcvReleaseMat(&b_r);\r\n\tcvReleaseMat(&A_c);\r\n\tcvReleaseMat(&b_c);\r\n\tcvReleaseMat(&theta_all);\r\n\tcvReleaseMat(&theta_i);\r\n\tcvReleaseMat(&Theta_i);\r\n}\r\n\r\nvoid SparseBundleAdjustment_KDMOT(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> &cP, CvMat *X, vector<Camera> vCamera, vector<int> visibleStructureID)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment motion only\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\r\n\tGetParameterForSBA_KDRT(vFeature, vUsedFrame, cP, X, vCamera, max_nFrames, visibleStructureID, cameraParameter, feature2DParameter, vMask);\r\n\r\n\tint nCameraParam = 7+4+2;\r\n\tint nFeatures = vFeature.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\t\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tadata.XYZ = &(dCameraParameter[nCameraParam*vUsedFrame.size()]);\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-12;\r\n\topt[2] = 1e-12;\r\n\topt[3] = 1e-12;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_mot_levmar(visibleStructureID.size(), vUsedFrame.size(), 1, dVMask,  dCameraParameter, nCameraParam, dFeature2DParameter, dCovFeatures, 2, Projection3Donto2D_KDMOT, NULL, &adata,\r\n\t\t\t\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info);\r\n\tRetrieveParameterFromSBA_KDRT(dCameraParameter, vCamera, cP, X, visibleStructureID, vUsedFrame, max_nFrames);\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n}\r\n\r\n\r\nvoid SparseBundleAdjustment_TEMPORAL(vector<Feature> vFeature, vector<Theta> &vTheta, vector<Camera> &vCamera)\r\n{\r\n\tPrintAlgorithm(\"Sparse bundle adjustment - Temporal adjustment\");\r\n\tvector<double> cameraParameter, feature2DParameter;\r\n\tvector<char> vMask;\r\n\tdouble *dCovFeatures = 0;\r\n\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\r\n\tint max_nFrames = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t\t}\r\n\t}\r\n\tmax_nFrames++;\r\n\tadata.max_nFrames = max_nFrames;\r\n\tvector<int> vUsedFrame;\r\n\tvector<CvMat *> vP;\r\n\tvector<double> vdP;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tvUsedFrame.push_back(iCamera*max_nFrames+vCamera[iCamera].vTakenFrame[iFrame]);\r\n\t\t\tvP.push_back(vCamera[iCamera].vP[iFrame]);\r\n\t\t\tfor (int iP = 0; iP < 3; iP++)\r\n\t\t\t\tfor (int jP = 0; jP < 4; jP++)\r\n\t\t\t\t\tvdP.push_back(cvGetReal2D(vCamera[iCamera].vP[iFrame], iP, jP));\r\n\t\t}\r\n\t}\r\n\tadata.vUsedFrame = vUsedFrame;\r\n\tadata.vP = vP;\r\n\tadata.vdP = vdP;\r\n\tadata.nBase = vTheta[0].thetaX.size();\r\n\tadata.vTheta = vTheta;\r\n\r\n\tGetParameterForSBA_TEMPORAL(vFeature, vTheta, vCamera, max_nFrames, cameraParameter, feature2DParameter, vMask);\r\n\r\n\tint nCameraParam = 1;\r\n\tint nFeatures = vTheta.size(); \r\n\tint nFrames = vUsedFrame.size(); \r\n\tchar *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\tdouble *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t\tdCameraParameter[i] = cameraParameter[i];\r\n\tfor (int i = 0; i < vMask.size(); i++)\r\n\t\tdVMask[i] = vMask[i];\r\n\tfor (int i = 0; i < feature2DParameter.size(); i++)\r\n\t\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\tadata.XYZ = &(dCameraParameter[nCameraParam*vUsedFrame.size()]);\r\n\tdouble opt[5];\r\n\topt[0] = 1e-3;\r\n\topt[1] = 1e-5;\r\n\topt[2] = 1e-5;\r\n\topt[3] = 1e-5;\r\n\topt[4] = 0;\r\n\tdouble info[12];\r\n\tsba_motstr_levmar(vTheta.size(), 0, vUsedFrame.size(), 0, dVMask,  dCameraParameter, nCameraParam, 3*adata.nBase, dFeature2DParameter, dCovFeatures, 4, ProjectionThetaonto2D_TEMPORAL, NULL, &adata,\r\n\t\t1e+3, 0, opt, info);\r\n\tPrintSBAInfo(info);\r\n\tRetrieveParameterFromSBA_TEMPORAL(dCameraParameter, vCamera, vTheta);\r\n\r\n\tfree(dVMask);\r\n\tfree(dFeature2DParameter);\r\n\tfree(dCameraParameter);\r\n}\r\n\r\nvoid SparseBundleAdjustment_TEMPORAL_LEVMAR(vector<Feature> vFeature, vector<Theta> &vTheta, vector<Camera> &vCamera)\r\n{\r\n\t//for (int i = 0; i < 106; i++)\r\n\t//{\r\n\t//\tvFeature.pop_back();\r\n\t//\tvTheta.pop_back();\r\n\t//}\r\n\t//PrintAlgorithm(\"Sparse bundle adjustment - Temporal adjustment, Levenburg-Marquedt\");\r\n\t//vector<double> cameraParameter, feature2DParameter;\r\n\t//vector<char> vMask;\r\n\t//double *dCovFeatures = 0;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\r\n\t//int max_nFrames = 0;\r\n\t//for (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t//{\r\n\t//\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t//\t{\r\n\t//\t\tif (vCamera[iCamera].vTakenFrame[iFrame] > max_nFrames)\r\n\t//\t\t\tmax_nFrames = vCamera[iCamera].vTakenFrame[iFrame];\r\n\t//\t}\r\n\t//}\r\n\t//max_nFrames++;\r\n\t//adata.max_nFrames = max_nFrames;\r\n\t//vector<int> vUsedFrame;\r\n\t//vector<CvMat *> vP;\r\n\t//vector<double> vdP;\r\n\t//for (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t//{\r\n\t//\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t//\t{\r\n\t//\t\tvUsedFrame.push_back(iCamera*max_nFrames+vCamera[iCamera].vTakenFrame[iFrame]);\r\n\t//\t\tvP.push_back(vCamera[iCamera].vP[iFrame]);\r\n\t//\t\tfor (int iP = 0; iP < 3; iP++)\r\n\t//\t\t\tfor (int jP = 0; jP < 4; jP++)\r\n\t//\t\t\t\tvdP.push_back(cvGetReal2D(vCamera[iCamera].vP[iFrame], iP, jP));\r\n\t//\t}\r\n\t//}\r\n\t//adata.vUsedFrame = vUsedFrame;\r\n\t////adata.vP = vP;\r\n\t//adata.vdP = vdP;\r\n\t//adata.nBase = vTheta[0].thetaX.size();\r\n\t//adata.nFeatures = vTheta.size();\r\n\t//adata.vTheta = vTheta;\r\n\r\n\t//GetParameterForSBA_TEMPORAL_LEVMAR(vFeature, vTheta, vCamera, max_nFrames, cameraParameter, feature2DParameter);\r\n\r\n\t//int nCameraParam = 1;\r\n\t//int nFeatures = vTheta.size(); \r\n\t//int nFrames = vUsedFrame.size(); \r\n\t////char *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\t//double *dFeature2DParameter = (double *) malloc((feature2DParameter.size()+nFeatures) * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//\tdFeature2DParameter[i] = feature2DParameter[i]/1e-6;\r\n\t//for (int i = 0; i < nFeatures; i++)\r\n\t//\tdFeature2DParameter[feature2DParameter.size()+i] = 0.0;\r\n\r\n\t//adata.isStatic = false;\r\n\r\n\t////adata.XYZ = &(dCameraParameter[nCameraParam*vUsedFrame.size()]);\r\n\t//adata.measurements = feature2DParameter;\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-1;\r\n\t//opt[1] = 1e-20;\r\n\t//opt[2] = 1e-15;\r\n\t//opt[3] = 1e-15;\r\n\t//opt[4] = 0;\r\n\r\n\t//double info[12];\r\n\r\n\t//double *work = (double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), feature2DParameter.size()+nFeatures)+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n\t//if(!work)\r\n\t//\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\t//int ret = dlevmar_dif(ProjectionThetaonto2D_TEMPORAL_LEVMAR, dCameraParameter, dFeature2DParameter, cameraParameter.size(), feature2DParameter.size()+nFeatures,\r\n\t//\t1e+3, opt, info, work, NULL, &adata);\r\n\t//cout << ret << endl;\r\n\t//PrintSBAInfo(info);\r\n\t//RetrieveParameterFromSBA_TEMPORAL(dCameraParameter, vCamera, vTheta);\r\n\r\n\t//free(dFeature2DParameter);\r\n\t//free(dCameraParameter);\r\n}\r\n\r\n\r\n\r\n\r\nvoid GlobalBundleAdjustment(vector<Feature> vFeature, vector<Camera> vCamera, vector<Theta> vTheta, CvMat *K, int nFrames, int nBase, int nFeatures_static)\r\n{\r\n\t//PrintAlgorithm(\"Global bundle adjustment motion and structure\");\r\n\t//vector<double> cameraParameter, feature2DParameter;\r\n\t//vector<char> vMask;\r\n\t//double *dCovFeatures = 0;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//double intrinsic[4];\r\n\t//intrinsic[0] = cvGetReal2D(K, 0, 0);\r\n\t//intrinsic[1] = cvGetReal2D(K, 1, 1);\r\n\t//intrinsic[2] = cvGetReal2D(K, 0, 2);\r\n\t//intrinsic[3] = cvGetReal2D(K, 1, 2);\r\n\t//adata.intrinsic = intrinsic;\r\n\t//adata.nCameraParameters = 7;\r\n\t//adata.nImagePointPrameraters = 2;\r\n\t//adata.nBase = nBase;\r\n\t//adata.nFrames = nFrames;\r\n\t//adata.nFeature_static = nFeatures_static;\r\n\t//bool *isStatic = (bool *) malloc(vFeature.size() * sizeof(bool));\r\n\t//for (int iStatic = 0; iStatic < vFeature.size(); iStatic++)\r\n\t//{\r\n\t//\tif (iStatic < nFeatures_static)\r\n\t//\t\tisStatic[iStatic] = true;\r\n\t//\telse\r\n\t//\t\tisStatic[iStatic] = false;\r\n\t//}\r\n\t//adata.isStatic = isStatic;\r\n\t//GetParameterForGBA(vFeature, vCamera, vTheta, K, nFrames, cameraParameter, feature2DParameter, vMask);\r\n\r\n\t//int NZ = 0;\r\n\t//for (int i = 0; i < vMask.size(); i++)\r\n\t//{\r\n\t//\tif (vMask[i])\r\n\t//\t\tNZ++;\r\n\t//}\r\n\t//double nCameraParam = 7;\r\n\t//int nFeatures = vFeature.size();  \r\n\t//char *dVMask = (char *) malloc(vMask.size() * sizeof(char));\r\n\t//double *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < vMask.size(); i++)\r\n\t//\tdVMask[i] = vMask[i];\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-3;\r\n\t//opt[1] = 1e-5;//1e-12;\r\n\t//opt[2] = 1e-5;//1e-12;\r\n\t//opt[3] = 1e-5;//1e-12;\r\n\t//opt[4] = 0;\r\n\t//double info[12];\r\n\t//sba_motstr_levmar_x(vFeature.size(), 0, nFrames*vCamera.size(), 1, dVMask,  dCameraParameter, nCameraParam, 3*nBase, dFeature2DParameter, dCovFeatures, 2, ProjectionThetaonto2D_MOTSTR_x, NULL, &adata,\r\n\t//\t1e+3, 0, opt, info);\r\n\t//PrintSBAInfo(info);\r\n\t//RetrieveParameterFromGBA(dCameraParameter, K, vCamera, vTheta, nFrames);\r\n\r\n\t//free(isStatic);\r\n\t//free(dVMask);\r\n\t//free(dFeature2DParameter);\r\n\t//free(dCameraParameter);\r\n}\r\n\r\nvoid GlobalBundleAdjustment_LEVMAR(vector<Feature> vFeature, vector<Camera> vCamera, vector<Theta> vTheta, CvMat *K, int nFrames, int nBase, int nFeatures_static)\r\n{\r\n\t//PrintAlgorithm(\"Global bundle adjustment motion and structure\");\r\n\t//vector<double> cameraParameter, feature2DParameter;\r\n\t//double *dCovFeatures = 0;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t//double intrinsic[4];\r\n\t//intrinsic[0] = cvGetReal2D(K, 0, 0);\r\n\t//intrinsic[1] = cvGetReal2D(K, 1, 1);\r\n\t//intrinsic[2] = cvGetReal2D(K, 0, 2);\r\n\t//intrinsic[3] = cvGetReal2D(K, 1, 2);\r\n\t//adata.intrinsic = intrinsic;\r\n\t//adata.nCameraParameters = 7;\r\n\t//adata.nImagePointPrameraters = 2;\r\n\t//adata.nBase = nBase;\r\n\t//adata.nFrames = nFrames*vCamera.size();\r\n\t//adata.nFeature_static = nFeatures_static;\r\n\t//bool *isStatic = (bool *) malloc(vFeature.size() * sizeof(bool));\r\n\t//for (int iStatic = 0; iStatic < vFeature.size(); iStatic++)\r\n\t//{\r\n\t//\tif (iStatic < nFeatures_static)\r\n\t//\t\tisStatic[iStatic] = true;\r\n\t//\telse\r\n\t//\t\tisStatic[iStatic] = false;\r\n\t//}\r\n\t//adata.isStatic = isStatic;\r\n\t//adata.nNZ = (double)feature2DParameter.size()/2;\r\n\t//CvMat visibilityMask;\r\n\t//GetParameterForGBA(vFeature, vCamera, vTheta, K, nFrames, cameraParameter, feature2DParameter, visibilityMask);\r\n\t//CvMat *vMask = cvCreateMat(visibilityMask.rows, visibilityMask.cols, CV_32FC1);\r\n\t//vMask = cvCloneMat(&visibilityMask);\r\n\t//adata.visibilityMask = vMask;\r\n\r\n\t//double nCameraParam = 7;\r\n\t//int nFeatures = vFeature.size();  \r\n\t//double *dFeature2DParameter = (double *) malloc(feature2DParameter.size() * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-3;\r\n\t//opt[1] = 1e-5;//1e-12;\r\n\t//opt[2] = 1e-5;//1e-12;\r\n\t//opt[3] = 1e-5;//1e-12;\r\n\t//opt[4] = 0;\r\n\t//double info[12];\r\n\t//double *work=(double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), feature2DParameter.size())+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n\t//if(!work)\r\n\t//\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\t//feature2DParameter.clear();\r\n\t//cameraParameter.clear();\r\n\t//for (int i = 0; i < 10000;i++)\r\n\t//\tfeature2DParameter.push_back(0);\r\n\t//for (int i = 0; i < 10000-1; i++)\r\n\t//\tcameraParameter.push_back(0);\r\n\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < feature2DParameter.size(); i++)\r\n\t//\tdFeature2DParameter[i] = feature2DParameter[i];\r\n\t//slevmar_dif(ProjectionThetaonto2D_MOTSTR_LEVMAR, (float*)dCameraParameter, (float*)dFeature2DParameter, cameraParameter.size(), feature2DParameter.size(),\r\n\t//\t\t\t1e+3, (float*)opt, (float*)info, (float*)work, NULL, &adata);\r\n\r\n\t//PrintSBAInfo(info);\r\n\t//RetrieveParameterFromGBA(dCameraParameter, K, vCamera, vTheta, nFrames);\r\n\r\n\t//cvReleaseMat(&vMask);\r\n\t//free(isStatic);\r\n\t//free(dFeature2DParameter);\r\n\t//free(dCameraParameter);\r\n}\r\n\r\nvoid ProjectionThetaonto2D_MOTSTR_LEVMAR(double *p, double *hx, int m, int n, void *adata_)\r\n{\r\n\t//for (int i = 0; i <n; i++)\r\n\t//\thx[i] = 1;\r\n\t//return;\r\n\t//AdditionalData *adata = (AdditionalData *)adata_;\r\n\t//bool *isStatic = adata->isStatic;\r\n\t//int nFrames = adata->nFrames;\r\n\t//int nCameraParameters = adata->nCameraParameters;\r\n\t//int nImagePointParameters = adata->nImagePointPrameraters;\r\n\t//int nBase = adata->nBase;\r\n\t//int nFeature_static = adata->nFeature_static;\r\n\t//double *XYZ = p + nCameraParameters*nFrames;\r\n\t//double *rt;\r\n\t//double *xij;\r\n\t//\r\n\t//int last = 0;\r\n\t//for (int iFeature = 0; iFeature < ((AdditionalData*)adata_)->visibilityMask->rows; iFeature++)\r\n\t//{\r\n\t//\tfor (int iFrame = 0; iFrame < ((AdditionalData*)adata_)->visibilityMask->cols; iFrame++)\r\n\t//\t{\r\n\t//\t\tif (cvGetReal2D(((AdditionalData*)adata_)->visibilityMask, iFeature, iFrame))\r\n\t//\t\t{\r\n\t//\t\t\tif (isStatic[iFeature])\r\n\t//\t\t\t{\r\n\t//\t\t\t\tdouble x, y;\r\n\t//\t\t\t\t//xij = hx + nImagePointParameters*last;\r\n\t//\t\t\t\trt = p + iFrame*nCameraParameters;\r\n\t//\t\t\t\tXYZ = p + nFrames*nCameraParameters + iFeature*3;\r\n\t//\t\t\t\tProjectionThetaonto2D_MOTSTR_LEVMAR(iFrame, iFeature, rt, XYZ, x, y, adata);\r\n\t//\t\t\t\thx[nImagePointParameters*last] = 0;\r\n\t//\t\t\t\thx[nImagePointParameters*last+1] = 0;\r\n\t//\t\t\t\tlast++;\r\n\t//\t\t\t}\r\n\t//\t\t\telse\r\n\t//\t\t\t{\r\n\t//\t\t\t\tdouble x, y;\r\n\t//\t\t\t\t//xij = hx + nImagePointParameters*last;\r\n\t//\t\t\t\trt = p + iFrame*nCameraParameters;\r\n\t//\t\t\t\tXYZ = p + nFrames*nCameraParameters + nFeature_static*3 + (iFeature-nFeature_static)*3*nBase;\r\n\t//\t\t\t\tProjectionThetaonto2D_MOTSTR_LEVMAR(iFrame, iFeature, rt, XYZ, x, y, adata);\r\n\t//\t\t\t\thx[nImagePointParameters*last] = 0;\r\n\t//\t\t\t\thx[nImagePointParameters*last+1] = 0;\r\n\t//\t\t\t\tlast++;\r\n\t//\t\t\t}\t\t\t\t\r\n\t//\t\t}\r\n\t//\t}\r\n\t//}\r\n}\r\n\r\nvoid ProjectionThetaonto2D_TEMPORAL_LEVMAR(double *p, double *hx, int m, int n, void *adata)\r\n{\r\n\tif (!((AdditionalData *)adata)->isStatic)\r\n\t{\r\n\t\t((AdditionalData *)adata)->isStatic = true;\r\n\t\t((AdditionalData *)adata)->ptr = p;\r\n\t}\r\n\tp = ((AdditionalData *)adata)->ptr;\r\n\tfor (int ihx = 0; ihx < n; ihx++)\r\n\t\thx[ihx] = 0.0;\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tint nFeatures = ((AdditionalData *) adata)->nFeatures;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint nBase = ((AdditionalData*) adata)->nBase;\r\n\tvector<Theta> vTheta = ((AdditionalData *) adata)->vTheta;\r\n\tvector<double> measurements = ((AdditionalData *) adata)->measurements;\r\n\r\n\tfor (int iFeature = 0; iFeature < nFeatures; iFeature++)\r\n\t{\r\n\t\tdouble *xyz = p+vUsedFrame.size()+nBase*3*iFeature;\r\n\t\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tdouble *rt = p+iFrame;\r\n\r\n\t\t\tint iCamera = (int)((double)vUsedFrame[iFrame]/max_nFrames);\r\n\t\t\tint cFrame = vUsedFrame[iFrame] % max_nFrames;\r\n\t\t\tCvMat *P = cvCreateMat(3,4, CV_32FC1);\r\n\t\t\tfor (int iP = 0; iP < 3; iP++)\r\n\t\t\t\tfor (int jP = 0; jP < 4; jP++)\r\n\t\t\t\t\tcvSetReal2D(P, iP, jP, ((AdditionalData *) adata)->vdP[12*iFrame+iP*4+jP]);\r\n\t\t\tdouble dt = rt[0];\r\n\t\t\tdouble t = (double)cFrame + dt;\r\n\t\t\tCvMat *B = cvCreateMat(1, nBase, CV_32FC1);\r\n\t\t\tcvSetReal2D(B, 0, 0, sqrt(1.0/(double)max_nFrames));\r\n\t\t\tfor (int iB = 1; iB < nBase; iB++)\r\n\t\t\t\tcvSetReal2D(B, 0, iB, sqrt(2.0/(double)max_nFrames)*cos((2*t-1)*(iB)*PI/2.0/(double)max_nFrames));\r\n\r\n\t\t\tCvMat *thetaX = cvCreateMat(nBase,1, CV_32FC1);\r\n\t\t\tCvMat *thetaY = cvCreateMat(nBase,1, CV_32FC1);\r\n\t\t\tCvMat *thetaZ = cvCreateMat(nBase,1, CV_32FC1);\r\n\t\t\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\t\t\tcvSetReal2D(thetaX, iTheta, 0, xyz[iTheta]);\r\n\t\t\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\t\t\tcvSetReal2D(thetaY, iTheta, 0, xyz[nBase+iTheta]);\r\n\t\t\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\t\t\tcvSetReal2D(thetaZ, iTheta, 0, xyz[2*nBase+iTheta]);\r\n\r\n\t\t\tCvMat *X3 = cvCreateMat(1,1,CV_32FC1);\r\n\t\t\tCvMat *Y3 = cvCreateMat(1,1,CV_32FC1);\r\n\t\t\tCvMat *Z3 = cvCreateMat(1,1,CV_32FC1);\r\n\t\t\tcvMatMul(B, thetaX, X3);\r\n\t\t\tcvMatMul(B, thetaY, Y3);\r\n\t\t\tcvMatMul(B, thetaZ, Z3);\r\n\t\t\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X3,0,0));\r\n\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(Y3,0,0));\r\n\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(Z3,0,0));\r\n\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\r\n\t\t\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tcvMatMul(P, X, x);\r\n\r\n\t\t\tdouble pm_x = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\tdouble pm_y = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\tdouble m_x = measurements[2*(iFeature*vUsedFrame.size()+iFrame)];\r\n\t\t\tdouble m_y = measurements[2*(iFeature*vUsedFrame.size()+iFrame)+1];\r\n\t\t\t//hx[2*(iFeature*vUsedFrame.size()+iFrame)] = (pm_x-m_x)*(pm_x-m_x);\r\n\t\t\t//hx[2*(iFeature*vUsedFrame.size()+iFrame)+1] = (pm_y-m_y)*(pm_y-m_y);\r\n\r\n\t\t\thx[2*(iFeature*vUsedFrame.size()+iFrame)] = pm_x/1e-6;\r\n\t\t\thx[2*(iFeature*vUsedFrame.size()+iFrame)+1] = pm_y/1e-6;\r\n\r\n\t\t\tcvReleaseMat(&X);\r\n\t\t\tcvReleaseMat(&x);\r\n\t\t\tcvReleaseMat(&P);\r\n\t\t\tcvReleaseMat(&B);\r\n\t\t\tcvReleaseMat(&thetaX);\r\n\t\t\tcvReleaseMat(&thetaY);\r\n\t\t\tcvReleaseMat(&thetaZ);\r\n\t\t\tcvReleaseMat(&X3);\r\n\t\t\tcvReleaseMat(&Y3);\r\n\t\t\tcvReleaseMat(&Z3);\r\n\t\t}\r\n\t\tint error = 0;\r\n\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t{\r\n\t\t\terror += (xyz[iBase]-vTheta[iFeature].thetaX[iBase])*(xyz[iBase]-vTheta[iFeature].thetaX[iBase]);\r\n\t\t}\r\n\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t{\r\n\t\t\terror += (xyz[nBase+iBase]-vTheta[iFeature].thetaY[iBase])*(xyz[nBase+iBase]-vTheta[iFeature].thetaY[iBase]);\r\n\t\t}\r\n\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t{\r\n\t\t\terror += (xyz[2*nBase+iBase]-vTheta[iFeature].thetaZ[iBase])*(xyz[2*nBase+iBase]-vTheta[iFeature].thetaZ[iBase]);\r\n\t\t}\r\n\r\n\t\thx[2*(nFeatures*vUsedFrame.size())+iFeature] = 0.0;//error/10;\r\n\t}\r\n\t//for (int i = 0; i < n; i++)\r\n\t//\tcout << hx[i] << \" \";\r\n\t//cout << endl;\r\n}\r\n\r\nvoid ProjectionThetaonto2D_MOTSTR_LEVMAR(float *p, float *hx, int m, int n, void *adata_)\r\n{\r\n\t//for (int i = 0; i <n; i++)\r\n\t//\thx[i] = 1;\r\n\t//return;\r\n\t//AdditionalData *adata = (AdditionalData *)adata_;\r\n\t//bool *isStatic = adata->isStatic;\r\n\t//int nFrames = adata->nFrames;\r\n\t//int nCameraParameters = adata->nCameraParameters;\r\n\t//int nImagePointParameters = adata->nImagePointPrameraters;\r\n\t//int nBase = adata->nBase;\r\n\t//int nFeature_static = adata->nFeature_static;\r\n\t//float *XYZ = p + nCameraParameters*nFrames;\r\n\t//float *rt;\r\n\t//float *xij;\r\n\r\n\t//int last = 0;\r\n\t////for (int iFeature = 0; iFeature < ((AdditionalData*)adata_)->visibilityMask->rows; iFeature++)\r\n\t////{\r\n\t////\tfor (int iFrame = 0; iFrame < ((AdditionalData*)adata_)->visibilityMask->cols; iFrame++)\r\n\t////\t{\r\n\t////\t\tif (cvGetReal2D(((AdditionalData*)adata_)->visibilityMask, iFeature, iFrame))\r\n\t////\t\t{\r\n\t////\t\t\tif (isStatic[iFeature])\r\n\t////\t\t\t{\r\n\t////\t\t\t\tfloat x, y;\r\n\t////\t\t\t\t//xij = hx + nImagePointParameters*last;\r\n\t////\t\t\t\trt = p + iFrame*nCameraParameters;\r\n\t////\t\t\t\tXYZ = p + nFrames*nCameraParameters + iFeature*3;\r\n\t////\t\t\t\tProjectionThetaonto2D_MOTSTR_LEVMAR(iFrame, iFeature, (double*)rt, (double*)XYZ, (double)x, (double)y, adata);\r\n\t////\t\t\t\thx[nImagePointParameters*last] = 0;\r\n\t////\t\t\t\thx[nImagePointParameters*last+1] = 0;\r\n\t////\t\t\t\tlast++;\r\n\t////\t\t\t}\r\n\t////\t\t\telse\r\n\t////\t\t\t{\r\n\t////\t\t\t\tfloat x, y;\r\n\t////\t\t\t\t//xij = hx + nImagePointParameters*last;\r\n\t////\t\t\t\trt = p + iFrame*nCameraParameters;\r\n\t////\t\t\t\tXYZ = p + nFrames*nCameraParameters + nFeature_static*3 + (iFeature-nFeature_static)*3*nBase;\r\n\t////\t\t\t\tProjectionThetaonto2D_MOTSTR_LEVMAR(iFrame, iFeature, (double*)rt, (double*)XYZ, (double)x, (double)y, adata);\r\n\t////\t\t\t\thx[nImagePointParameters*last] = 0;\r\n\t////\t\t\t\thx[nImagePointParameters*last+1] = 0;\r\n\t////\t\t\t\tlast++;\r\n\t////\t\t\t}\t\t\t\t\r\n\t////\t\t}\r\n\t////\t}\r\n\t////}\r\n}\r\n\r\n\r\nvoid ProjectionThetaonto2D_MOTSTR_x(double *p, struct sba_crsm *idxij, int *rcidxs, int *rcsubs, double *hx, void *adata)\r\n{\r\n\t//int i, j;\r\n\t//int cnp, pnp, mnp;\r\n\t//double *pa, *pb, *pqr, *pt, *ppt, *pmeas, *Kparms, *pr0, lrot[4], trot[4];\r\n\t////int n;\r\n\t//int m, nnz;\r\n\t//AdditionalData *gl;\r\n\r\n\t//gl= (AdditionalData *)adata;\r\n\t//cnp=gl->nCameraParameters; \r\n\t//mnp=gl->nImagePointPrameraters;\r\n\r\n\t////n=idxij->nr;\r\n\t//m=idxij->nc;\r\n\t//pa=p; // Pointer for camera\r\n\t//pb=p+m*cnp; // Point for xyz\r\n\r\n\t//for(j=0; j<m; ++j)\r\n\t//{\r\n\t//\t/* j-th camera parameters */\r\n\t//\tdouble *rt = pa + j*cnp;\r\n\t//\tdouble *xyz;\r\n\t//\tnnz=sba_crsm_col_elmidxs(idxij, j, rcidxs, rcsubs); /* find nonzero hx_ij, i=0...n-1 */\r\n\r\n\t//\tfor(i=0; i<nnz; ++i)\r\n\t//\t{\r\n\t//\t\tif (gl->isStatic[i])\r\n\t//\t\t{\r\n\t//\t\t\txyz = pb + rcsubs[i]*3;\r\n\t//\t\t}\r\n\t//\t\telse\r\n\t//\t\t{\r\n\t//\t\t\txyz = pb + gl->nFeature_static*3 + (rcsubs[i]-gl->nFeature_static)*3*gl->nBase;\r\n\t//\t\t}\r\n\t//\t\tdouble *xij = hx + idxij->val[rcidxs[i]]*mnp; // set pmeas to point to hx_ij\r\n\r\n\t//\t\tProjectionThetaonto2D_MOTSTR(j, i, rt, xyz, xij, adata);\r\n\t//\t\t//calcImgProjFullR(Kparms, trot, pt, ppt, pmeas); // evaluate Q in pmeas\r\n\t//\t\t//calcImgProj(Kparms, pr0, pqr, pt, ppt, pmeas); // evaluate Q in pmeas\r\n\t//\t}\r\n\t//}\r\n}\r\n\r\nvoid PrintSBAInfo(double *info)\r\n{\r\n\tcout << \"SBA result -------\" << endl;\r\n\tcout << \"Mean squared reprojection error: \" << info[0] << \" ==> \" << info[1] << endl;\r\n\tcout << \"Total number of iteration: \" << info[5] << endl;\r\n\tcout << \"Reason for terminating: \";\r\n\tif (info[6] == 1)\r\n\t\tcout << \"Stopped by small ||J^T e||\" <<endl;\r\n\telse if (info[6] == 2)\r\n\t\tcout << \"Stopped by small ||delta||\" << endl;\r\n\telse if (info[6] == 3)\r\n\t\tcout << \"Stopped by maximum iteration\" << endl;\r\n\telse if (info[6] == 4)\r\n\t\tcout << \"Stopped by small relative reduction in ||e||\" << endl;\r\n\telse if (info[6] == 5)\r\n\t\tcout << \"Stopped by small ||e||\" << endl;\r\n\telse if (info[6] == 6)\r\n\t\tcout << \"Stopped due to excessive failed attempts to increase damping for getting a positive definite normal equations\" << endl;\r\n\telse if (info[6] == 7)\r\n\t\tcout << \"Stopped due to infinite values in the coordinates of the set of predicted projections x\" << endl;\r\n\tcout << \"Total number of projection function evaluation: \" << info[7] <<endl;\r\n\tcout << \"Total number of times that normal equations were solved: \" << info[9] << endl;\r\n \r\n}\r\n\r\nvoid PrintSBAInfo(double *info, int nVisiblePoints)\r\n{\r\n\tcout << \"SBA result -------\" << endl;\r\n\tcout << \"Mean squared reprojection error: \" << info[0]/(double)nVisiblePoints << \" ==> \" << info[1]/(double)nVisiblePoints << endl;\r\n\tcout << \"Total number of iteration: \" << info[5] << endl;\r\n\tcout << \"Reason for terminating: \";\r\n\tif (info[6] == 1)\r\n\t\tcout << \"Stopped by small ||J^T e||\" <<endl;\r\n\telse if (info[6] == 2)\r\n\t\tcout << \"Stopped by small ||delta||\" << endl;\r\n\telse if (info[6] == 3)\r\n\t\tcout << \"Stopped by maximum iteration\" << endl;\r\n\telse if (info[6] == 4)\r\n\t\tcout << \"Stopped by small relative reduction in ||e||\" << endl;\r\n\telse if (info[6] == 5)\r\n\t\tcout << \"Stopped by small ||e||\" << endl;\r\n\telse if (info[6] == 6)\r\n\t\tcout << \"Stopped due to excessive failed attempts to increase damping for getting a positive definite normal equations\" << endl;\r\n\telse if (info[6] == 7)\r\n\t\tcout << \"Stopped due to infinite values in the coordinates of the set of predicted projections x\" << endl;\r\n\tcout << \"Total number of projection function evaluation: \" << info[7] <<endl;\r\n\tcout << \"Total number of times that normal equations were solved: \" << info[9] << endl;\r\n\r\n}\r\n\r\nvoid RetrieveParameterFromSBA(double *dCameraParameter, CvMat *K, vector<CvMat *> &cP, CvMat *X, vector<int> visibleStructureID)\r\n{\t\r\n\tint nFrames = cP.size();\r\n\tcP.clear();\r\n\tCvMat *P;\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[7*iFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[7*iFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[7*iFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[7*iFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[7*iFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[7*iFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[7*iFrame+6]);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\t\tP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, K, P_);\r\n\t\tP = cvCloneMat(P_);\r\n\r\n\t\tcP.push_back(P);\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&P_);\r\n\t}\r\n\tP = cvCreateMat(3,4,CV_32FC1);\r\n\tcvReleaseMat(&P);\r\n\r\n\tCvMat *X_ = cvCreateMat(visibleStructureID.size(), 3, CV_32FC1);\r\n\r\n\tfor (int iFeature = 0; iFeature < visibleStructureID.size(); iFeature++)\r\n\t{\r\n\t\tcvSetReal2D(X_, iFeature, 0, dCameraParameter[7*cP.size()+3*iFeature]);\r\n\t\tcvSetReal2D(X_, iFeature, 1, dCameraParameter[7*cP.size()+3*iFeature+1]);\r\n\t\tcvSetReal2D(X_, iFeature, 2, dCameraParameter[7*cP.size()+3*iFeature+2]);\r\n\t}\r\n\tSetIndexedMatRowwise(X, visibleStructureID, X_);\r\n}\r\n\r\nvoid RetrieveParameterFromSBA_mem(double *dCameraParameter, vector<Camera> vCamera, vector<CvMat *> &cP, CvMat *X, vector<int> visibleStructureID, vector<int> vUsedFrame, int max_nFrames)\r\n{\t\r\n\tint nFrames = cP.size();\r\n\tfor (int i = 0; i < cP.size(); i++)\t\r\n\t\tcvReleaseMat(&(cP[i]));\r\n\tcP.clear();\r\n\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tint frame = vUsedFrame[iFrame]%max_nFrames;\r\n\t\tint cam = (int) vUsedFrame[iFrame]/max_nFrames;\r\n\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[7*iFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[7*iFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[7*iFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[7*iFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[7*iFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[7*iFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[7*iFrame+6]);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, vCamera[cam].vK[frame], P);\r\n\r\n\t\tcP.push_back(P);\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t}\r\n\r\n\tCvMat *X_ = cvCreateMat(visibleStructureID.size(), 3, CV_32FC1);\r\n\r\n\tfor (int iFeature = 0; iFeature < visibleStructureID.size(); iFeature++)\r\n\t{\r\n\t\tcvSetReal2D(X_, iFeature, 0, dCameraParameter[7*cP.size()+3*iFeature]);\r\n\t\tcvSetReal2D(X_, iFeature, 1, dCameraParameter[7*cP.size()+3*iFeature+1]);\r\n\t\tcvSetReal2D(X_, iFeature, 2, dCameraParameter[7*cP.size()+3*iFeature+2]);\r\n\t}\r\n\tSetIndexedMatRowwise(X, visibleStructureID, X_);\r\n\tcvReleaseMat(&X_);\r\n}\r\n\r\nvoid RetrieveParameterFromSBA(double *dCameraParameter, vector<Camera> vCamera, vector<CvMat *> &cP, CvMat *X, vector<int> visibleStructureID, vector<int> vUsedFrame, int max_nFrames)\r\n{\t\r\n\tint nFrames = cP.size();\r\n\tcP.clear();\r\n\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tint frame = vUsedFrame[iFrame]%max_nFrames;\r\n\t\tint cam = (int) vUsedFrame[iFrame]/max_nFrames;\r\n\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[7*iFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[7*iFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[7*iFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[7*iFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[7*iFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[7*iFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[7*iFrame+6]);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, vCamera[cam].K, P);\r\n\r\n\t\tcP.push_back(P);\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t}\r\n\r\n\tCvMat *X_ = cvCreateMat(visibleStructureID.size(), 3, CV_32FC1);\r\n\r\n\tfor (int iFeature = 0; iFeature < visibleStructureID.size(); iFeature++)\r\n\t{\r\n\t\tcvSetReal2D(X_, iFeature, 0, dCameraParameter[7*cP.size()+3*iFeature]);\r\n\t\tcvSetReal2D(X_, iFeature, 1, dCameraParameter[7*cP.size()+3*iFeature+1]);\r\n\t\tcvSetReal2D(X_, iFeature, 2, dCameraParameter[7*cP.size()+3*iFeature+2]);\r\n\t}\r\n\tSetIndexedMatRowwise(X, visibleStructureID, X_);\r\n\tcvReleaseMat(&X_);\r\n}\r\n\r\nvoid RetrieveParameterFromSBA_KRT(double *dCameraParameter, vector<Camera> vCamera, vector<CvMat *> &cP, CvMat *X, vector<int> visibleStructureID, vector<int> vUsedFrame, int max_nFrames)\r\n{\t\r\n\tint nFrames = cP.size();\r\n\tcP.clear();\r\n\tCvMat *P;\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tint frame = vUsedFrame[iFrame]%max_nFrames;\r\n\t\tint cam = (int) vUsedFrame[iFrame]/max_nFrames;\r\n\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[11*iFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[11*iFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[11*iFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[11*iFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[11*iFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[11*iFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[11*iFrame+6]);\r\n\r\n\t\tvector<int>::const_iterator it = find(vCamera[cam].vTakenFrame.begin(), vCamera[cam].vTakenFrame.end(), frame);\r\n\t\tif (it == vCamera[cam].vTakenFrame.end())\r\n\t\t\treturn;\r\n\t\tint iTakenFrame = (int) (it - vCamera[cam].vTakenFrame.begin());\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 0, 0, dCameraParameter[11*iFrame+7]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 1, 1, dCameraParameter[11*iFrame+8]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 0, 2, dCameraParameter[11*iFrame+9]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 1, 2, dCameraParameter[11*iFrame+10]);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\t\tP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, vCamera[cam].vK[iTakenFrame], P_);\r\n\t\tP = cvCloneMat(P_);\r\n\r\n\t\tcP.push_back(P);\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&P_);\r\n\t}\r\n\tP = cvCreateMat(3,4,CV_32FC1);\r\n\tcvReleaseMat(&P);\r\n\r\n\tCvMat *X_ = cvCreateMat(visibleStructureID.size(), 3, CV_32FC1);\r\n\r\n\tfor (int iFeature = 0; iFeature < visibleStructureID.size(); iFeature++)\r\n\t{\r\n\t\tcvSetReal2D(X_, iFeature, 0, dCameraParameter[11*cP.size()+3*iFeature]);\r\n\t\tcvSetReal2D(X_, iFeature, 1, dCameraParameter[11*cP.size()+3*iFeature+1]);\r\n\t\tcvSetReal2D(X_, iFeature, 2, dCameraParameter[11*cP.size()+3*iFeature+2]);\r\n\t}\r\n\tSetIndexedMatRowwise(X, visibleStructureID, X_);\r\n\tcvReleaseMat(&X_);\r\n}\r\n\r\n\r\nvoid RetrieveParameterFromSBA_TEMPORAL(double *dCameraParameter, vector<Camera> &vCamera, vector<Theta> &vTheta)\r\n{\t\r\n\tint cFrame = 0;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tvCamera[iCamera].vTakenInstant.push_back(vCamera[iCamera].vTakenFrame[iFrame]+dCameraParameter[cFrame]);\r\n\t\t\tcout << vCamera[iCamera].vTakenFrame[iFrame]+dCameraParameter[cFrame] << \" \";\r\n\t\t\tcFrame++;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tTheta theta;\r\n\t\ttheta = vTheta[iTheta];\r\n\t\ttheta.thetaX.clear();\r\n\t\ttheta.thetaY.clear();\r\n\t\ttheta.thetaZ.clear();\r\n\t\tfor (int i = 0; i < vTheta[0].thetaX.size(); i++)\t\r\n\t\t{\r\n\t\t\ttheta.thetaX.push_back(dCameraParameter[cFrame]);\r\n\t\t\tcFrame++;\r\n\t\t}\r\n\t\tfor (int i = 0; i < vTheta[0].thetaX.size(); i++)\t\r\n\t\t{\r\n\t\t\ttheta.thetaY.push_back(dCameraParameter[cFrame]);\r\n\t\t\tcFrame++;\r\n\t\t}\r\n\t\tfor (int i = 0; i < vTheta[0].thetaX.size(); i++)\t\r\n\t\t{\r\n\t\t\ttheta.thetaZ.push_back(dCameraParameter[cFrame]);\r\n\t\t\tcFrame++;\r\n\t\t}\r\n\r\n\t\tvTheta[iTheta] = theta;\r\n\t}\r\n}\r\n\r\nvoid RetrieveParameterFromSBA_KDRT(double *dCameraParameter, vector<Camera> vCamera, vector<CvMat *> &cP, CvMat *X, vector<int> visibleStructureID, vector<int> vUsedFrame, int max_nFrames)\r\n{\t\r\n\tint nFrames = cP.size();\r\n\tcP.clear();\r\n\tCvMat *P;\r\n\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t{\r\n\t\tint frame = vUsedFrame[iFrame]%max_nFrames;\r\n\t\tint cam = (int) vUsedFrame[iFrame]/max_nFrames;\r\n\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[13*iFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[13*iFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[13*iFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[13*iFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[13*iFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[13*iFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[13*iFrame+6]);\r\n\r\n\t\tvector<int>::const_iterator it = find(vCamera[cam].vTakenFrame.begin(), vCamera[cam].vTakenFrame.end(), frame);\r\n\t\tif (it == vCamera[cam].vTakenFrame.end())\r\n\t\t\treturn;\r\n\t\tint iTakenFrame = (int) (it - vCamera[cam].vTakenFrame.begin());\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 0, 0, dCameraParameter[13*iFrame+7]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 1, 1, dCameraParameter[13*iFrame+8]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 0, 2, dCameraParameter[13*iFrame+9]);\r\n\t\tcvSetReal2D(vCamera[cam].vK[iTakenFrame], 1, 2, dCameraParameter[13*iFrame+10]);\r\n\t\tvCamera[cam].vk1[iTakenFrame] = dCameraParameter[13*iFrame+11];\r\n\t\tvCamera[cam].vk2[iTakenFrame] = dCameraParameter[13*iFrame+12];\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\t\tP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, vCamera[cam].vK[iTakenFrame], P_);\r\n\t\tP = cvCloneMat(P_);\r\n\r\n\t\tcP.push_back(P);\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&P_);\r\n\t}\r\n\tP = cvCreateMat(3,4,CV_32FC1);\r\n\tcvReleaseMat(&P);\r\n\r\n\tCvMat *X_ = cvCreateMat(visibleStructureID.size(), 3, CV_32FC1);\r\n\r\n\tfor (int iFeature = 0; iFeature < visibleStructureID.size(); iFeature++)\r\n\t{\r\n\t\tcvSetReal2D(X_, iFeature, 0, dCameraParameter[13*cP.size()+3*iFeature]);\r\n\t\tcvSetReal2D(X_, iFeature, 1, dCameraParameter[13*cP.size()+3*iFeature+1]);\r\n\t\tcvSetReal2D(X_, iFeature, 2, dCameraParameter[13*cP.size()+3*iFeature+2]);\r\n\t}\r\n\tSetIndexedMatRowwise(X, visibleStructureID, X_);\r\n\tcvReleaseMat(&X_);\r\n}\r\n\r\n\r\nvoid RetrieveParameterFromGBA(double *dCameraParameter, CvMat *K, vector<Camera> &vCamera, vector<Theta> &vTheta, int nFrames)\r\n{\t\r\n\tCvMat *P;\r\n\tfor (int cFrame = 0; cFrame < nFrames*vCamera.size(); cFrame++)\r\n\t{\r\n\t\tint iFrame = cFrame % nFrames;\r\n\t\tint iCamera = (int) cFrame / nFrames;\r\n\t\tvector<int>::const_iterator it = find(vCamera[iCamera].vTakenFrame.begin(), vCamera[iCamera].vTakenFrame.end(), iFrame);\r\n\t\tif (it == vCamera[iCamera].vTakenFrame.end())\r\n\t\t\tcontinue;\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSetReal2D(q, 0, 0, dCameraParameter[7*cFrame]);\r\n\t\tcvSetReal2D(q, 1, 0, dCameraParameter[7*cFrame+1]);\r\n\t\tcvSetReal2D(q, 2, 0, dCameraParameter[7*cFrame+2]);\r\n\t\tcvSetReal2D(q, 3, 0, dCameraParameter[7*cFrame+3]);\r\n\t\tcvSetReal2D(C, 0, 0, dCameraParameter[7*cFrame+4]);\r\n\t\tcvSetReal2D(C, 1, 0, dCameraParameter[7*cFrame+5]);\r\n\t\tcvSetReal2D(C, 2, 0, dCameraParameter[7*cFrame+6]);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *P_ = cvCreateMat(3,4,CV_32FC1);\r\n\t\tP = cvCreateMat(3,4,CV_32FC1);\r\n\t\tQuaternion2Rotation(q, R);\r\n\t\tCreateCameraMatrix(R, C, K, P_);\r\n\t\tP = cvCloneMat(P_);\r\n\r\n\t\tint idx = (int) (it - vCamera[iCamera].vTakenFrame.begin());\r\n\t\tvCamera[iCamera].vP[idx] = P;\r\n\t\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&C);\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&P_);\r\n\t}\r\n\tP = cvCreateMat(3,4,CV_32FC1);\r\n\tcvReleaseMat(&P);\r\n\r\n\tCvMat *A = cvCreateMat(nFrames, nFrames, CV_32FC1);\r\n\tGetDCTMappingMatrix(A, nFrames);\r\n\tCvMat *A1 = cvCreateMat(1, nFrames, CV_32FC1);\r\n\tGetSubMatRowwise(A, 0, 0, A1);\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tint nBase = vTheta[iTheta].thetaX.size();\r\n\t\tif (vTheta[iTheta].isStatic)\r\n\t\t{\r\n\t\t\tCvMat *X = cvCreateMat(nFrames, 1, CV_32FC1);\r\n\t\t\tCvMat *theta1 = cvCreateMat(1,1,CV_32FC1);\r\n\t\t\tfor (int iX = 0; iX < nFrames; iX++)\r\n\t\t\t{\r\n\t\t\t\tcvSetReal2D(X, iX, 0, dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta]);\r\n\t\t\t}\r\n\t\t\tcvMatMul(A1, X, theta1);\r\n\t\t\tvTheta[iTheta].thetaX[0] = cvGetReal2D(theta1, 0, 0);\r\n\t\t\tfor (int iBase = 1; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaX[iBase] = 0;\r\n\r\n\t\t\tfor (int iX = 0; iX < nFrames; iX++)\r\n\t\t\t{\r\n\t\t\t\tcvSetReal2D(X, iX, 0, dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta+1]);\r\n\t\t\t}\r\n\t\t\tcvMatMul(A1, X, theta1);\r\n\t\t\tvTheta[iTheta].thetaY[0] = cvGetReal2D(theta1, 0, 0);\r\n\t\t\tfor (int iBase = 1; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaY[iBase] = 0;\r\n\r\n\t\t\tfor (int iX = 0; iX < nFrames; iX++)\r\n\t\t\t{\r\n\t\t\t\tcvSetReal2D(X, iX, 0, dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta+2]);\r\n\t\t\t}\r\n\t\t\tcvMatMul(A1, X, theta1);\r\n\t\t\tvTheta[iTheta].thetaZ[0] = cvGetReal2D(theta1, 0, 0);\r\n\t\t\tfor (int iBase = 1; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaZ[iBase] = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaX[iBase] = dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta+3+iBase];\r\n\t\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaY[iBase] = dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta+3+nBase+iBase];\r\n\t\t\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t\t\t\tvTheta[iTheta].thetaZ[iBase] = dCameraParameter[7*nFrames*vCamera.size()+3*(1+nBase)*iTheta+3+2*nBase+iBase];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Projection3Donto2D_MOTSTR(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tCvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetIdentity(K);\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\t//double *intrinsic = (((AdditionalData *) adata)->vIntrinsic)[iCamera];\r\n\tcvSetReal2D(K, 0, 0, ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[0]);\r\n\tcvSetReal2D(K, 1, 1, ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[1]);\r\n\tcvSetReal2D(K, 0, 2, ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[2]);\r\n\tcvSetReal2D(K, 1, 2, ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[3]);\r\n\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetReal2D(q, 0, 0, rt[0]);\r\n\tcvSetReal2D(q, 1, 0, rt[1]);\r\n\tcvSetReal2D(q, 2, 0, rt[2]);\r\n\tcvSetReal2D(q, 3, 0, rt[3]);\r\n\tcvSetReal2D(C, 0, 0, rt[4]);\r\n\tcvSetReal2D(C, 1, 0, rt[5]);\r\n\tcvSetReal2D(C, 2, 0, rt[6]);\r\n\tQuaternion2Rotation(q, R);\r\n\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\tcvMatMul(K, R, temp33);\r\n\tcvSetIdentity(P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(P, 0,3,C);\r\n\tcvMatMul(temp33, P, P);\r\n\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\tcvSetReal2D(X, 0, 0, xyz[0]);\r\n\tcvSetReal2D(X, 1, 0, xyz[1]);\r\n\tcvSetReal2D(X, 2, 0, xyz[2]);\r\n\tcvSetReal2D(X, 3, 0, 1);\r\n\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\tcvMatMul(P, X, x);\r\n\r\n\tif (j == 1)\r\n\t\tint k = 1;\r\n\r\n\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\tcvReleaseMat(&K);\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tcvReleaseMat(&P);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&q);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n}\r\n\r\nvoid Projection3Donto2D_MOTSTR_fast(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\tint iFrame = vUsedFrame[j] % max_nFrames;\r\n\tif (j == 1)\r\n\t\tint k = 1;\r\n\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[iFrame])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[iFrame])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[iFrame])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[iFrame])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\t// Set orientation\r\n\tdouble qw = rt[0];\r\n\tdouble qx = rt[1];\r\n\tdouble qy = rt[2];\r\n\tdouble qz = rt[3];\r\n\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\tqw /= q_norm;\r\n\tqx /= q_norm;\r\n\tqy /= q_norm;\r\n\tqz /= q_norm;\r\n\t\r\n\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\r\n\t//cout << R11 << \" \" << R12 << \" \" << R13 << endl;\r\n\t//cout << R21 << \" \" << R22 << \" \" << R23 << endl;\r\n\t//cout << R31 << \" \" << R32 << \" \" << R33 << endl;\r\n\r\n\t// Set translation\r\n\tdouble C1 = rt[4];\r\n\tdouble C2 = rt[5];\r\n\tdouble C3 = rt[6];\r\n\r\n\tdouble X1 = xyz[0];\r\n\tdouble X2 = xyz[1];\r\n\tdouble X3 = xyz[2];\r\n\r\n\t// Building projection \r\n\tdouble RX1 = R11*X1+R12*X2+R13*X3;\r\n\tdouble RX2 = R21*X1+R22*X2+R23*X3;\r\n\tdouble RX3 = R31*X1+R32*X2+R33*X3;\r\n\r\n\tdouble KRX1 = K11*RX1+K12*RX2+K13*RX3;\r\n\tdouble KRX2 = K21*RX1+K22*RX2+K23*RX3;\r\n\tdouble KRX3 = K31*RX1+K32*RX2+K33*RX3;\r\n\r\n\tdouble RC1 = R11*C1+R12*C2+R13*C3;\r\n\tdouble RC2 = R21*C1+R22*C2+R23*C3;\r\n\tdouble RC3 = R31*C1+R32*C2+R33*C3;\r\n\r\n\tdouble KRC1 = K11*RC1+K12*RC2+K13*RC3;\r\n\tdouble KRC2 = K21*RC1+K22*RC2+K23*RC3;\r\n\tdouble KRC3 = K31*RC1+K32*RC2+K33*RC3;\r\n\r\n\tdouble proj1 = KRX1-KRC1;\r\n\tdouble proj2 = KRX2-KRC2;\r\n\tdouble proj3 = KRX3-KRC3;\r\n\r\n\txij[0] = proj1/proj3;\r\n\txij[1] = proj2/proj3;\r\n}\r\n\r\nvoid Projection3Donto2D_MOTSTR_fast_Distortion(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\tdouble omega = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[4];\r\n\tdouble tan_omega_half_2 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[5];\r\n\tif (j == 1)\r\n\t\tint k = 1;\r\n\tif (j == 2)\r\n\t\tint k = 1;\r\n\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\t// Set orientation\r\n\tdouble qw = rt[0];\r\n\tdouble qx = rt[1];\r\n\tdouble qy = rt[2];\r\n\tdouble qz = rt[3];\r\n\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\tqw /= q_norm;\r\n\tqx /= q_norm;\r\n\tqy /= q_norm;\r\n\tqz /= q_norm;\r\n\r\n\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\r\n\t//cout << R11 << \" \" << R12 << \" \" << R13 << endl;\r\n\t//cout << R21 << \" \" << R22 << \" \" << R23 << endl;\r\n\t//cout << R31 << \" \" << R32 << \" \" << R33 << endl;\r\n\r\n\t// Set translation\r\n\tdouble C1 = rt[4];\r\n\tdouble C2 = rt[5];\r\n\tdouble C3 = rt[6];\r\n\r\n\tdouble X1 = xyz[0];\r\n\tdouble X2 = xyz[1];\r\n\tdouble X3 = xyz[2];\r\n\r\n\t// Building projection \r\n\tdouble RX1 = R11*X1+R12*X2+R13*X3;\r\n\tdouble RX2 = R21*X1+R22*X2+R23*X3;\r\n\tdouble RX3 = R31*X1+R32*X2+R33*X3;\r\n\r\n\tdouble KRX1 = K11*RX1+K12*RX2+K13*RX3;\r\n\tdouble KRX2 = K21*RX1+K22*RX2+K23*RX3;\r\n\tdouble KRX3 = K31*RX1+K32*RX2+K33*RX3;\r\n\r\n\tdouble RC1 = R11*C1+R12*C2+R13*C3;\r\n\tdouble RC2 = R21*C1+R22*C2+R23*C3;\r\n\tdouble RC3 = R31*C1+R32*C2+R33*C3;\r\n\r\n\tdouble KRC1 = K11*RC1+K12*RC2+K13*RC3;\r\n\tdouble KRC2 = K21*RC1+K22*RC2+K23*RC3;\r\n\tdouble KRC3 = K31*RC1+K32*RC2+K33*RC3;\r\n\r\n\tdouble proj1 = KRX1-KRC1;\r\n\tdouble proj2 = KRX2-KRC2;\r\n\tdouble proj3 = KRX3-KRC3;\r\n\r\n\tdouble u = proj1/proj3;\r\n\tdouble v = proj2/proj3;\r\n\r\n\tdouble u_n = u/K11 - K13/K11;\r\n\tdouble v_n = v/K22 - K23/K22;\r\n\r\n\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\tdouble u_d_n = r_d/r_u * u_n;\r\n\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\tdouble u_d = u_d_n*K11 + K13;\r\n\tdouble v_d = v_d_n*K22 + K23;\r\n\r\n\txij[0] = u_d;\r\n\txij[1] = v_d;\r\n}\r\n\r\nvoid Projection3Donto2D_MOTSTR_fast_Distortion_ObstacleDetection(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\tdouble omega = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[4];\r\n\tdouble tan_omega_half_2 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[5];\r\n\tdouble princ_x1 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[6];\r\n\tdouble princ_y1 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[7];\r\n\r\n\t// Set intrinsic parameter\r\n\tdouble K11 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[0];\r\n\tdouble K12 = 0;\r\n\tdouble K13 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[2];\r\n\tdouble K21 = 0;\r\n\tdouble K22 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[1];\r\n\tdouble K23 = ((((AdditionalData *) adata)->vIntrinsic)[iCamera])[3];\r\n\tdouble K31 = 0;\r\n\tdouble K32 = 0;\r\n\tdouble K33 = 1;\r\n\r\n\t// Set orientation\r\n\tdouble qw = rt[0];\r\n\tdouble qx = rt[1];\r\n\tdouble qy = rt[2];\r\n\tdouble qz = rt[3];\r\n\tdouble q_norm = sqrt(qw*qw + qx*qx + qy*qy + qz*qz);\r\n\tqw /= q_norm;\r\n\tqx /= q_norm;\r\n\tqy /= q_norm;\r\n\tqz /= q_norm;\r\n\r\n\tdouble R11 = 1.0-2*qy*qy-2*qz*qz; \t\tdouble R12 = 2*qx*qy-2*qz*qw;\t\tdouble R13 = 2*qx*qz+2*qy*qw;\r\n\tdouble R21 = 2*qx*qy+2*qz*qw;\t\t\tdouble R22 = 1.0-2*qx*qx-2*qz*qz;\tdouble R23 = 2*qz*qy-2*qx*qw;\r\n\tdouble R31 = 2*qx*qz-2*qy*qw;\t\t\tdouble R32 = 2*qy*qz+2*qx*qw;\t\tdouble R33 = 1.0-2*qx*qx-2*qy*qy;\r\n\r\n\t//cout << R11 << \" \" << R12 << \" \" << R13 << endl;\r\n\t//cout << R21 << \" \" << R22 << \" \" << R23 << endl;\r\n\t//cout << R31 << \" \" << R32 << \" \" << R33 << endl;\r\n\r\n\t// Set translation\r\n\tdouble C1 = rt[4];\r\n\tdouble C2 = rt[5];\r\n\tdouble C3 = rt[6];\r\n\r\n\tdouble X1 = xyz[0];\r\n\tdouble X2 = xyz[1];\r\n\tdouble X3 = xyz[2];\r\n\r\n\t// Building projection \r\n\tdouble RX1 = R11*X1+R12*X2+R13*X3;\r\n\tdouble RX2 = R21*X1+R22*X2+R23*X3;\r\n\tdouble RX3 = R31*X1+R32*X2+R33*X3;\r\n\r\n\tdouble KRX1 = K11*RX1+K12*RX2+K13*RX3;\r\n\tdouble KRX2 = K21*RX1+K22*RX2+K23*RX3;\r\n\tdouble KRX3 = K31*RX1+K32*RX2+K33*RX3;\r\n\r\n\tdouble RC1 = R11*C1+R12*C2+R13*C3;\r\n\tdouble RC2 = R21*C1+R22*C2+R23*C3;\r\n\tdouble RC3 = R31*C1+R32*C2+R33*C3;\r\n\r\n\tdouble KRC1 = K11*RC1+K12*RC2+K13*RC3;\r\n\tdouble KRC2 = K21*RC1+K22*RC2+K23*RC3;\r\n\tdouble KRC3 = K31*RC1+K32*RC2+K33*RC3;\r\n\r\n\tdouble proj1 = KRX1-KRC1;\r\n\tdouble proj2 = KRX2-KRC2;\r\n\tdouble proj3 = KRX3-KRC3;\r\n\r\n\tdouble u = proj1/proj3;\r\n\tdouble v = proj2/proj3;\r\n\r\n\t//double u_n = u/K11 - K13/K11;\r\n\t//double v_n = v/K22 - K23/K22;\r\n\r\n\tdouble u_n = u - princ_x1;\r\n\tdouble v_n = v - princ_y1;\r\n\r\n\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\tdouble u_d_n = r_d/r_u * u_n;\r\n\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\tdouble u_d = u_d_n + princ_x1;\r\n\tdouble v_d = v_d_n + princ_y1;\r\n\r\n\txij[0] = u_d;\r\n\txij[1] = v_d;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Projection3Donto2D_KMOTSTR(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tCvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetIdentity(K);\r\n\t//int max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\t//vector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\t//int iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\t//double *intrinsic = (((AdditionalData *) adata)->vIntrinsic)[iCamera];\r\n\t//cvSetReal2D(K, 0, 0, intrinsic[0]);\r\n\t//cvSetReal2D(K, 1, 1, intrinsic[1]);\r\n\t//cvSetReal2D(K, 0, 2, intrinsic[2]);\r\n\t//cvSetReal2D(K, 1, 2, intrinsic[3]);\r\n\r\n\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetReal2D(q, 0, 0, rt[0]);\r\n\tcvSetReal2D(q, 1, 0, rt[1]);\r\n\tcvSetReal2D(q, 2, 0, rt[2]);\r\n\tcvSetReal2D(q, 3, 0, rt[3]);\r\n\tcvSetReal2D(C, 0, 0, rt[4]);\r\n\tcvSetReal2D(C, 1, 0, rt[5]);\r\n\tcvSetReal2D(C, 2, 0, rt[6]);\r\n\tcvSetReal2D(K, 0, 0, rt[7]);\r\n\tcvSetReal2D(K, 1, 1, rt[8]);\r\n\tcvSetReal2D(K, 0, 2, rt[9]);\r\n\tcvSetReal2D(K, 1, 2, rt[10]);\r\n\tQuaternion2Rotation(q, R);\r\n\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\tcvMatMul(K, R, temp33);\r\n\tcvSetIdentity(P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(P, 0,3,C);\r\n\tcvMatMul(temp33, P, P);\r\n\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\tcvSetReal2D(X, 0, 0, xyz[0]);\r\n\tcvSetReal2D(X, 1, 0, xyz[1]);\r\n\tcvSetReal2D(X, 2, 0, xyz[2]);\r\n\tcvSetReal2D(X, 3, 0, 1);\r\n\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\tcvMatMul(P, X, x);\r\n\r\n\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\tcvReleaseMat(&K);\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tcvReleaseMat(&P);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&q);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n}\r\n\r\nvoid ProjectionThetaonto2D_TEMPORAL(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\tint cFrame = vUsedFrame[j] % max_nFrames;\r\n\tint nBase = ((AdditionalData*) adata)->nBase;\r\n\tvector<Theta> vTheta = ((AdditionalData *) adata)->vTheta;\r\n\tCvMat *P = cvCreateMat(3,4, CV_32FC1);\r\n\tfor (int iP = 0; iP < 3; iP++)\r\n\t\tfor (int jP = 0; jP < 4; jP++)\r\n\t\t\tcvSetReal2D(P, iP, jP, ((AdditionalData *) adata)->vdP[12*j+iP*4+jP]);\r\n\tdouble dt = rt[0];\r\n\tdouble t = cFrame + dt;\r\n\r\n\tCvMat *B = cvCreateMat(1, nBase, CV_32FC1);\r\n\tcvSetReal2D(B, 0, 0, sqrt(1.0/(double)max_nFrames));\r\n\tfor (int iB = 1; iB < nBase; iB++)\r\n\t\tcvSetReal2D(B, 0, iB, sqrt(2.0/(double)max_nFrames)*cos((2*t-1)*(iB)*PI/2.0/(double)max_nFrames));\r\n\r\n\t//PrintMat(B);\r\n\tCvMat *thetaX = cvCreateMat(nBase,1, CV_32FC1);\r\n\tCvMat *thetaY = cvCreateMat(nBase,1, CV_32FC1);\r\n\tCvMat *thetaZ = cvCreateMat(nBase,1, CV_32FC1);\r\n\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\tcvSetReal2D(thetaX, iTheta, 0, xyz[iTheta]);\r\n\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\tcvSetReal2D(thetaY, iTheta, 0, xyz[nBase+iTheta]);\r\n\tfor (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t\tcvSetReal2D(thetaZ, iTheta, 0, xyz[2*nBase+iTheta]);\r\n\r\n\t//PrintMat(thetaX);\r\n\t//PrintMat(thetaY);\r\n\t//PrintMat(thetaZ);\r\n\r\n\t//for (int iTheta = 0; iTheta < nBase; iTheta++)\r\n\t//\tcout << xyz[iTheta] << \" \";\r\n\t//cout << endl;\r\n\r\n\tCvMat *X3 = cvCreateMat(1,1,CV_32FC1);\r\n\tCvMat *Y3 = cvCreateMat(1,1,CV_32FC1);\r\n\tCvMat *Z3 = cvCreateMat(1,1,CV_32FC1);\r\n\tcvMatMul(B, thetaX, X3);\r\n\tcvMatMul(B, thetaY, Y3);\r\n\tcvMatMul(B, thetaZ, Z3);\r\n\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\tcvSetReal2D(X, 0, 0, cvGetReal2D(X3,0,0));\r\n\tcvSetReal2D(X, 1, 0, cvGetReal2D(Y3,0,0));\r\n\tcvSetReal2D(X, 2, 0, cvGetReal2D(Z3,0,0));\r\n\tcvSetReal2D(X, 3, 0, 1);\r\n\r\n\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\tcvMatMul(P, X, x);\r\n\r\n\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\tint error = 0;\r\n\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t{\r\n\t\terror += (xyz[iBase]-vTheta[i].thetaX[iBase])*(xyz[iBase]-vTheta[i].thetaX[iBase]);\r\n\t}\r\n\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t{\r\n\t\terror += (xyz[nBase+iBase]-vTheta[i].thetaY[iBase])*(xyz[nBase+iBase]-vTheta[i].thetaY[iBase]);\r\n\t}\r\n\tfor (int iBase = 0; iBase < nBase; iBase++)\r\n\t{\r\n\t\terror += (xyz[2*nBase+iBase]-vTheta[i].thetaZ[iBase])*(xyz[2*nBase+iBase]-vTheta[i].thetaZ[iBase]);\r\n\t}\r\n\r\n\txij[2] = 10*error;\r\n\txij[3] = 10*rt[0];\r\n\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tcvReleaseMat(&P);\r\n\tcvReleaseMat(&B);\r\n\tcvReleaseMat(&thetaX);\r\n\tcvReleaseMat(&thetaY);\r\n\tcvReleaseMat(&thetaZ);\r\n\tcvReleaseMat(&X3);\r\n\tcvReleaseMat(&Y3);\r\n\tcvReleaseMat(&Z3);\r\n}\r\n\r\n\r\nvoid Projection3Donto2D_KDMOTSTR(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\tCvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetIdentity(K);\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\t//double *intrinsic = (((AdditionalData *) adata)->vIntrinsic)[iCamera];\r\n\t//cvSetReal2D(K, 0, 0, intrinsic[0]);\r\n\t//cvSetReal2D(K, 1, 1, intrinsic[1]);\r\n\t//cvSetReal2D(K, 0, 2, intrinsic[2]);\r\n\t//cvSetReal2D(K, 1, 2, intrinsic[3]);\r\n\r\n\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetReal2D(q, 0, 0, rt[0]);\r\n\tcvSetReal2D(q, 1, 0, rt[1]);\r\n\tcvSetReal2D(q, 2, 0, rt[2]);\r\n\tcvSetReal2D(q, 3, 0, rt[3]);\r\n\tcvSetReal2D(C, 0, 0, rt[4]);\r\n\tcvSetReal2D(C, 1, 0, rt[5]);\r\n\tcvSetReal2D(C, 2, 0, rt[6]);\r\n\tcvSetReal2D(K, 0, 0, rt[7]);\r\n\tcvSetReal2D(K, 1, 1, rt[8]);\r\n\tcvSetReal2D(K, 0, 2, rt[9]);\r\n\tcvSetReal2D(K, 1, 2, rt[10]);\r\n\tQuaternion2Rotation(q, R);\r\n\r\n\tdouble k11 = rt[7];\r\n\tdouble k22 = rt[8];\r\n\tdouble px = rt[9];\r\n\tdouble py = rt[10];\r\n\tdouble k1 = rt[11];\r\n\tdouble k2 = rt[12];\r\n\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\tcvMatMul(K, R, temp33);\r\n\tcvSetIdentity(P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(P, 0,3,C);\r\n\tcvMatMul(temp33, P, P);\r\n\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\tcvSetReal2D(X, 0, 0, xyz[0]);\r\n\tcvSetReal2D(X, 1, 0, xyz[1]);\r\n\tcvSetReal2D(X, 2, 0, xyz[2]);\r\n\tcvSetReal2D(X, 3, 0, 1);\r\n\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\tcvMatMul(P, X, x);\r\n\r\n\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t// taking into account distortion\r\n\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K, invK);\r\n\tdouble ik11 = cvGetReal2D(invK, 0, 0);\tdouble ik12 = cvGetReal2D(invK, 0, 1);\tdouble ik13 = cvGetReal2D(invK, 0, 2);\r\n\tdouble ik21 = cvGetReal2D(invK, 1, 0);\tdouble ik22 = cvGetReal2D(invK, 1, 1);\tdouble ik23 = cvGetReal2D(invK, 1, 2);\r\n\tdouble ik31 = cvGetReal2D(invK, 2, 0);\tdouble ik32 = cvGetReal2D(invK, 2, 1);\tdouble ik33 = cvGetReal2D(invK, 2, 2);\r\n\tdouble nz = (ik31*xij[0]+ik32*xij[1]+ik33);\r\n\tdouble nx = (ik11*xij[0]+ik12*xij[1]+ik13)/nz; \r\n\tdouble ny = (ik21*xij[0]+ik22*xij[1]+ik23)/nz; \r\n\r\n\tdouble r = sqrt((nx)*(nx)+(ny)*(ny));\r\n\tdouble L = 1 + k1*r + k2*r*r;\r\n\tnx = L*(nx);\r\n\tny = L*(ny);\r\n\r\n\txij[0] = (k11*nx+px); \r\n\txij[1] = (k22*ny+py); \r\n\r\n\tcvReleaseMat(&K);\r\n\tcvReleaseMat(&invK);\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tcvReleaseMat(&P);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&q);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n}\r\n\r\n\r\nvoid ProjectionThetaonto2D_MOTSTR(int j, int i, double *rt, double *xyz, double *xij, void *adata)\r\n{\r\n\t//CvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetIdentity(K);\r\n\t//cvSetReal2D(K, 0, 0, ((AdditionalData *) adata)->intrinsic[0]);\r\n\t//cvSetReal2D(K, 1, 1, ((AdditionalData *) adata)->intrinsic[1]);\r\n\t//cvSetReal2D(K, 0, 2, ((AdditionalData *) adata)->intrinsic[2]);\r\n\t//cvSetReal2D(K, 1, 2, ((AdditionalData *) adata)->intrinsic[3]);\r\n\t//bool isStatic = ((AdditionalData *) adata)->isStatic[i];\r\n\t//CvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//CvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t//CvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetReal2D(q, 0, 0, rt[0]);\r\n\t//cvSetReal2D(q, 1, 0, rt[1]);\r\n\t//cvSetReal2D(q, 2, 0, rt[2]);\r\n\t//cvSetReal2D(q, 3, 0, rt[3]);\r\n\t//cvSetReal2D(C, 0, 0, rt[4]);\r\n\t//cvSetReal2D(C, 1, 0, rt[5]);\r\n\t//cvSetReal2D(C, 2, 0, rt[6]);\r\n\t//Quaternion2Rotation(q, R);\r\n\r\n\t//CvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t//cvMatMul(K, R, temp33);\r\n\t//cvSetIdentity(P);\r\n\t//ScalarMul(C, -1, C);\r\n\t//SetSubMat(P, 0,3,C);\r\n\t//cvMatMul(temp33, P, P);\r\n\r\n\t//if (!isStatic)\r\n\t//{\r\n\t//\tint iFrame = j % ((AdditionalData *) adata)->nFrames;\r\n\t//\tint nBase = ((AdditionalData *) adata)->nBase;\r\n\t//\tint nFrames = ((AdditionalData *) adata)->nFrames;\r\n\t//\tCvMat *x = cvCreateMat(2,1,CV_32FC1);\r\n\t//\tCvMat *theta = cvCreateMat(3*nBase, 1, CV_32FC1);\r\n\t//\tfor (int iTheta = 0; iTheta < 3*nBase; iTheta++)\r\n\t//\t\tcvSetReal2D(theta, iTheta, 0, xyz[iTheta]);\r\n\t//\tDCTProjection(P, theta, nFrames, iFrame, nBase, x);\r\n\t//\txij[0] = cvGetReal2D(x, 0, 0);\r\n\t//\txij[1] = cvGetReal2D(x, 1, 0);\r\n\t//\tcvReleaseMat(&x);\r\n\t//\tcvReleaseMat(&theta);\r\n\t//}\r\n\t//else\r\n\t//{\r\n\t//\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tcvSetReal2D(X, 0, 0, xyz[0]);\r\n\t//\tcvSetReal2D(X, 1, 0, xyz[1]);\r\n\t//\tcvSetReal2D(X, 2, 0, xyz[2]);\r\n\t//\tcvSetReal2D(X, 3, 0, 1);\r\n\t//\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\t//\tcvMatMul(P, X, x);\r\n\t//\t\r\n\r\n\t//\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t//\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\t//\tcvReleaseMat(&X);\r\n\t//\tcvReleaseMat(&x);\r\n\t//}\r\n\r\n\t//cvReleaseMat(&K);\r\n\t//cvReleaseMat(&P);\r\n\t//cvReleaseMat(&temp33);\r\n\t//cvReleaseMat(&q);\r\n\t//cvReleaseMat(&C);\r\n\t//cvReleaseMat(&R);\r\n}\r\n\r\nvoid ProjectionThetaonto2D_MOTSTR_LEVMAR(int j, int i, double *rt, double *xyz, double &xi, double &yi, void *adata)\r\n{\r\n\t//CvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetIdentity(K);\r\n\t//cvSetReal2D(K, 0, 0, ((AdditionalData *) adata)->intrinsic[0]);\r\n\t//cvSetReal2D(K, 1, 1, ((AdditionalData *) adata)->intrinsic[1]);\r\n\t//cvSetReal2D(K, 0, 2, ((AdditionalData *) adata)->intrinsic[2]);\r\n\t//cvSetReal2D(K, 1, 2, ((AdditionalData *) adata)->intrinsic[3]);\r\n\t//bool isStatic = ((AdditionalData *) adata)->isStatic[i];\r\n\t//CvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//CvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t//CvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetReal2D(q, 0, 0, rt[0]);\r\n\t//cvSetReal2D(q, 1, 0, rt[1]);\r\n\t//cvSetReal2D(q, 2, 0, rt[2]);\r\n\t//cvSetReal2D(q, 3, 0, rt[3]);\r\n\t//cvSetReal2D(C, 0, 0, rt[4]);\r\n\t//cvSetReal2D(C, 1, 0, rt[5]);\r\n\t//cvSetReal2D(C, 2, 0, rt[6]);\r\n\t//Quaternion2Rotation(q, R);\r\n\r\n\t//CvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t//cvMatMul(K, R, temp33);\r\n\t//cvSetIdentity(P);\r\n\t//ScalarMul(C, -1, C);\r\n\t//SetSubMat(P, 0,3,C);\r\n\t//cvMatMul(temp33, P, P);\r\n\r\n\t//if (!isStatic)\r\n\t//{\r\n\t//\tint iFrame = j % ((AdditionalData *) adata)->nFrames;\r\n\t//\tint nBase = ((AdditionalData *) adata)->nBase;\r\n\t//\tint nFrames = ((AdditionalData *) adata)->nFrames;\r\n\t//\tCvMat *x = cvCreateMat(2,1,CV_32FC1);\r\n\t//\tCvMat *theta = cvCreateMat(3*nBase, 1, CV_32FC1);\r\n\t//\tfor (int iTheta = 0; iTheta < 3*nBase; iTheta++)\r\n\t//\t\tcvSetReal2D(theta, iTheta, 0, xyz[iTheta]);\r\n\t//\tDCTProjection(P, theta, nFrames, iFrame, nBase, x);\r\n\t//\txi = cvGetReal2D(x, 0, 0);\r\n\t//\tyi = cvGetReal2D(x, 1, 0);\r\n\t//\tcvReleaseMat(&x);\r\n\t//\tcvReleaseMat(&theta);\r\n\t//}\r\n\t//else\r\n\t//{\r\n\t//\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tcvSetReal2D(X, 0, 0, xyz[0]);\r\n\t//\tcvSetReal2D(X, 1, 0, xyz[1]);\r\n\t//\tcvSetReal2D(X, 2, 0, xyz[2]);\r\n\t//\tcvSetReal2D(X, 3, 0, 1);\r\n\t//\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\t//\tcvMatMul(P, X, x);\r\n\r\n\t//\txi = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t//\tyi = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\t//\tcvReleaseMat(&X);\r\n\t//\tcvReleaseMat(&x);\r\n\t//}\r\n\r\n\t//cvReleaseMat(&K);\r\n\t//cvReleaseMat(&P);\r\n\t//cvReleaseMat(&temp33);\r\n\t//cvReleaseMat(&q);\r\n\t//cvReleaseMat(&C);\r\n\t//cvReleaseMat(&R);\r\n}\r\n\r\n\r\nvoid Projection3Donto2D_MOT(int j, int i, double *rt, double *xij, void *adata)\r\n{\r\n\t//CvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetIdentity(K);\r\n\t//cvSetReal2D(K, 0, 0, ((AdditionalData *) adata)->intrinsic[0]);\r\n\t//cvSetReal2D(K, 1, 1, ((AdditionalData *) adata)->intrinsic[1]);\r\n\t//cvSetReal2D(K, 0, 2, ((AdditionalData *) adata)->intrinsic[2]);\r\n\t//cvSetReal2D(K, 1, 2, ((AdditionalData *) adata)->intrinsic[3]);\r\n\t//CvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//CvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\t//CvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvSetReal2D(q, 0, 0, rt[0]);\r\n\t//cvSetReal2D(q, 1, 0, rt[1]);\r\n\t//cvSetReal2D(q, 2, 0, rt[2]);\r\n\t//cvSetReal2D(q, 3, 0, rt[3]);\r\n\t//cvSetReal2D(C, 0, 0, rt[4]);\r\n\t//cvSetReal2D(C, 1, 0, rt[5]);\r\n\t//cvSetReal2D(C, 2, 0, rt[6]);\r\n\t//Quaternion2Rotation(q, R);\r\n\r\n\t//CvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\t//cvMatMul(K, R, temp33);\r\n\t//cvSetIdentity(P);\r\n\t//ScalarMul(C, -1, C);\r\n\t//SetSubMat(P, 0,3,C);\r\n\t//cvMatMul(temp33, P, P);\r\n\t//CvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\t//cvSetReal2D(X, 0, 0, ((AdditionalData *) adata)->XYZ[3*i]);\r\n\t//cvSetReal2D(X, 1, 0, ((AdditionalData *) adata)->XYZ[3*i+1]);\r\n\t//cvSetReal2D(X, 2, 0, ((AdditionalData *) adata)->XYZ[3*i+2]);\r\n\t//cvSetReal2D(X, 3, 0, 1);\r\n\t////PrintMat(X, \"X\");\r\n\t////PrintMat(C, \"C\");\r\n\t////cout << i << endl;\r\n\t////if (j == 1)\r\n\t////\tint k = 1;\r\n\r\n\t//CvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\t//cvMatMul(P, X, x);\r\n\t//xij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t//xij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t//cvReleaseMat(&K);\r\n\t//cvReleaseMat(&X);\r\n\t//cvReleaseMat(&x);\r\n\t//cvReleaseMat(&P);\r\n\t//cvReleaseMat(&temp33);\r\n\t//cvReleaseMat(&q);\r\n\t//cvReleaseMat(&C);\r\n}\r\n\r\nvoid Projection3Donto2D_KDMOT(int j, int i, double *rt, double *xij, void *adata)\r\n{\r\n\tCvMat *K = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetIdentity(K);\r\n\tint max_nFrames = ((AdditionalData *) adata)->max_nFrames;\r\n\tvector<int> vUsedFrame = ((AdditionalData *) adata)->vUsedFrame;\r\n\tint iCamera = (int)((double)vUsedFrame[j]/max_nFrames);\r\n\r\n\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *C = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\tcvSetReal2D(q, 0, 0, rt[0]);\r\n\tcvSetReal2D(q, 1, 0, rt[1]);\r\n\tcvSetReal2D(q, 2, 0, rt[2]);\r\n\tcvSetReal2D(q, 3, 0, rt[3]);\r\n\tcvSetReal2D(C, 0, 0, rt[4]);\r\n\tcvSetReal2D(C, 1, 0, rt[5]);\r\n\tcvSetReal2D(C, 2, 0, rt[6]);\r\n\tcvSetReal2D(K, 0, 0, rt[7]);\r\n\tcvSetReal2D(K, 1, 1, rt[8]);\r\n\tcvSetReal2D(K, 0, 2, rt[9]);\r\n\tcvSetReal2D(K, 1, 2, rt[10]);\r\n\tQuaternion2Rotation(q, R);\r\n\r\n\tdouble k11 = rt[7];\r\n\tdouble k22 = rt[8];\r\n\tdouble px = rt[9];\r\n\tdouble py = rt[10];\r\n\tdouble k1 = rt[11];\r\n\tdouble k2 = rt[12];\r\n\r\n\tCvMat *temp33 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *P = cvCreateMat(3,4,CV_32FC1);\r\n\tcvMatMul(K, R, temp33);\r\n\tcvSetIdentity(P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(P, 0,3,C);\r\n\tcvMatMul(temp33, P, P);\r\n\tCvMat *X = cvCreateMat(4,1,CV_32FC1);\r\n\tcvSetReal2D(X, 0, 0, ((AdditionalData *) adata)->XYZ[3*i]);\r\n\tcvSetReal2D(X, 1, 0, ((AdditionalData *) adata)->XYZ[3*i+1]);\r\n\tcvSetReal2D(X, 2, 0, ((AdditionalData *) adata)->XYZ[3*i+2]);\r\n\tcvSetReal2D(X, 3, 0, 1);\r\n\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\tcvMatMul(P, X, x);\r\n\r\n\txij[0] = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\txij[1] = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t// taking into account distortion\r\n\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\tcvInvert(K, invK);\r\n\tdouble ik11 = cvGetReal2D(invK, 0, 0);\tdouble ik12 = cvGetReal2D(invK, 0, 1);\tdouble ik13 = cvGetReal2D(invK, 0, 2);\r\n\tdouble ik21 = cvGetReal2D(invK, 1, 0);\tdouble ik22 = cvGetReal2D(invK, 1, 1);\tdouble ik23 = cvGetReal2D(invK, 1, 2);\r\n\tdouble ik31 = cvGetReal2D(invK, 2, 0);\tdouble ik32 = cvGetReal2D(invK, 2, 1);\tdouble ik33 = cvGetReal2D(invK, 2, 2);\r\n\tdouble nz = (ik31*xij[0]+ik32*xij[1]+ik33);\r\n\tdouble nx = (ik11*xij[0]+ik12*xij[1]+ik13)/nz; \r\n\tdouble ny = (ik21*xij[0]+ik22*xij[1]+ik23)/nz; \r\n\r\n\tdouble r = sqrt((nx)*(nx)+(ny)*(ny));\r\n\tdouble L = 1 + k1*r + k2*r*r;\r\n\tnx = L*(nx);\r\n\tny = L*(ny);\r\n\r\n\txij[0] = (k11*nx+px); \r\n\txij[1] = (k22*ny+py); \r\n\r\n\tcvReleaseMat(&K);\r\n\tcvReleaseMat(&invK);\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tcvReleaseMat(&P);\r\n\tcvReleaseMat(&temp33);\r\n\tcvReleaseMat(&q);\r\n\tcvReleaseMat(&C);\r\n\tcvReleaseMat(&R);\r\n}\r\n\r\nvoid GetParameterForSBA(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> cP, CvMat *X, CvMat *K, vector<int> visibleStructureID,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = cP.size(); \r\n\tint nFeatures = X->rows;\r\n\t\r\n\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t{\r\n\t\tint cFrame = vUsedFrame[iFrame];\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvInvert(K, invK);\r\n\t\tGetSubMatColwise(cP[iFrame], 0, 2, R);\r\n\t\tGetSubMatColwise(cP[iFrame], 3, 3, t);\r\n\t\tcvMatMul(invK, R, R);\r\n\t\tcvInvert(R, invR);\r\n\t\tcvMatMul(invK, t, t);\r\n\t\tcvMatMul(invR, t, t);\r\n\t\tScalarMul(t, -1, t);\r\n\t\tRotation2Quaternion(R, q);\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&t);\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&invK);\r\n\t\tcvReleaseMat(&invR);\r\n\t}\r\n\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 1));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 2));\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(visibleStructureID.size(), nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t\tcvSetReal2D(visibilityMask, cFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForSBA(vector<Feature> &vFeature, vector<int> vUsedFrame, vector<CvMat *> cP, CvMat *X, vector<Camera> vCamera, int max_nFrames, vector<int> visibleStructureID,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = cP.size(); \r\n\tint nFeatures = X->rows;\r\n\r\n\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t{\r\n\t\tint cFrame = vUsedFrame[iFrame];\r\n\t\tint iCamera = (int) ((double)vUsedFrame[iFrame]/max_nFrames);\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvInvert(vCamera[iCamera].vK[cFrame], invK);\r\n\t\tGetSubMatColwise(cP[iFrame], 0, 2, R);\r\n\t\tGetSubMatColwise(cP[iFrame], 3, 3, t);\r\n\t\tcvMatMul(invK, R, R);\r\n\t\tcvInvert(R, invR);\r\n\t\tcvMatMul(invK, t, t);\r\n\t\tcvMatMul(invR, t, t);\r\n\t\tScalarMul(t, -1, t);\r\n\t\tRotation2Quaternion(R, q);\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&t);\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&invK);\r\n\t\tcvReleaseMat(&invR);\r\n\t}\r\n\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 1));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 2));\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(visibleStructureID.size(), nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t\tcvSetReal2D(visibilityMask, cFeature, iVisibleFrame, 1);\r\n\t\t\t\t//cvSetReal2D(visibilityMask, iFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForSBA_Distortion(vector<Feature> &vFeature, vector<int> vUsedFrame, vector<CvMat *> cP, CvMat *X, vector<Camera> vCamera, int max_nFrames, vector<int> visibleStructureID,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = cP.size(); \r\n\tint nFeatures = X->rows;\r\n\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t{\r\n\t\tint cFrame = vUsedFrame[iFrame];\r\n\t\tint iCamera = (int) ((double)vUsedFrame[iFrame]/max_nFrames);\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\tcvInvert(vCamera[iCamera].K, invK);\r\n\t\tGetSubMatColwise(cP[iFrame], 0, 2, R);\r\n\t\tGetSubMatColwise(cP[iFrame], 3, 3, t);\r\n\t\tcvMatMul(invK, R, R);\r\n\t\tcvInvert(R, invR);\r\n\t\tcvMatMul(invK, t, t);\r\n\t\tcvMatMul(invR, t, t);\r\n\t\tScalarMul(t, -1, t);\r\n\t\t\r\n\t\tRotation2Quaternion(R, q);\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&t);\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&invK);\r\n\t\tcvReleaseMat(&invR);\r\n\t}\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 1));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 2));\r\n\t}\r\n\tCvMat *visibilityMask = cvCreateMat(visibleStructureID.size(), nFrames, CV_32FC1);\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx_dis[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy_dis[idx]);\r\n\t\t\t\tcvSetReal2D(visibilityMask, cFeature, iVisibleFrame, 1);\r\n\t\t\t\t//cvSetReal2D(visibilityMask, iFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\n\r\nvoid GetParameterForSBA_KRT(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> cP, CvMat *X, vector<Camera> vCamera, int max_nFrames, vector<int> visibleStructureID,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = cP.size(); \r\n\tint nFeatures = visibleStructureID.size();\r\n\tcout << \"nFeatures: \" << X->rows << \" nFeatures_: \" << nFeatures <<endl;\r\n\r\n\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t{\r\n\t\tint cFrame = vUsedFrame[iFrame];\r\n\t\tint takenFrame = vUsedFrame[iFrame] % max_nFrames;\r\n\t\tint iCamera = (int) ((double)vUsedFrame[iFrame]/max_nFrames);\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\tvector<int>::const_iterator it = find(vCamera[iCamera].vTakenFrame.begin(), vCamera[iCamera].vTakenFrame.end(), takenFrame);\r\n\t\tif (it == vCamera[iCamera].vTakenFrame.end())\r\n\t\t\treturn;\r\n\t\tint iTakenFrame = (int) (it - vCamera[iCamera].vTakenFrame.begin());\r\n\t\tcvInvert(vCamera[iCamera].vK[iTakenFrame], invK);\r\n\t\tdouble k11 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 0, 0);\r\n\t\tdouble k22 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 1, 1);\r\n\t\tdouble k13 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 0, 2);\r\n\t\tdouble k23 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 1, 2);\r\n\r\n\t\tGetSubMatColwise(cP[iFrame], 0, 2, R);\r\n\t\tGetSubMatColwise(cP[iFrame], 3, 3, t);\r\n\t\tcvMatMul(invK, R, R);\r\n\t\tcvInvert(R, invR);\r\n\t\tcvMatMul(invK, t, t);\r\n\t\tcvMatMul(invR, t, t);\r\n\t\tScalarMul(t, -1, t);\r\n\t\tRotation2Quaternion(R, q);\r\n\t\t//PrintMat(R);\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\tcameraParameter.push_back(k11);\r\n\t\tcameraParameter.push_back(k22);\r\n\t\tcameraParameter.push_back(k13);\r\n\t\tcameraParameter.push_back(k23);\r\n\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&t);\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&invK);\r\n\t\tcvReleaseMat(&invR);\r\n\t}\r\n\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 1));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 2));\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(visibleStructureID.size(), nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t\tcvSetReal2D(visibilityMask, cFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForSBA_KDRT(vector<Feature> vFeature, vector<int> vUsedFrame, vector<CvMat *> cP, CvMat *X, vector<Camera> vCamera, int max_nFrames, vector<int> visibleStructureID,\r\n\t\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = cP.size(); \r\n\tint nFeatures = visibleStructureID.size();\r\n\r\n\tfor (int iFrame = 0; iFrame < vUsedFrame.size(); iFrame++)\r\n\t{\r\n\t\tPrintMat(cP[iFrame],\"P\");\r\n\t\tint cFrame = vUsedFrame[iFrame];\r\n\t\tint takenFrame = vUsedFrame[iFrame] % max_nFrames;\r\n\t\tint iCamera = (int) ((double)vUsedFrame[iFrame]/max_nFrames);\r\n\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\tvector<int>::const_iterator it = find(vCamera[iCamera].vTakenFrame.begin(), vCamera[iCamera].vTakenFrame.end(), takenFrame);\r\n\t\tif (it == vCamera[iCamera].vTakenFrame.end())\r\n\t\t\treturn;\r\n\t\tint iTakenFrame = (int) (it - vCamera[iCamera].vTakenFrame.begin());\r\n\t\tcvInvert(vCamera[iCamera].vK[iTakenFrame], invK);\r\n\t\tdouble k11 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 0, 0);\r\n\t\tdouble k22 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 1, 1);\r\n\t\tdouble k13 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 0, 2);\r\n\t\tdouble k23 = cvGetReal2D(vCamera[iCamera].vK[iTakenFrame], 1, 2);\r\n\r\n\t\tGetSubMatColwise(cP[iFrame], 0, 2, R);\r\n\t\tGetSubMatColwise(cP[iFrame], 3, 3, t);\r\n\t\tcvMatMul(invK, R, R);\r\n\t\tcvInvert(R, invR);\r\n\t\tcvMatMul(invK, t, t);\r\n\t\tcvMatMul(invR, t, t);\r\n\t\tScalarMul(t, -1, t);\r\n\t\tRotation2Quaternion(R, q);\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\tcameraParameter.push_back(k11);\r\n\t\tcameraParameter.push_back(k22);\r\n\t\tcameraParameter.push_back(k13);\r\n\t\tcameraParameter.push_back(k23);\r\n\r\n\t\tcameraParameter.push_back(vCamera[iCamera].vk1[iTakenFrame]);\r\n\t\tcameraParameter.push_back(vCamera[iCamera].vk2[iTakenFrame]);\r\n\r\n\t\tcvReleaseMat(&R);\r\n\t\tcvReleaseMat(&t);\r\n\t\tcvReleaseMat(&q);\r\n\t\tcvReleaseMat(&invK);\r\n\t\tcvReleaseMat(&invR);\r\n\t}\r\n\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 0));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 1));\r\n\t\tcameraParameter.push_back(cvGetReal2D(X, iFeature, 2));\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(visibleStructureID.size(), nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int cFeature = 0; cFeature < visibleStructureID.size(); cFeature++)\r\n\t{\r\n\t\tint iFeature = visibleStructureID[cFeature];\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t\tcvSetReal2D(visibilityMask, cFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForSBA_TEMPORAL(vector<Feature> vFeature, vector<Theta> vTheta, vector<Camera> vCamera, int max_nFrames,\r\n\t\t\t\t\t\t\t vector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFrames = 0;\r\n\tvector<int> vUsedFrame;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\t// Temporal error initialization\r\n\t\t\tcameraParameter.push_back(0);\r\n\t\t\tvUsedFrame.push_back(iCamera*max_nFrames+vCamera[iCamera].vTakenFrame[iFrame]);\r\n\t\t\tnFrames++;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaX[iTheta_x]);\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaY[iTheta_x]);\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaZ[iTheta_x]);\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(vTheta.size(), nFrames, CV_32FC1);\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(0.0);\r\n\t\t\t\tfeature2DParameter.push_back(0.0);\r\n\t\t\t\tcvSetReal2D(visibilityMask, iFeature, iVisibleFrame, 1);\r\n\t\t\t\tNZ++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForSBA_TEMPORAL_LEVMAR(vector<Feature> vFeature, vector<Theta> vTheta, vector<Camera> vCamera, int max_nFrames,\r\n\t\t\t\t\t\t\t\t vector<double> &cameraParameter, vector<double> &feature2DParameter)\r\n{\r\n\tint nFrames = 0;\r\n\tvector<int> vUsedFrame;\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vCamera[iCamera].vTakenFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\t// Temporal error initialization\r\n\t\t\tcameraParameter.push_back(0);\r\n\t\t\tvUsedFrame.push_back(iCamera*max_nFrames+vCamera[iCamera].vTakenFrame[iFrame]);\r\n\t\t\tnFrames++;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaX[iTheta_x]);\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaY[iTheta_x]);\r\n\t\tfor (int iTheta_x = 0; iTheta_x < vTheta[iTheta].thetaX.size(); iTheta_x++)\r\n\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaZ[iTheta_x]);\r\n\t}\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tfor (int iVisibleFrame = 0; iVisibleFrame < vUsedFrame.size(); iVisibleFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::iterator it = find(vFeature[iFeature].vFrame.begin(),vFeature[iFeature].vFrame.end(),vUsedFrame[iVisibleFrame]);\r\n\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = int(it-vFeature[iFeature].vFrame.begin());\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[idx]);\r\n\t\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[idx]);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfeature2DParameter.push_back(0);\r\n\t\t\t\tfeature2DParameter.push_back(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid GetParameterForGBA(vector<Feature> vFeature, vector<Camera> vCamera, vector<Theta> vTheta, CvMat *K, int nFrames,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, vector<char> &vMask)\r\n{\r\n\tint nFeatures = vFeature.size();\r\n\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::const_iterator it = find(vCamera[iCamera].vTakenFrame.begin(), vCamera[iCamera].vTakenFrame.end(), iFrame);\r\n\t\t\tif (it == vCamera[iCamera].vTakenFrame.end())\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\t\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tcvInvert(K, invK);\r\n\t\t\t\tGetSubMatColwise(vCamera[iCamera].vP[iFrame], 0, 2, R);\r\n\t\t\t\tGetSubMatColwise(vCamera[iCamera].vP[iFrame], 3, 3, t);\r\n\t\t\t\tcvMatMul(invK, R, R);\r\n\t\t\t\tcvInvert(R, invR);\r\n\t\t\t\tcvMatMul(invK, t, t);\r\n\t\t\t\tcvMatMul(invR, t, t);\r\n\t\t\t\tScalarMul(t, -1, t);\r\n\t\t\t\tRotation2Quaternion(R, q);\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\t\t\tcvReleaseMat(&R);\r\n\t\t\t\tcvReleaseMat(&t);\r\n\t\t\t\tcvReleaseMat(&q);\r\n\t\t\t\tcvReleaseMat(&invK);\r\n\t\t\t\tcvReleaseMat(&invR);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tif (vTheta[iTheta].isStatic)\r\n\t\t{\r\n\t\t\tdouble IDCT = sqrt(1.0/(double)nFrames);\r\n\t\t\tdouble X = vTheta[iTheta].thetaX[0]*IDCT;\r\n\t\t\tdouble Y = vTheta[iTheta].thetaY[0]*IDCT;\r\n\t\t\tdouble Z = vTheta[iTheta].thetaZ[0]*IDCT;\r\n\t\t\tcameraParameter.push_back(X);\r\n\t\t\tcameraParameter.push_back(Y);\r\n\t\t\tcameraParameter.push_back(Z);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaX[iBase]);\r\n\t\t\t}\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaY[iBase]);\r\n\t\t\t}\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaZ[iBase]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tCvMat *visibilityMask = cvCreateMat(vTheta.size(), vCamera.size()*nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vFeature[iFeature].vFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[iFrame]);\r\n\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[iFrame]);\r\n\t\t\tcvSetReal2D(visibilityMask, iFeature, iFrame, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iFeature = 0; iFeature < visibilityMask->rows; iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < visibilityMask->cols; iFrame++)\r\n\t\t{\r\n\t\t\tvMask.push_back(cvGetReal2D(visibilityMask, iFeature, iFrame));\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&visibilityMask);\r\n}\r\n\r\nvoid GetParameterForGBA(vector<Feature> vFeature, vector<Camera> vCamera, vector<Theta> vTheta, CvMat *K, int nFrames,\r\n\t\t\t\t\t\tvector<double> &cameraParameter, vector<double> &feature2DParameter, CvMat &visibilityMask)\r\n{\r\n\tint nFeatures = vFeature.size();\r\n\r\n\tfor (int iCamera = 0; iCamera < vCamera.size(); iCamera++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < nFrames; iFrame++)\r\n\t\t{\r\n\t\t\tvector<int>::const_iterator it = find(vCamera[iCamera].vTakenFrame.begin(), vCamera[iCamera].vTakenFrame.end(), iFrame);\r\n\t\t\tif (it == vCamera[iCamera].vTakenFrame.end())\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t\tcameraParameter.push_back(0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t\t\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tCvMat *t = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n\t\t\t\tcvInvert(K, invK);\r\n\t\t\t\tGetSubMatColwise(vCamera[iCamera].vP[iFrame], 0, 2, R);\r\n\t\t\t\tGetSubMatColwise(vCamera[iCamera].vP[iFrame], 3, 3, t);\r\n\t\t\t\tcvMatMul(invK, R, R);\r\n\t\t\t\tcvInvert(R, invR);\r\n\t\t\t\tcvMatMul(invK, t, t);\r\n\t\t\t\tcvMatMul(invR, t, t);\r\n\t\t\t\tScalarMul(t, -1, t);\r\n\t\t\t\tRotation2Quaternion(R, q);\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 0, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 1, 0));\r\n\t\t\t\tcameraParameter.push_back(cvGetReal2D(t, 2, 0));\r\n\r\n\t\t\t\tcvReleaseMat(&R);\r\n\t\t\t\tcvReleaseMat(&t);\r\n\t\t\t\tcvReleaseMat(&q);\r\n\t\t\t\tcvReleaseMat(&invK);\r\n\t\t\t\tcvReleaseMat(&invR);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iTheta = 0; iTheta < vTheta.size(); iTheta++)\r\n\t{\r\n\t\tif (vTheta[iTheta].isStatic)\r\n\t\t{\r\n\t\t\tdouble IDCT = sqrt(1.0/(double)nFrames);\r\n\t\t\tdouble X = vTheta[iTheta].thetaX[0]*IDCT;\r\n\t\t\tdouble Y = vTheta[iTheta].thetaY[0]*IDCT;\r\n\t\t\tdouble Z = vTheta[iTheta].thetaZ[0]*IDCT;\r\n\t\t\tcameraParameter.push_back(X);\r\n\t\t\tcameraParameter.push_back(Y);\r\n\t\t\tcameraParameter.push_back(Z);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaX[iBase]);\r\n\t\t\t}\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaY[iBase]);\r\n\t\t\t}\r\n\t\t\tfor (int iBase = 0; iBase < vTheta[iTheta].thetaX.size(); iBase++)\r\n\t\t\t{\r\n\t\t\t\tcameraParameter.push_back(vTheta[iTheta].thetaZ[iBase]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tvisibilityMask = *cvCreateMat(vTheta.size(), vCamera.size()*nFrames, CV_32FC1);\r\n\r\n\tcvSetZero(&visibilityMask);\r\n\tint NZ = 0;\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tfor (int iFrame = 0; iFrame < vFeature[iFeature].vFrame.size(); iFrame++)\r\n\t\t{\r\n\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vx[iFrame]);\r\n\t\t\tfeature2DParameter.push_back(vFeature[iFeature].vy[iFrame]);\r\n\t\t\tcvSetReal2D(&visibilityMask, iFeature, iFrame, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//void GetCameraParameter(CvMat *P, CvMat *K, CvMat &R, CvMat &C)\r\n//{\r\n//\tR = *cvCreateMat(3,3,CV_32FC1);\r\n//\tC = *cvCreateMat(3,1,CV_32FC1);\r\n//\tCvMat *temp34 = cvCreateMat(3,4,CV_32FC1);\r\n//\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(K, invK);\r\n//\tcvMatMul(invK, P, temp34);\r\n//\tGetSubMatColwise(temp34, 0,2,&R);\r\n//\tGetSubMatColwise(temp34, 3,3,&C);\r\n//\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(&R, invR);\r\n//\tcvMatMul(invR, &C, &C);\r\n//\tScalarMul(&C, -1, &C);\r\n//\r\n//\tcvReleaseMat(&temp34);\r\n//\tcvReleaseMat(&invK);\r\n//\tcvReleaseMat(&invR);\r\n//}\r\n//\r\n//void GetCameraParameter(CvMat *P, CvMat *K, CvMat *R, CvMat *C)\r\n//{\r\n//\t//R = *cvCreateMat(3,3,CV_32FC1);\r\n//\t//C = *cvCreateMat(3,1,CV_32FC1);\r\n//\tCvMat *temp34 = cvCreateMat(3,4,CV_32FC1);\r\n//\tCvMat *invK = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(K, invK);\r\n//\tcvMatMul(invK, P, temp34);\r\n//\tGetSubMatColwise(temp34, 0,2,R);\r\n//\tGetSubMatColwise(temp34, 3,3,C);\r\n//\tCvMat *invR = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(R, invR);\r\n//\tcvMatMul(invR, C, C);\r\n//\tScalarMul(C, -1, C);\r\n//\r\n//\tcvReleaseMat(&temp34);\r\n//\tcvReleaseMat(&invK);\r\n//\tcvReleaseMat(&invR);\r\n//}\r\n\r\nvoid CreateCameraMatrix(CvMat *R, CvMat *C, CvMat *K, CvMat &P)\r\n{\r\n\tP = *cvCreateMat(3,4,CV_32FC1);\r\n\tcvSetIdentity(&P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(&P, 0,3, C);\r\n\tcvMatMul(R, &P, &P);\r\n\tcvMatMul(K, &P, &P);\r\n}\r\n\r\nvoid CreateCameraMatrix(CvMat *R, CvMat *C, CvMat *K, CvMat *P)\r\n{\r\n\tcvSetIdentity(P);\r\n\tScalarMul(C, -1, C);\r\n\tSetSubMat(P, 0,3, C);\r\n\tcvMatMul(R, P, P);\r\n\tcvMatMul(K, P, P);\r\n}\r\n\r\nint ExcludePointBehindCamera(CvMat *X, CvMat *P1, CvMat *P2, vector<int> featureID, vector<int> &excludedFeatureID, CvMat &cX)\r\n{\r\n\tCvMat *H1 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH1 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX1 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H1);\r\n\tSetSubMat(H1, 0, 0, P1);\r\n\tcvInvert(H1, invH1);\r\n\tPxx_inhomo(H1, X, HX1);\r\n\r\n\tCvMat *H2 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH2 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX2 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H2);\r\n\tSetSubMat(H2, 0, 0, P2);\r\n\tcvInvert(H2, invH2);\r\n\tPxx_inhomo(H2, X, HX2);\r\n\r\n\texcludedFeatureID.clear();\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((cvGetReal2D(HX1, i, 2) > 0) && (cvGetReal2D(HX2, i, 2) > 0))\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t\treturn 0;\r\n\tcX = *cvCreateMat(excludedFeatureID.size(),3, CV_32FC1);\r\n\tint k = 0;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((cvGetReal2D(HX1, i, 2) > 0) && (cvGetReal2D(HX2, i, 2) > 0))\t\t\r\n\t\t{\r\n\t\t\tcvSetReal2D(&cX, k, 0, cvGetReal2D(X, i, 0));\r\n\t\t\tcvSetReal2D(&cX, k, 1, cvGetReal2D(X, i, 1));\r\n\t\t\tcvSetReal2D(&cX, k, 2, cvGetReal2D(X, i, 2));\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint ExcludePointBehindCamera_mem(CvMat *X, CvMat *P1, CvMat *P2, vector<int> featureID, vector<int> &excludedFeatureID, vector<vector<double> > &cX)\r\n{\r\n\tCvMat *H1 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH1 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX1 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H1);\r\n\tSetSubMat(H1, 0, 0, P1);\r\n\tcvInvert(H1, invH1);\r\n\tPxx_inhomo(H1, X, HX1);\r\n\r\n\tCvMat *H2 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH2 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX2 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H2);\r\n\tSetSubMat(H2, 0, 0, P2);\r\n\tcvInvert(H2, invH2);\r\n\tPxx_inhomo(H2, X, HX2);\r\n\r\n\texcludedFeatureID.clear();\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((cvGetReal2D(HX1, i, 2) > 0) && (cvGetReal2D(HX2, i, 2) > 0))\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t{\r\n\t\tcvReleaseMat(&H1);\r\n\t\tcvReleaseMat(&HX1);\r\n\t\tcvReleaseMat(&H2);\r\n\t\tcvReleaseMat(&HX2);\r\n\t\tcvReleaseMat(&invH1);\r\n\t\tcvReleaseMat(&invH2);\r\n\t\treturn 0;\r\n\t}\r\n\t//cX = *cvCreateMat(excludedFeatureID.size(),3, CV_32FC1);\r\n\tint k = 0;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((cvGetReal2D(HX1, i, 2) > 0) && (cvGetReal2D(HX2, i, 2) > 0))\t\t\r\n\t\t{\r\n\t\t\tvector<double> cX_vec;\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 0));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 1));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 2));\r\n\r\n\t\t\tcX.push_back(cX_vec);\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&H1);\r\n\tcvReleaseMat(&HX1);\r\n\tcvReleaseMat(&H2);\r\n\tcvReleaseMat(&HX2);\r\n\tcvReleaseMat(&invH1);\r\n\tcvReleaseMat(&invH2);\r\n\treturn cX.size();\r\n}\r\n\r\nint ExcludePointBehindCamera_mem_fast(CvMat *X, CvMat *P1, CvMat *P2, vector<int> &featureID, vector<int> &excludedFeatureID, vector<vector<double> > &cX)\r\n{\r\n\tCvMat *H1 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH1 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX1 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H1);\r\n\tSetSubMat(H1, 0, 0, P1);\r\n\tcvInvert(H1, invH1);\r\n\tPxx_inhomo(H1, X, HX1);\r\n\r\n\tCvMat *H2 = cvCreateMat(4, 4, CV_32FC1);\tCvMat *invH2 = cvCreateMat(4, 4, CV_32FC1);\r\n\tCvMat *HX2 = cvCreateMat(X->rows, X->cols, CV_32FC1);\r\n\tcvSetIdentity(H2);\r\n\tSetSubMat(H2, 0, 0, P2);\r\n\tcvInvert(H2, invH2);\r\n\tPxx_inhomo(H2, X, HX2);\r\n\r\n\texcludedFeatureID.clear();\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((cvGetReal2D(HX1, i, 2) > 0) && (cvGetReal2D(HX2, i, 2) > 0))\r\n\t\t{\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\r\n\t\t\tvector<double> cX_vec;\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 0));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 1));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 2));\r\n\r\n\t\t\tcX.push_back(cX_vec);\r\n\t\t}\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t{\r\n\t\tcvReleaseMat(&H1);\r\n\t\tcvReleaseMat(&HX1);\r\n\t\tcvReleaseMat(&H2);\r\n\t\tcvReleaseMat(&HX2);\r\n\t\tcvReleaseMat(&invH1);\r\n\t\tcvReleaseMat(&invH2);\r\n\t\treturn 0;\r\n\t}\r\n\tcvReleaseMat(&H1);\r\n\tcvReleaseMat(&HX1);\r\n\tcvReleaseMat(&H2);\r\n\tcvReleaseMat(&HX2);\r\n\tcvReleaseMat(&invH1);\r\n\tcvReleaseMat(&invH2);\r\n\treturn cX.size();\r\n}\r\n\r\n\r\nint ExcludePointAtInfinity(CvMat *X, CvMat *P1, CvMat *P2, CvMat *K1, CvMat *K2, vector<int> featureID, vector<int> &excludedFeatureID, CvMat &cX)\r\n{\r\n\tCvMat *q1 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t1 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR1 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tCvMat *q2 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t2 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR2 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetSubMatColwise(P1, 0, 2, R1);\r\n\tGetSubMatColwise(P1, 3, 3, t1);\r\n\tcvInvert(K1, invK1);\r\n\tcvMatMul(invK1, R1, R1);\r\n\tcvInvert(R1, invR1);\r\n\tcvMatMul(invK1, t1, t1);\r\n\tcvMatMul(invR1, t1, t1);\r\n\tScalarMul(t1, -1, t1);\r\n\r\n\tGetSubMatColwise(P2, 0, 2, R2);\r\n\tGetSubMatColwise(P2, 3, 3, t2);\r\n\tcvInvert(K2, invK2);\r\n\tcvMatMul(invK2, R2, R2);\r\n\tcvInvert(R2, invR2);\r\n\tcvMatMul(invK2, t2, t2);\r\n\tcvMatMul(invR2, t2, t2);\r\n\tScalarMul(t2, -1, t2);\r\n\t\r\n\tdouble xC1 = cvGetReal2D(t1, 0, 0);\r\n\tdouble yC1 = cvGetReal2D(t1, 1, 0);\r\n\tdouble zC1 = cvGetReal2D(t1, 2, 0);\r\n\tdouble xC2 = cvGetReal2D(t2, 0, 0);\r\n\tdouble yC2 = cvGetReal2D(t2, 1, 0);\r\n\tdouble zC2 = cvGetReal2D(t2, 2, 0);\r\n\r\n\texcludedFeatureID.clear();\r\n\tvector<double> vInner;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tdouble x3D = cvGetReal2D(X, i, 0);\r\n\t\tdouble y3D = cvGetReal2D(X, i, 1);\r\n\t\tdouble z3D = cvGetReal2D(X, i, 2);\r\n\r\n\t\tdouble v1x = x3D - xC1;\t\tdouble v1y = y3D - yC1;\t\tdouble v1z = z3D - zC1;\r\n\t\tdouble v2x = x3D - xC2;\t\tdouble v2y = y3D - yC2;\t\tdouble v2z = z3D - zC2;\r\n\r\n\t\tdouble nv1 = sqrt(v1x*v1x+v1y*v1y+v1z*v1z);\r\n\t\tdouble nv2 = sqrt(v2x*v2x+v2y*v2y+v2z*v2z);\r\n\t\tv1x /= nv1;\t\tv1y /= nv1;\t\tv1z /= nv1;\r\n\t\tv2x /= nv2;\t\tv2y /= nv2;\t\tv2z /= nv2;\r\n\t\tdouble inner = v1x*v2x+v1y*v2y+v1z*v2z;\r\n\t\tvInner.push_back(inner);\r\n\t\tif ((abs(inner) < cos(PI/180*3)) && (inner > 0))\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t\treturn 0;\r\n\tcX = *cvCreateMat(excludedFeatureID.size(),3, CV_32FC1);\r\n\tint k = 0;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((abs(vInner[i]) < cos(PI/180*3)) && (vInner[i] > 0))\t\r\n\t\t{\r\n\t\t\tcvSetReal2D(&cX, k, 0, cvGetReal2D(X, i, 0));\r\n\t\t\tcvSetReal2D(&cX, k, 1, cvGetReal2D(X, i, 1));\r\n\t\t\tcvSetReal2D(&cX, k, 2, cvGetReal2D(X, i, 2));\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint ExcludePointAtInfinity_mem(CvMat *X, CvMat *P1, CvMat *P2, CvMat *K1, CvMat *K2, vector<int> featureID, vector<int> &excludedFeatureID, vector<vector<double> > &cX)\r\n{\r\n\tCvMat *q1 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t1 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR1 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tCvMat *q2 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t2 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR2 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetSubMatColwise(P1, 0, 2, R1);\r\n\tGetSubMatColwise(P1, 3, 3, t1);\r\n\tcvInvert(K1, invK1);\r\n\tcvMatMul(invK1, R1, R1);\r\n\tcvInvert(R1, invR1);\r\n\tcvMatMul(invK1, t1, t1);\r\n\tcvMatMul(invR1, t1, t1);\r\n\tScalarMul(t1, -1, t1);\r\n\r\n\tGetSubMatColwise(P2, 0, 2, R2);\r\n\tGetSubMatColwise(P2, 3, 3, t2);\r\n\tcvInvert(K2, invK2);\r\n\tcvMatMul(invK2, R2, R2);\r\n\tcvInvert(R2, invR2);\r\n\tcvMatMul(invK2, t2, t2);\r\n\tcvMatMul(invR2, t2, t2);\r\n\tScalarMul(t2, -1, t2);\r\n\r\n\tdouble xC1 = cvGetReal2D(t1, 0, 0);\r\n\tdouble yC1 = cvGetReal2D(t1, 1, 0);\r\n\tdouble zC1 = cvGetReal2D(t1, 2, 0);\r\n\tdouble xC2 = cvGetReal2D(t2, 0, 0);\r\n\tdouble yC2 = cvGetReal2D(t2, 1, 0);\r\n\tdouble zC2 = cvGetReal2D(t2, 2, 0);\r\n\r\n\texcludedFeatureID.clear();\r\n\tvector<double> vInner;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tdouble x3D = cvGetReal2D(X, i, 0);\r\n\t\tdouble y3D = cvGetReal2D(X, i, 1);\r\n\t\tdouble z3D = cvGetReal2D(X, i, 2);\r\n\r\n\t\tdouble v1x = x3D - xC1;\t\tdouble v1y = y3D - yC1;\t\tdouble v1z = z3D - zC1;\r\n\t\tdouble v2x = x3D - xC2;\t\tdouble v2y = y3D - yC2;\t\tdouble v2z = z3D - zC2;\r\n\r\n\t\tdouble nv1 = sqrt(v1x*v1x+v1y*v1y+v1z*v1z);\r\n\t\tdouble nv2 = sqrt(v2x*v2x+v2y*v2y+v2z*v2z);\r\n\t\tv1x /= nv1;\t\tv1y /= nv1;\t\tv1z /= nv1;\r\n\t\tv2x /= nv2;\t\tv2y /= nv2;\t\tv2z /= nv2;\r\n\t\tdouble inner = v1x*v2x+v1y*v2y+v1z*v2z;\r\n\t\tvInner.push_back(inner);\r\n\t\tif ((abs(inner) < cos(PI/180*3)) && (inner > 0))\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t{\r\n\t\tcvReleaseMat(&q1);\r\n\t\tcvReleaseMat(&R1);\r\n\t\tcvReleaseMat(&t1);\r\n\t\tcvReleaseMat(&invK1);\r\n\t\tcvReleaseMat(&invR1);\r\n\r\n\t\tcvReleaseMat(&q2);\r\n\t\tcvReleaseMat(&R2);\r\n\t\tcvReleaseMat(&t2);\r\n\t\tcvReleaseMat(&invK2);\r\n\t\tcvReleaseMat(&invR2);\r\n\t\treturn 0;\r\n\t}\r\n\tint k = 0;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tif ((abs(vInner[i]) < cos(PI/180*3)) && (vInner[i] > 0))\t\r\n\t\t{\r\n\t\t\tvector<double> cX_vec;\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 0));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 1));\r\n\t\t\tcX_vec.push_back(cvGetReal2D(X, i, 2));\r\n\t\t\tcX.push_back(cX_vec);\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\r\n\tcvReleaseMat(&q1);\r\n\tcvReleaseMat(&R1);\r\n\tcvReleaseMat(&t1);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invR1);\r\n\r\n\tcvReleaseMat(&q2);\r\n\tcvReleaseMat(&R2);\r\n\tcvReleaseMat(&t2);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&invR2);\r\n\treturn cX.size();\r\n}\r\n\r\nint ExcludePointAtInfinity_mem_fast(CvMat *X, CvMat *P1, CvMat *P2, CvMat *K1, CvMat *K2, vector<int> &featureID, vector<int> &excludedFeatureID, vector<vector<double> > &cX)\r\n{\r\n\tCvMat *q1 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t1 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK1 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR1 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tCvMat *q2 = cvCreateMat(4,1,CV_32FC1);\r\n\tCvMat *R2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *t2 = cvCreateMat(3,1,CV_32FC1);\r\n\tCvMat *invK2 = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *invR2 = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tGetSubMatColwise(P1, 0, 2, R1);\r\n\tGetSubMatColwise(P1, 3, 3, t1);\r\n\tcvInvert(K1, invK1);\r\n\tcvMatMul(invK1, R1, R1);\r\n\tcvInvert(R1, invR1);\r\n\tcvMatMul(invK1, t1, t1);\r\n\tcvMatMul(invR1, t1, t1);\r\n\tScalarMul(t1, -1, t1);\r\n\r\n\tGetSubMatColwise(P2, 0, 2, R2);\r\n\tGetSubMatColwise(P2, 3, 3, t2);\r\n\tcvInvert(K2, invK2);\r\n\tcvMatMul(invK2, R2, R2);\r\n\tcvInvert(R2, invR2);\r\n\tcvMatMul(invK2, t2, t2);\r\n\tcvMatMul(invR2, t2, t2);\r\n\tScalarMul(t2, -1, t2);\r\n\r\n\tdouble xC1 = cvGetReal2D(t1, 0, 0);\r\n\tdouble yC1 = cvGetReal2D(t1, 1, 0);\r\n\tdouble zC1 = cvGetReal2D(t1, 2, 0);\r\n\tdouble xC2 = cvGetReal2D(t2, 0, 0);\r\n\tdouble yC2 = cvGetReal2D(t2, 1, 0);\r\n\tdouble zC2 = cvGetReal2D(t2, 2, 0);\r\n\r\n\texcludedFeatureID.clear();\r\n\tvector<double> vInner;\r\n\tfor (int i = 0; i < X->rows; i++)\r\n\t{\r\n\t\tdouble x3D = cvGetReal2D(X, i, 0);\r\n\t\tdouble y3D = cvGetReal2D(X, i, 1);\r\n\t\tdouble z3D = cvGetReal2D(X, i, 2);\r\n\r\n\t\tdouble v1x = x3D - xC1;\t\tdouble v1y = y3D - yC1;\t\tdouble v1z = z3D - zC1;\r\n\t\tdouble v2x = x3D - xC2;\t\tdouble v2y = y3D - yC2;\t\tdouble v2z = z3D - zC2;\r\n\r\n\t\tdouble nv1 = sqrt(v1x*v1x+v1y*v1y+v1z*v1z);\r\n\t\tdouble nv2 = sqrt(v2x*v2x+v2y*v2y+v2z*v2z);\r\n\t\tv1x /= nv1;\t\tv1y /= nv1;\t\tv1z /= nv1;\r\n\t\tv2x /= nv2;\t\tv2y /= nv2;\t\tv2z /= nv2;\r\n\t\tdouble inner = v1x*v2x+v1y*v2y+v1z*v2z;\r\n\t\tvInner.push_back(inner);\r\n\t\tif ((abs(inner) < cos(PI/180*3)) && (inner > 0))\r\n\t\t{\t\t\t\r\n\t\t\tvector<double> cX_vec;\r\n\t\t\tcX_vec.push_back(x3D);\r\n\t\t\tcX_vec.push_back(y3D);\r\n\t\t\tcX_vec.push_back(z3D);\r\n\t\t\tcX.push_back(cX_vec);\r\n\t\t\texcludedFeatureID.push_back(featureID[i]);\r\n\t\t}\r\n\t}\r\n\tif (excludedFeatureID.size() == 0)\r\n\t{\r\n\t\tcvReleaseMat(&q1);\r\n\t\tcvReleaseMat(&R1);\r\n\t\tcvReleaseMat(&t1);\r\n\t\tcvReleaseMat(&invK1);\r\n\t\tcvReleaseMat(&invR1);\r\n\r\n\t\tcvReleaseMat(&q2);\r\n\t\tcvReleaseMat(&R2);\r\n\t\tcvReleaseMat(&t2);\r\n\t\tcvReleaseMat(&invK2);\r\n\t\tcvReleaseMat(&invR2);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tcvReleaseMat(&q1);\r\n\tcvReleaseMat(&R1);\r\n\tcvReleaseMat(&t1);\r\n\tcvReleaseMat(&invK1);\r\n\tcvReleaseMat(&invR1);\r\n\r\n\tcvReleaseMat(&q2);\r\n\tcvReleaseMat(&R2);\r\n\tcvReleaseMat(&t2);\r\n\tcvReleaseMat(&invK2);\r\n\tcvReleaseMat(&invR2);\r\n\treturn cX.size();\r\n}\r\n\r\n\r\n\r\nvoid ExcludePointHighReprojectionError(vector<Feature> vFeature, vector<CvMat *> cP, vector<int> vUsedFrame, vector<int> &visibleStrucrtureID, CvMat *X_tot)\r\n{\r\n\tvector<bool> temp;\r\n\ttemp.resize(visibleStrucrtureID.size(), true);\r\n\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t{\r\n\t\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\t\t\t\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\t\t\t\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy[idx];\r\n\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 5)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tif(temp[iVS])\r\n\t\t\t\t\t\ttemp[iVS] = false;\r\n\t\t\t\t}\r\n\t\t\t\tcvReleaseMat(&X);\r\n\t\t\t\tcvReleaseMat(&x);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvector<int> tempID;\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tif (temp[iVS])\r\n\t\t{\r\n\t\t\ttempID.push_back(visibleStrucrtureID[iVS]);\r\n\t\t}\r\n\t}\r\n\tvisibleStrucrtureID = tempID;\r\n}\r\n\r\nvoid ExcludePointHighReprojectionError_mem(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, vector<int> &visibleStrucrtureID, CvMat *X_tot)\r\n{\r\n\tvector<bool> temp;\r\n\ttemp.resize(visibleStrucrtureID.size(), true);\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t{\r\n\t\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, visibleStrucrtureID[iVS], 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy[idx];\r\n\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 5)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tif(temp[iVS])\r\n\t\t\t\t\t\ttemp[iVS] = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\tvector<int> tempID;\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tif (temp[iVS])\r\n\t\t{\r\n\t\t\ttempID.push_back(visibleStrucrtureID[iVS]);\r\n\t\t}\r\n\t}\r\n\tvisibleStrucrtureID = tempID;\r\n}\r\n\r\nint ExcludePointHighReprojectionError_mem_fast(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, CvMat *X_tot)\r\n{\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tint count1=0, count2=0;\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tcount1++;\r\n\t\t\tint nProj = 0;\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tnProj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (nProj == 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tint idx = (int) (it - vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iFeature, 0));\r\n\t\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iFeature, 1));\r\n\t\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iFeature, 2));\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\t\t//PrintMat(X);\r\n\t\t\t\t\t//PrintMat(cP[iP]);\r\n\t\t\t\t\t//PrintMat(x);\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tdouble u0 = vFeature[iFeature].vx[idx];\r\n\t\t\t\t\tdouble v0 = vFeature[iFeature].vy[idx];\r\n\t\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\t\tdouble dist = sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));\r\n\t\t\t\t\t//cout << dist << endl;\r\n\r\n\t\t\t\t\tif (dist > 3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvFeature[iFeature].vFrame.erase(vFeature[iFeature].vFrame.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx.erase(vFeature[iFeature].vx.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy.erase(vFeature[iFeature].vy.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx_dis.erase(vFeature[iFeature].vx_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy_dis.erase(vFeature[iFeature].vy_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vCamera.erase(vFeature[iFeature].vCamera.begin()+idx);\r\n\t\t\t\t\t\tnProj--;\r\n\t\t\t\t\t\tif (nProj < 2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvFeature[iFeature].isRegistered = false;\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << count2 << \" points are deleted.\" << endl;\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn count1;\r\n\r\n}\r\n\r\nint ExcludePointHighReprojectionError_mem_fast_Distortion(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, CvMat *X_tot, double omega, CvMat *K)\r\n{\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tint count1=0, count2=0;\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tcount1++;\r\n\t\t\tint nProj = 0;\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tnProj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (nProj == 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tint idx = (int) (it - vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iFeature, 0));\r\n\t\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iFeature, 1));\r\n\t\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iFeature, 2));\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\t\tdouble u = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\tdouble v = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\t\tdouble tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\t\tdouble K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\t\tdouble K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\t\tdouble K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\t\tdouble K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\t\tdouble u_n = u/K11 - K13/K11;\r\n\t\t\t\t\tdouble v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\t\t\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\t\tdouble u1 = u_d_n*K11 + K13;\r\n\t\t\t\t\tdouble v1 = v_d_n*K22 + K23;\r\n\r\n\t\t\t\t\tdouble u0 = vFeature[iFeature].vx_dis[idx];\r\n\t\t\t\t\tdouble v0 = vFeature[iFeature].vy_dis[idx];\r\n\r\n\r\n\t\t\t\t\tdouble dist = sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));\r\n\t\t\t\t\t//cout << dist << endl;\r\n\r\n\t\t\t\t\tif (dist > 3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvFeature[iFeature].vFrame.erase(vFeature[iFeature].vFrame.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx.erase(vFeature[iFeature].vx.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy.erase(vFeature[iFeature].vy.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx_dis.erase(vFeature[iFeature].vx_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy_dis.erase(vFeature[iFeature].vy_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vCamera.erase(vFeature[iFeature].vCamera.begin()+idx);\r\n\t\t\t\t\t\tnProj--;\r\n\t\t\t\t\t\tif (nProj < 2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvFeature[iFeature].isRegistered = false;\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << count2 << \" points are deleted.\" << endl;\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn count1;\r\n\r\n}\r\n\r\nint ExcludePointHighReprojectionError_mem_fast_Distortion_AD(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, CvMat *X_tot, double omega, CvMat *K, vector<vector<int> > &vvPointIndex)\r\n{\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tint count1=0, count2=0;\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tcount1++;\r\n\t\t\tint nProj = 0;\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tnProj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (nProj == 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tint idx = (int) (it - vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iFeature, 0));\r\n\t\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iFeature, 1));\r\n\t\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iFeature, 2));\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\t\tdouble u = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\tdouble v = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\t\tdouble tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\t\tdouble K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\t\tdouble K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\t\tdouble K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\t\tdouble K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\t\tdouble u_n = u/K11 - K13/K11;\r\n\t\t\t\t\tdouble v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\t\t\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\t\tdouble u1 = u_d_n*K11 + K13;\r\n\t\t\t\t\tdouble v1 = v_d_n*K22 + K23;\r\n\r\n\t\t\t\t\tdouble u0 = vFeature[iFeature].vx_dis[idx];\r\n\t\t\t\t\tdouble v0 = vFeature[iFeature].vy_dis[idx];\r\n\r\n\r\n\t\t\t\t\tdouble dist = sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));\r\n\t\t\t\t\t//cout << dist << endl;\r\n\r\n\t\t\t\t\tif (dist > 3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvector<int>::const_iterator it = find(vvPointIndex[iP].begin(), vvPointIndex[iP].end(), vFeature[iFeature].id);\r\n\t\t\t\t\t\t//if (it != vvPointIndex[iP].end())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tint idx_point = (int) (it - vvPointIndex[iP].begin());\r\n\t\t\t\t\t\t\tvvPointIndex[iP].erase(vvPointIndex[iP].begin()+idx_point);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\tvFeature[iFeature].vFrame.erase(vFeature[iFeature].vFrame.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx.erase(vFeature[iFeature].vx.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy.erase(vFeature[iFeature].vy.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx_dis.erase(vFeature[iFeature].vx_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy_dis.erase(vFeature[iFeature].vy_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vCamera.erase(vFeature[iFeature].vCamera.begin()+idx);\r\n\t\t\t\t\t\tnProj--;\r\n\t\t\t\t\t\tif (nProj < 2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvFeature[iFeature].isRegistered = false;\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << count2 << \" points are deleted.\" << endl;\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn count1;\r\n\r\n}\r\n\r\nint ExcludePointHighReprojectionError_mem_fast_AD(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, CvMat *X_tot, CvMat *K, vector<vector<int> > &vvPointIndex)\r\n{\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tint count1=0, count2=0;\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tcount1++;\r\n\t\t\tint nProj = 0;\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tnProj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (nProj == 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tint idx = (int) (it - vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iFeature, 0));\r\n\t\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iFeature, 1));\r\n\t\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iFeature, 2));\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\t\t//double tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\t\t//double K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\t\t//double K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\t\t//double K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\t\t//double K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\t\t//double u_n = u/K11 - K13/K11;\r\n\t\t\t\t\t//double v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\t\t//double r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\t\t//double r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\t\t//double u_d_n = r_d/r_u * u_n;\r\n\t\t\t\t\t//double v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\t\t//double u1 = u_d_n*K11 + K13;\r\n\t\t\t\t\t//double v1 = v_d_n*K22 + K23;\r\n\r\n\t\t\t\t\tdouble u0 = vFeature[iFeature].vx_dis[idx];\r\n\t\t\t\t\tdouble v0 = vFeature[iFeature].vy_dis[idx];\r\n\r\n\r\n\t\t\t\t\tdouble dist = sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));\r\n\t\t\t\t\t//cout << dist << endl;\r\n\r\n\t\t\t\t\tif (dist > 3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvector<int>::const_iterator it = find(vvPointIndex[iP].begin(), vvPointIndex[iP].end(), vFeature[iFeature].id);\r\n\t\t\t\t\t\tif (it != vvPointIndex[iP].end())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tint idx_point = (int) (it - vvPointIndex[iP].begin());\r\n\t\t\t\t\t\t\tvvPointIndex[iP].erase(vvPointIndex[iP].begin()+idx_point);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\tvFeature[iFeature].vFrame.erase(vFeature[iFeature].vFrame.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx.erase(vFeature[iFeature].vx.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy.erase(vFeature[iFeature].vy.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx_dis.erase(vFeature[iFeature].vx_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy_dis.erase(vFeature[iFeature].vy_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vCamera.erase(vFeature[iFeature].vCamera.begin()+idx);\r\n\t\t\t\t\t\tnProj--;\r\n\t\t\t\t\t\tif (nProj < 2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvFeature[iFeature].isRegistered = false;\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << count2 << \" points are deleted.\" << endl;\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn count1;\r\n\r\n}\r\n\r\n\r\n\r\nint ExcludePointHighReprojectionError_mem_fast_Distortion_ObstacleDetection(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> vUsedFrame, CvMat *X_tot, double omega, double princ_x1, double princ_y1, CvMat *K)\r\n{\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tint count1=0, count2=0;\r\n\r\n\tfor (int iFeature = 0; iFeature < vFeature.size(); iFeature++)\r\n\t{\r\n\t\tif (vFeature[iFeature].isRegistered)\r\n\t\t{\r\n\t\t\tcount1++;\r\n\t\t\tint nProj = 0;\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tnProj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (nProj == 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t\t{\r\n\t\t\t\tvector<int>:: const_iterator it = find(vFeature[iFeature].vFrame.begin(), vFeature[iFeature].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\t\tif (it != vFeature[iFeature].vFrame.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tint idx = (int) (it - vFeature[iFeature].vFrame.begin());\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iFeature, 0));\r\n\t\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iFeature, 1));\r\n\t\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iFeature, 2));\r\n\r\n\t\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\t\tdouble u = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t\tdouble v = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\t\tdouble tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\t\t//double K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\t\t//double K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\t\t//double K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\t\t//double K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\t\t//double u_n = u/K11 - K13/K11;\r\n\t\t\t\t\t//double v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\t\tdouble u_n = u - princ_x1;\r\n\t\t\t\t\tdouble v_n = v - princ_y1;\r\n\r\n\t\t\t\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\t\t\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\t\tdouble u1 = u_d_n + princ_x1;\r\n\t\t\t\t\tdouble v1 = v_d_n + princ_y1;\r\n\r\n\t\t\t\t\tdouble u0 = vFeature[iFeature].vx_dis[idx];\r\n\t\t\t\t\tdouble v0 = vFeature[iFeature].vy_dis[idx];\r\n\r\n\r\n\t\t\t\t\tdouble dist = sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1));\r\n\t\t\t\t\t//cout << dist << endl;\r\n\r\n\t\t\t\t\tif (dist > 3)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvFeature[iFeature].vFrame.erase(vFeature[iFeature].vFrame.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx.erase(vFeature[iFeature].vx.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy.erase(vFeature[iFeature].vy.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vx_dis.erase(vFeature[iFeature].vx_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vy_dis.erase(vFeature[iFeature].vy_dis.begin()+idx);\r\n\t\t\t\t\t\tvFeature[iFeature].vCamera.erase(vFeature[iFeature].vCamera.begin()+idx);\r\n\t\t\t\t\t\tnProj--;\r\n\t\t\t\t\t\tif (nProj < 2)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvFeature[iFeature].isRegistered = false;\r\n\t\t\t\t\t\t\tcount2++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << count2 << \" points are deleted.\" << endl;\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\treturn count1;\r\n\r\n}\r\n\r\n\r\n\r\nbool ExcludePointHighReprojectionError_AddingFrame(vector<Feature> vFeature, vector<CvMat *> cP, vector<int> vUsedFrame\r\n\t\t\t\t\t\t\t\t\t\t\t\t  , vector<int> &visibleStrucrtureID, CvMat &X_tot\r\n\t\t\t\t\t\t\t\t\t\t\t\t  , vector<int> &visibleStrucrtureID_new, CvMat &X_tot_new)\r\n{\r\n\tvisibleStrucrtureID_new.clear();\r\n\tvector<double> vx, vy, vz;\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tbool isIn = true;\r\n\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\t\t\t\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\t\t\t\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(&X_tot, iVS, 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(&X_tot, iVS, 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(&X_tot, iVS, 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy[idx];\r\n\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 5)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tisIn = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcvReleaseMat(&X);\r\n\t\t\t\tcvReleaseMat(&x);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isIn)\r\n\t\t{\r\n\t\t\tvisibleStrucrtureID_new.push_back(visibleStrucrtureID[iVS]);\r\n\t\t\tvx.push_back(cvGetReal2D(&X_tot, iVS, 0));\r\n\t\t\tvy.push_back(cvGetReal2D(&X_tot, iVS, 1));\r\n\t\t\tvz.push_back(cvGetReal2D(&X_tot, iVS, 2));\r\n\t\t}\r\n\t}\r\n\tif (visibleStrucrtureID_new.size() == 0)\r\n\t\treturn false;\r\n\tX_tot_new = *cvCreateMat(visibleStrucrtureID_new.size(), 3, CV_32FC1);\r\n\tfor (int ivx = 0; ivx < visibleStrucrtureID_new.size(); ivx++)\r\n\t{\r\n\t\tcvSetReal2D(&X_tot_new, ivx, 0, vx[ivx]);\r\n\t\tcvSetReal2D(&X_tot_new, ivx, 1, vy[ivx]);\r\n\t\tcvSetReal2D(&X_tot_new, ivx, 2, vz[ivx]);\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n\r\nbool ExcludePointHighReprojectionError_AddingFrame_mem(vector<Feature> &vFeature, vector<CvMat *> cP, vector<int> vUsedFrame\r\n\t\t\t\t\t\t\t\t\t\t\t\t   , vector<int> &visibleStrucrtureID, CvMat *X_tot\r\n\t\t\t\t\t\t\t\t\t\t\t\t   , vector<int> &visibleStrucrtureID_new, vector<vector<double> > &X_tot_new)\r\n{\r\n\tvisibleStrucrtureID_new.clear();\r\n\tvector<double> vx, vy, vz;\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tbool isIn = true;\r\n\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\t\t\t\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\t\t\t\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iVS, 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy[idx];\r\n\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 5)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tisIn = false;\r\n\t\t\t\t\tcvReleaseMat(&X);\r\n\t\t\t\t\tcvReleaseMat(&x);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcvReleaseMat(&X);\r\n\t\t\t\tcvReleaseMat(&x);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isIn)\r\n\t\t{\r\n\t\t\tvisibleStrucrtureID_new.push_back(visibleStrucrtureID[iVS]);\r\n\t\t\tvx.push_back(cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\tvy.push_back(cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\tvz.push_back(cvGetReal2D(X_tot, iVS, 2));\r\n\t\t}\r\n\t}\r\n\tif (visibleStrucrtureID_new.size() == 0)\r\n\t\treturn false;\r\n\r\n\tfor (int ivx = 0; ivx < visibleStrucrtureID_new.size(); ivx++)\r\n\t{\r\n\t\tvector<double> X_tot_new_vec;\r\n\t\tX_tot_new_vec.push_back(vx[ivx]);\r\n\t\tX_tot_new_vec.push_back(vy[ivx]);\r\n\t\tX_tot_new_vec.push_back(vz[ivx]);\r\n\t\tX_tot_new.push_back(X_tot_new_vec);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool ExcludePointHighReprojectionError_AddingFrame_mem_fast(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> &vUsedFrame\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t   , vector<int> &visibleStrucrtureID, CvMat *X_tot\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t   , vector<int> &visibleStrucrtureID_new, vector<vector<double> > &X_tot_new)\r\n{\r\n\tvisibleStrucrtureID_new.clear();\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tbool isIn = true;\r\n\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iVS, 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy[idx];\r\n\t\t\t\tdouble u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 5)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tisIn = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isIn)\r\n\t\t{\r\n\t\t\tvisibleStrucrtureID_new.push_back(visibleStrucrtureID[iVS]);\r\n\t\t\tvector<double> X_tot_new_vec;\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 2));\r\n\t\t\tX_tot_new.push_back(X_tot_new_vec);\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\tif (visibleStrucrtureID_new.size() == 0)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\nbool ExcludePointHighReprojectionError_AddingFrame_mem_fast_Distortion(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> &vUsedFrame\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vector<int> &visibleStrucrtureID, CvMat *X_tot\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vector<int> &visibleStrucrtureID_new, vector<vector<double> > &X_tot_new, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble omega, CvMat *K)\r\n{\r\n\tvisibleStrucrtureID_new.clear();\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tbool isIn = true;\r\n\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iVS, 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tdouble tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\tdouble K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\tdouble K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\tdouble K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\tdouble K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\tdouble u_n = u/K11 - K13/K11;\r\n\t\t\t\tdouble v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\t\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\tdouble u1 = u_d_n*K11 + K13;\r\n\t\t\t\tdouble v1 = v_d_n*K22 + K23;\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx_dis[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy_dis[idx];\r\n\t\t\t\t//double u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t//double v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 3)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tisIn = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isIn)\r\n\t\t{\r\n\t\t\tvisibleStrucrtureID_new.push_back(visibleStrucrtureID[iVS]);\r\n\t\t\tvector<double> X_tot_new_vec;\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 2));\r\n\t\t\tX_tot_new.push_back(X_tot_new_vec);\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\tif (visibleStrucrtureID_new.size() == 0)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\nbool ExcludePointHighReprojectionError_AddingFrame_mem_fast_Distortion_ObstacleDetection(vector<Feature> &vFeature, vector<CvMat *> &cP, vector<int> &vUsedFrame\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vector<int> &visibleStrucrtureID, CvMat *X_tot\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vector<int> &visibleStrucrtureID_new, vector<vector<double> > &X_tot_new, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble omega, double princ_x1, double princ_y1, CvMat *K)\r\n{\r\n\tvisibleStrucrtureID_new.clear();\r\n\tCvMat *X = cvCreateMat(4, 1, CV_32FC1);\r\n\tCvMat *x = cvCreateMat(3, 1, CV_32FC1);\r\n\tfor (int iVS = 0; iVS < visibleStrucrtureID.size(); iVS++)\r\n\t{\r\n\t\tbool isIn = true;\r\n\t\tfor (int iP = 0; iP < cP.size(); iP++)\r\n\t\t{\r\n\t\t\tvector<int>:: const_iterator it = find(vFeature[visibleStrucrtureID[iVS]].vFrame.begin(), vFeature[visibleStrucrtureID[iVS]].vFrame.end(), vUsedFrame[iP]);\r\n\t\t\tif (it != vFeature[visibleStrucrtureID[iVS]].vFrame.end())\r\n\t\t\t{\r\n\t\t\t\tint idx = (int) (it - vFeature[visibleStrucrtureID[iVS]].vFrame.begin());\r\n\r\n\t\t\t\tcvSetReal2D(X, 0, 0, cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\t\tcvSetReal2D(X, 1, 0, cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\t\tcvSetReal2D(X, 2, 0, cvGetReal2D(X_tot, iVS, 2));\r\n\r\n\t\t\t\tcvSetReal2D(X, 3, 0, 1);\r\n\t\t\t\tcvMatMul(cP[iP], X, x);\r\n\r\n\t\t\t\tdouble u = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\tdouble v = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tdouble tan_omega_half_2 = tan(omega/2)*2;\r\n\r\n\t\t\t\t//double K11 = cvGetReal2D(K, 0, 0);\r\n\t\t\t\t//double K22 = cvGetReal2D(K, 1, 1);\r\n\t\t\t\t//double K13 = cvGetReal2D(K, 0, 2);\r\n\t\t\t\t//double K23 = cvGetReal2D(K, 1, 2);\r\n\r\n\t\t\t\t//double u_n = u/K11 - K13/K11;\r\n\t\t\t\t//double v_n = v/K22 - K23/K22;\r\n\r\n\t\t\t\tdouble u_n = u - princ_x1;\r\n\t\t\t\tdouble v_n = v - princ_y1;\r\n\r\n\t\t\t\tdouble r_u = sqrt(u_n*u_n+v_n*v_n);\r\n\t\t\t\tdouble r_d = 1/omega*atan(r_u*tan_omega_half_2);\r\n\r\n\t\t\t\tdouble u_d_n = r_d/r_u * u_n;\r\n\t\t\t\tdouble v_d_n = r_d/r_u * v_n;\r\n\r\n\t\t\t\tdouble u1 = u_d_n + princ_x1;\r\n\t\t\t\tdouble v1 = v_d_n + princ_y1;\r\n\r\n\t\t\t\tdouble u0 = vFeature[visibleStrucrtureID[iVS]].vx_dis[idx];\r\n\t\t\t\tdouble v0 = vFeature[visibleStrucrtureID[iVS]].vy_dis[idx];\r\n\t\t\t\t//double u1 = cvGetReal2D(x, 0, 0)/cvGetReal2D(x, 2, 0);\r\n\t\t\t\t//double v1 = cvGetReal2D(x, 1, 0)/cvGetReal2D(x, 2, 0);\r\n\r\n\t\t\t\tif (sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) > 3)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout << visibleStrucrtureID[iVS] << \"th 3D point erased \" << sqrt((u0-u1)*(u0-u1)+(v0-v1)*(v0-v1)) << endl;\r\n\t\t\t\t\tisIn = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isIn)\r\n\t\t{\r\n\t\t\tvisibleStrucrtureID_new.push_back(visibleStrucrtureID[iVS]);\r\n\t\t\tvector<double> X_tot_new_vec;\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 0));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 1));\r\n\t\t\tX_tot_new_vec.push_back(cvGetReal2D(X_tot, iVS, 2));\r\n\t\t\tX_tot_new.push_back(X_tot_new_vec);\r\n\t\t}\r\n\t}\r\n\tcvReleaseMat(&X);\r\n\tcvReleaseMat(&x);\r\n\r\n\tif (visibleStrucrtureID_new.size() == 0)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid OrientationRefinement(CvMat *R_1, CvMat *R_F, vector<int> vFrame1, vector<int> vFrame2, vector<CvMat*> &vM, vector<CvMat*> &vm, vector<CvMat *> &vx1, vector<CvMat *> &vx2)\r\n{\r\n\t//PrintAlgorithm(\"Orientation Refinement\");\r\n\t//vector<double> cameraParameter, measurement;\r\n\t//AdditionalData adata;// focal_x focal_y princ_x princ_y\r\n\t////double intrinsic[4] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2)};\r\n\t////adata.vIntrinsic.push_back(intrinsic);\r\n\t//adata.nFrames = vFrame1.size();\r\n\r\n\t//adata.vx1 = &vx1;\r\n\t//adata.vx2 = &vx2;\r\n\r\n\t//for (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n\t//{\r\n\t//\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tRotation2Quaternion(vM[iFrame], q);\r\n\t//\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 0, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 1, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 2, 0));\r\n\t//\tcvReleaseMat(&q);\r\n\t//}\r\n\r\n\t//CvMat *R_r = cvCreateMat(3,3,CV_32FC1);\r\n\t//CvMat *R_1_inv = cvCreateMat(3,3,CV_32FC1);\r\n\t//cvInvert(R_1, R_1_inv);\r\n\t//cvMatMul(R_F, R_1_inv, R_r);\r\n\t//CvMat *q_r = cvCreateMat(4,1,CV_32FC1);\r\n\t//Rotation2Quaternion(R_r, q_r);\r\n\t//measurement.push_back(cvGetReal2D(q_r, 0, 0));\r\n\t//measurement.push_back(cvGetReal2D(q_r, 1, 0));\r\n\t//measurement.push_back(cvGetReal2D(q_r, 2, 0));\r\n\t//measurement.push_back(cvGetReal2D(q_r, 3, 0));\r\n\r\n\t//for (int i = 0; i < vx1.size(); i++)\r\n\t//{\r\n\t//\tif (vx1[i]->rows == 1)\r\n\t//\t\tcontinue;\r\n\t//\t//for (int j = 0; j < vx1[i]->rows; j++)\t\r\n\t//\tfor (int j = 0; j < 10; j++)\t\t\r\n\t//\t\tmeasurement.push_back(0);\r\n\t//}\r\n\t//cvReleaseMat(&R_r);\r\n\t//cvReleaseMat(&R_1_inv);\r\n\t//cvReleaseMat(&q_r);\r\n\r\n\t//double *dmeasurement = (double *) malloc(measurement.size() * sizeof(double));\r\n\t//double *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//for (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\tdCameraParameter[i] = cameraParameter[i];\r\n\t//for (int i = 0; i < measurement.size(); i++)\r\n\t//\tdmeasurement[i] = measurement[i];\r\n\r\n\t//double opt[5];\r\n\t//opt[0] = 1e-3;\r\n\t//opt[1] = 1e-12;\r\n\t//opt[2] = 1e-12;\r\n\t//opt[3] = 1e-12;\r\n\t//opt[4] = 0;\r\n\t//double info[12];\r\n\r\n\t//double *work = (double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), measurement.size())+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n\t//if(!work)\r\n\t//\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\t//int ret = dlevmar_dif(ObjectiveOrientationRefinement, dCameraParameter, dmeasurement, cameraParameter.size(), measurement.size(),\r\n\t//\t1e+2, opt, info, work, NULL, &adata);\r\n\r\n\t//PrintSBAInfo(info);\r\n\r\n\t//for (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n\t//{\r\n\t//\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n\t//\tcvSetReal2D(q, 0, 0, dCameraParameter[7*iFrame+0]);\r\n\t//\tcvSetReal2D(q, 1, 0, dCameraParameter[7*iFrame+1]);\r\n\t//\tcvSetReal2D(q, 2, 0, dCameraParameter[7*iFrame+2]);\r\n\t//\tcvSetReal2D(q, 3, 0, dCameraParameter[7*iFrame+3]);\r\n\t//\tQuaternion2Rotation(q, R);\r\n\t//\tfor (int i = 0; i < 3; i++)\r\n\t//\t{\r\n\t//\t\tfor (int j = 0; j < 3; j++)\r\n\t//\t\t{\r\n\t//\t\t\tcvSetReal2D(vM[iFrame], i, j, cvGetReal2D(R, i, j));\r\n\t//\t\t}\r\n\t//\t}\r\n\t//\tcvReleaseMat(&q);\r\n\t//\tcvReleaseMat(&R);\r\n\r\n\t//\tcvSetReal2D(vm[iFrame], 0, 0, dCameraParameter[7*iFrame+4]);\r\n\t//\tcvSetReal2D(vm[iFrame], 1, 0, dCameraParameter[7*iFrame+5]);\r\n\t//\tcvSetReal2D(vm[iFrame], 2, 0, dCameraParameter[7*iFrame+6]);\r\n\t//\t\r\n\t//}\r\n\r\n\t//free(dmeasurement);\r\n\t//free(dCameraParameter);\r\n\t//free(work);\r\n}\r\n\r\nvoid OrientationRefinement1(CvMat *R_1, CvMat *R_F, vector<int> vFrame1, vector<int> vFrame2, vector<CvMat*> &vM, vector<CvMat*> &vm, vector<CvMat *> &vx1, vector<CvMat *> &vx2, \r\n\t\t\t\t\t\t\t\t\t               vector<int> vFrame1_r, vector<int> vFrame2_r, vector<CvMat*> &vM_r, vector<CvMat*> &vm_r, vector<CvMat *> &vx1_r, vector<CvMat *> &vx2_r)\r\n{\r\n\t//PrintAlgorithm(\"Orientation Refinement for non-consecutive frame\");\r\n\t//\r\n\t//// focal_x focal_y princ_x princ_y\r\n\t////double intrinsic[4] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2)};\r\n\t////adata.vIntrinsic.push_back(intrinsic);\r\n\r\n\t//for (int iFrame = 0; iFrame < vFrame1_r.size(); iFrame++)\r\n\t//{\r\n\t//\tvector<double> cameraParameter, measurement;\r\n\t//\tAdditionalData adata;\r\n\t//\t//cout << endl << \"Orientation Refinement for non-consecutive frame: \" << vFrame1_r[iFrame] << \" \" << vFrame2_r[iFrame] << endl; \r\n\t//\tcout << vFrame1_r[iFrame] << \" \";\r\n\t//\tcameraParameter.clear();\r\n\t//\tmeasurement.clear();\r\n\t//\tvector<double> vx1_a, vy1_a, vx2_a, vy2_a;\r\n\t//\tfor (int ix = 0; ix < vx1_r[iFrame]->rows; ix++)\r\n\t//\t{\r\n\t//\t\tvx1_a.push_back(cvGetReal2D(vx1_r[iFrame], ix, 0));\r\n\t//\t\tvy1_a.push_back(cvGetReal2D(vx1_r[iFrame], ix, 1));\r\n\r\n\t//\t\tvx2_a.push_back(cvGetReal2D(vx2_r[iFrame], ix, 0));\r\n\t//\t\tvy2_a.push_back(cvGetReal2D(vx2_r[iFrame], ix, 1));\r\n\r\n\t//\t\tmeasurement.push_back(0);\r\n\t//\t}\r\n\r\n\t//\tadata.vx1_a = &vx1_a;\r\n\t//\tadata.vy1_a = &vy1_a;\r\n\t//\tadata.vx2_a = &vx2_a;\r\n\t//\tadata.vy2_a = &vy2_a;\r\n\t//\t\r\n\t//\tvector<int>::iterator it1 = find(vFrame1.begin(), vFrame1.end(), vFrame1_r[iFrame]);\r\n\t//\tvector<int>::iterator it2 = find(vFrame2.begin(), vFrame2.end(), vFrame2_r[iFrame]);\r\n\r\n\t//\tint idx1 = (int) (it1 - vFrame1.begin());\r\n\t//\tint idx2 = (int) (it2 - vFrame2.begin());\r\n\r\n\t//\tCvMat *R_r = cvCreateMat(3,3,CV_32FC1);\r\n\t//\tcvSetIdentity(R_r);\r\n\t//\tfor (int iIdx = idx1; iIdx < idx2+1; iIdx++)\r\n\t//\t{\r\n\t//\t\tcvMatMul(vM[iIdx], R_r, R_r);\r\n\t//\t}\r\n\r\n\t//\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n\t//\tRotation2Quaternion(R_r, q);\r\n\t//\t//Rotation2Quaternion(vM_r[iFrame], q);\r\n\r\n\t//\tadata.qw = cvGetReal2D(q, 0, 0);\r\n\t//\tadata.qx = cvGetReal2D(q, 1, 0);\r\n\t//\tadata.qy = cvGetReal2D(q, 2, 0);\r\n\t//\tadata.qz = cvGetReal2D(q, 3, 0);\r\n\t//\tcvReleaseMat(&q);\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 0, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 1, 0));\r\n\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 2, 0));\r\n\t//\t\r\n\r\n\t//\tcvSetReal2D(vM_r[iFrame], 0, 0, cvGetReal2D(R_r, 0, 0));\tcvSetReal2D(vM_r[iFrame], 0, 1, cvGetReal2D(R_r, 0, 1));\tcvSetReal2D(vM_r[iFrame], 0, 2, cvGetReal2D(R_r, 0, 2));\r\n\t//\tcvSetReal2D(vM_r[iFrame], 1, 0, cvGetReal2D(R_r, 1, 0));\tcvSetReal2D(vM_r[iFrame], 1, 1, cvGetReal2D(R_r, 1, 1));\tcvSetReal2D(vM_r[iFrame], 1, 2, cvGetReal2D(R_r, 1, 2));\r\n\t//\tcvSetReal2D(vM_r[iFrame], 2, 0, cvGetReal2D(R_r, 2, 0));\tcvSetReal2D(vM_r[iFrame], 2, 1, cvGetReal2D(R_r, 2, 1));\tcvSetReal2D(vM_r[iFrame], 2, 2, cvGetReal2D(R_r, 2, 2));\r\n\r\n\r\n\t//\t//for (int i = 0; i < vx1_r.size(); i++)\r\n\t//\t//{\r\n\t//\t//\tfor (int j = 0; j < vx1[i]->rows; j++)\t\t\r\n\t//\t//\t\tmeasurement.push_back(0);\r\n\t//\t//}\r\n\r\n\t//\tdouble *dmeasurement = (double *) malloc(measurement.size() * sizeof(double));\r\n\t//\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n\r\n\t//\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n\t//\t\tdCameraParameter[i] = cameraParameter[i];\r\n\t//\tfor (int i = 0; i < measurement.size(); i++)\r\n\t//\t\tdmeasurement[i] = measurement[i];\r\n\r\n\t//\tdouble opt[5];\r\n\t//\topt[0] = 1e-3;\r\n\t//\topt[1] = 1e-12;\r\n\t//\topt[2] = 1e-12;\r\n\t//\topt[3] = 1e-12;\r\n\t//\topt[4] = 0;\r\n\t//\tdouble info[12];\r\n\t//\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), measurement.size())+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n\t//\tif(!work)\r\n\t//\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n\r\n\t//\tint ret = dlevmar_dif(ObjectiveOrientationRefinement1, dCameraParameter, dmeasurement, cameraParameter.size(), measurement.size(),\r\n\t//\t\t1e+2, opt, info, work, NULL, &adata);\r\n\r\n\t//\t//PrintSBAInfo(info);\r\n\t//\tcvReleaseMat(&R_r);\r\n\r\n\t//\tcvSetReal2D(vm_r[iFrame], 0, 0, dCameraParameter[0]);\r\n\t//\tcvSetReal2D(vm_r[iFrame], 1, 0, dCameraParameter[1]);\r\n\t//\tcvSetReal2D(vm_r[iFrame], 2, 0, dCameraParameter[2]);\r\n\r\n\t//\tfree(dmeasurement);\r\n\t//\tfree(dCameraParameter);\r\n\t//\tfree(work);\r\n\t//}\r\n\t//cout << endl;\r\n}\r\n\r\n//void OrientationRefinement_sba(CvMat *R_1, CvMat *R_F, vector<int> vFrame1, vector<int> vFrame2, vector<CvMat*> &vM, vector<CvMat*> &vm, vector<CvMat *> &vx1, vector<CvMat *> &vx2, \r\n//\t\t\t\t\t\t\tvector<int> vFrame1_r, vector<int> vFrame2_r, vector<CvMat*> &vM_r, vector<CvMat*> &vm_r, vector<CvMat *> &vx1_r, vector<CvMat *> &vx2_r)\r\n//{\r\n//\tPrintAlgorithm(\"Orientation Refinement - sba\");\r\n//\tvector<double> cameraParameter, measurement;\r\n//\tAdditionalData adata;// focal_x focal_y princ_x princ_y\r\n//\t//double intrinsic[4] = {cvGetReal2D(K, 0, 0), cvGetReal2D(K, 1, 1), cvGetReal2D(K, 0, 2), cvGetReal2D(K, 1, 2)};\r\n//\t//adata.vIntrinsic.push_back(intrinsic);\r\n//\t//adata.vFrame1 = vFrame1;\r\n//\t//adata.vFrame2 = vFrame2;\r\n//\t//adata.vFrame1_r = vFrame1_r;\r\n//\t//adata.vFrame2_r = vFrame2_r;\r\n//\r\n//\t//adata.vx1 = &vx1;\r\n//\t//adata.vx2 = &vx2;\r\n//\r\n//\t//adata.vx1_r = &vx1_r;\r\n//\t//adata.vx2_r = &vx2_r;\r\n//\r\n//\t//for (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n//\t//{\r\n//\t//\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n//\t//\tRotation2Quaternion(vM[iFrame], q);\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n//\t//\tcvReleaseMat(&q);\r\n//\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 0, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 1, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 2, 0));\r\n//\t//}\r\n//\r\n//\t//for (int iFrame = 0; iFrame < vFrame1_r.size(); iFrame++)\r\n//\t//{\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 0, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 1, 0));\r\n//\t//\tcameraParameter.push_back(cvGetReal2D(vm_r[iFrame], 2, 0));\r\n//\t//}\r\n//\r\n//\tCvMat *R_r = cvCreateMat(3,3,CV_32FC1);\r\n//\tCvMat *R_1_inv = cvCreateMat(3,3,CV_32FC1);\r\n//\tcvInvert(R_1, R_1_inv);\r\n//\tcvMatMul(R_F, R_1_inv, R_r);\r\n//\tCvMat *q_r = cvCreateMat(4,1,CV_32FC1);\r\n//\tRotation2Quaternion(R_r, q_r);\r\n//\t//measurement.push_back(cvGetReal2D(q_r, 0, 0));\r\n//\t//measurement.push_back(cvGetReal2D(q_r, 1, 0));\r\n//\t//measurement.push_back(cvGetReal2D(q_r, 2, 0));\r\n//\t//measurement.push_back(cvGetReal2D(q_r, 3, 0));\r\n//\r\n//\tfor (int i = 0; i < vx1.size(); i++)\r\n//\t{\r\n//\t\tfor (int j = 0; j < vx1[i]->rows; j++)\t\r\n//\t\t//for (int j = 0; j < 7; j++)\t\t\r\n//\t\t\tmeasurement.push_back(0);\r\n//\t}\r\n//\r\n//\t//for (int i = 0; i < vx1_r.size(); i++)\r\n//\t//{\r\n//\t//\tfor (int j = 0; j < vx1[i]->rows; j++)\t\r\n//\t//\t//for (int j = 0; j < 3; j++)\t\t\r\n//\t//\t\tmeasurement.push_back(0);\r\n//\t//}\r\n//\r\n//\tcameraParameter.push_back(cvGetReal2D(q_r, 0, 0));\r\n//\tcameraParameter.push_back(cvGetReal2D(q_r, 1, 0));\r\n//\tcameraParameter.push_back(cvGetReal2D(q_r, 2, 0));\r\n//\tcameraParameter.push_back(cvGetReal2D(q_r, 3, 0));\r\n//\r\n//\tfor (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n//\t{\r\n//\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n//\t\tRotation2Quaternion(vM[iFrame], q);\r\n//\t\tcameraParameter.push_back(cvGetReal2D(q, 0, 0));\r\n//\t\tcameraParameter.push_back(cvGetReal2D(q, 1, 0));\r\n//\t\tcameraParameter.push_back(cvGetReal2D(q, 2, 0));\r\n//\t\tcameraParameter.push_back(cvGetReal2D(q, 3, 0));\r\n//\t\tcvReleaseMat(&q);\r\n//\r\n//\t\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 0, 0));\r\n//\t\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 1, 0));\r\n//\t\tcameraParameter.push_back(cvGetReal2D(vm[iFrame], 2, 0));\r\n//\t}\r\n//\r\n//\r\n//\r\n//\tcvReleaseMat(&R_r);\r\n//\tcvReleaseMat(&R_1_inv);\r\n//\tcvReleaseMat(&q_r);\r\n//\r\n//\tdouble *dmeasurement = (double *) malloc(measurement.size() * sizeof(double));\r\n//\tdouble *dCameraParameter = (double *) malloc(cameraParameter.size() * sizeof(double));\r\n//\r\n//\tfor (int i = 0; i < cameraParameter.size(); i++)\r\n//\t\tdCameraParameter[i] = cameraParameter[i];\r\n//\tfor (int i = 0; i < measurement.size(); i++)\r\n//\t\tdmeasurement[i] = measurement[i];\r\n//\r\n//\tdouble opt[5];\r\n//\topt[0] = 1e-3;\r\n//\topt[1] = 1e-5;\r\n//\topt[2] = 1e-5;\r\n//\topt[3] = 1e-5;\r\n//\topt[4] = 0;\r\n//\tdouble info[12];\r\n//\r\n//\tint ret = sba_mot_levmar()\r\n//\r\n//\tdouble *work = (double*)malloc((LM_DIF_WORKSZ(cameraParameter.size(), measurement.size())+cameraParameter.size()*cameraParameter.size())*sizeof(double));\r\n//\tif(!work)\r\n//\t\tfprintf(stderr, \"memory allocation request failed in main()\\n\");\r\n//\r\n//\tint ret = dlevmar_dif(ObjectiveOrientationRefinement1, dCameraParameter, dmeasurement, cameraParameter.size(), measurement.size(),\r\n//\t\t1e+2, opt, info, work, NULL, &adata);\r\n//\r\n//\tPrintSBAInfo(info);\r\n//\tvector<double> vR11, vR12, vR13, vR21, vR22, vR23, vR31, vR32, vR33;\r\n//\tfor (int iFrame = 0; iFrame < vFrame1.size(); iFrame++)\r\n//\t{\r\n//\t\tCvMat *q = cvCreateMat(4,1,CV_32FC1);\r\n//\t\tCvMat *R = cvCreateMat(3,3,CV_32FC1);\r\n//\t\tcvSetReal2D(q, 0, 0, dCameraParameter[7*iFrame+0]);\r\n//\t\tcvSetReal2D(q, 1, 0, dCameraParameter[7*iFrame+1]);\r\n//\t\tcvSetReal2D(q, 2, 0, dCameraParameter[7*iFrame+2]);\r\n//\t\tcvSetReal2D(q, 3, 0, dCameraParameter[7*iFrame+3]);\r\n//\t\tQuaternion2Rotation(q, R);\r\n//\t\tfor (int i = 0; i < 3; i++)\r\n//\t\t{\r\n//\t\t\tfor (int j = 0; j < 3; j++)\r\n//\t\t\t{\r\n//\t\t\t\tcvSetReal2D(vM[iFrame], i, j, cvGetReal2D(R, i, j));\r\n//\t\t\t}\r\n//\t\t}\r\n//\r\n//\t\tvR11.push_back(cvGetReal2D(R, 0, 0));\tvR12.push_back(cvGetReal2D(R, 0, 1));\tvR13.push_back(cvGetReal2D(R, 0, 2));\r\n//\t\tvR21.push_back(cvGetReal2D(R, 1, 0));\tvR22.push_back(cvGetReal2D(R, 1, 1));\tvR23.push_back(cvGetReal2D(R, 1, 2));\r\n//\t\tvR31.push_back(cvGetReal2D(R, 2, 0));\tvR32.push_back(cvGetReal2D(R, 2, 1));\tvR33.push_back(cvGetReal2D(R, 2, 2));\r\n//\t\tcvReleaseMat(&q);\r\n//\t\tcvReleaseMat(&R);\r\n//\r\n//\t\tcvSetReal2D(vm[iFrame], 0, 0, dCameraParameter[7*iFrame+4]);\r\n//\t\tcvSetReal2D(vm[iFrame], 1, 0, dCameraParameter[7*iFrame+5]);\r\n//\t\tcvSetReal2D(vm[iFrame], 2, 0, dCameraParameter[7*iFrame+6]);\r\n//\t}\r\n//\r\n//\tfor (int iFrame_r = 0; iFrame_r < vFrame1_r.size(); iFrame_r++)\r\n//\t{\r\n//\t\tdouble R11 = 1;\t\tdouble R12 = 0;\t\tdouble R13 = 0;\r\n//\t\tdouble R21 = 0;\t\tdouble R22 = 1;\t\tdouble R23 = 0;\r\n//\t\tdouble R31 = 0;\t\tdouble R32 = 0;\t\tdouble R33 = 1;\r\n//\r\n//\t\tfor (int iFrame = vFrame1_r[iFrame_r]; iFrame < vFrame2_r[iFrame_r]; iFrame++)\r\n//\t\t{\r\n//\t\t\tR11 = vR11[iFrame]*R11 + vR12[iFrame]*R21 + vR13[iFrame]*R31;\r\n//\t\t\tR12 = vR11[iFrame]*R12 + vR12[iFrame]*R22 + vR13[iFrame]*R32;\r\n//\t\t\tR13 = vR11[iFrame]*R13 + vR12[iFrame]*R23 + vR13[iFrame]*R33;\r\n//\r\n//\t\t\tR21 = vR21[iFrame]*R11 + vR22[iFrame]*R21 + vR23[iFrame]*R31;\r\n//\t\t\tR22 = vR21[iFrame]*R12 + vR22[iFrame]*R22 + vR23[iFrame]*R32;\r\n//\t\t\tR23 = vR21[iFrame]*R13 + vR22[iFrame]*R23 + vR23[iFrame]*R33;\r\n//\r\n//\t\t\tR31 = vR31[iFrame]*R11 + vR32[iFrame]*R21 + vR33[iFrame]*R31;\r\n//\t\t\tR32 = vR31[iFrame]*R12 + vR32[iFrame]*R22 + vR33[iFrame]*R32;\r\n//\t\t\tR33 = vR31[iFrame]*R13 + vR32[iFrame]*R23 + vR33[iFrame]*R33;\r\n//\t\t}\r\n//\t\tcvSetReal2D(vM_r[iFrame_r], 0, 0, R11);\tcvSetReal2D(vM_r[iFrame_r], 0, 1, R12);\tcvSetReal2D(vM_r[iFrame_r], 0, 2, R13);\r\n//\t\tcvSetReal2D(vM_r[iFrame_r], 1, 0, R21);\tcvSetReal2D(vM_r[iFrame_r], 1, 1, R22);\tcvSetReal2D(vM_r[iFrame_r], 1, 2, R23);\r\n//\t\tcvSetReal2D(vM_r[iFrame_r], 2, 0, R31);\tcvSetReal2D(vM_r[iFrame_r], 2, 1, R32);\tcvSetReal2D(vM_r[iFrame_r], 2, 2, R33);\r\n//\r\n//\t\tcvSetReal2D(vm_r[iFrame_r], 0, 0, dCameraParameter[7*vFrame1.size()+3*iFrame_r+0]);\r\n//\t\tcvSetReal2D(vm_r[iFrame_r], 1, 0, dCameraParameter[7*vFrame1.size()+3*iFrame_r+1]);\r\n//\t\tcvSetReal2D(vm_r[iFrame_r], 2, 0, dCameraParameter[7*vFrame1.size()+3*iFrame_r+2]);\r\n//\t}\r\n//\r\n//\tfree(dmeasurement);\r\n//\tfree(dCameraParameter);\r\n//\tfree(work);\r\n//}\r\n\r\nvoid DetectPOI(vector<CvMat *> vP, vector<CvMat *> vV, int nSegments, double range, double merging_threshold, vector<double> vBandwidth, vector<CvMat *> &vPOI,\r\n\t\t\t   double epsilon_cov, int nSegments_cov, vector<CvMat *> &v_a_cov, vector<CvMat *> &v_b_cov, vector<CvMat *> &v_l_cov, vector<double> &vf)\r\n{\r\n\r\n\tvector<CvMat *> vPOI_temp;\r\n\tvector<vector<double> > vvWeight;\r\n\tfor (int iP = 0; iP < vP.size(); iP++)\r\n\t{\r\n\t\tfor (int iSeg = 0; iSeg < nSegments; iSeg++)\r\n\t\t{\r\n\t\t\tdouble y1, y2, y3;\r\n\t\t\ty1 = cvGetReal2D(vP[iP], 0, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 0, 0);\r\n\t\t\ty2 = cvGetReal2D(vP[iP], 1, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 1, 0);\r\n\t\t\ty3 = cvGetReal2D(vP[iP], 2, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 2, 0);\r\n\r\n\t\t\tbool isBad = false;\r\n\t\t\tint nIter = 0;\r\n\t\t\tvector<double> vWeight;\r\n\t\t\tvector<double> vWeight_temp;\r\n\t\t\twhile (1)\r\n\t\t\t{\r\n\t\t\t\tdouble yp1 = y1, yp2 = y2, yp3 = y3;\r\n\t\t\t\tvWeight.clear();\r\n\t\t\t\tMeanShift_Gaussian_Cone(y1, y2, y3, vP, vV, vBandwidth, vWeight);\r\n\t\t\t\tdouble normDiff = sqrt((y1-yp1)*(y1-yp1)+(y2-yp2)*(y2-yp2)+(y3-yp3)*(y3-yp3));\r\n\t\t\t\tif (normDiff < 1e-5)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tnIter++;\r\n\t\t\t\tif (nIter > 2000)\r\n\t\t\t\t{\r\n\t\t\t\t\tisBad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isBad)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tdouble sumw = 0;\r\n\t\t\tfor (int iw = 0; iw < vWeight.size(); iw++)\r\n\t\t\t{\r\n\t\t\t\tsumw += vWeight[iw];\r\n\t\t\t}\r\n\t\t\tfor (int iw = 0; iw < vWeight.size(); iw++)\r\n\t\t\t{\r\n\t\t\t\tvWeight[iw] /= sumw;\r\n\t\t\t}\r\n\r\n\t\t\tvWeight_temp = vWeight;\r\n\r\n\t\t\tsort(vWeight.begin(), vWeight.end());\r\n\t\t\tif (vWeight[vWeight.size()-2]/vWeight[vWeight.size()-1] > 0.01)\r\n\t\t\t{\r\n\t\t\t\tif (vPOI_temp.empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tCvMat *poi = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\t\tcvSetReal2D(poi, 0, 0, y1);\r\n\t\t\t\t\tcvSetReal2D(poi, 1, 0, y2);\r\n\t\t\t\t\tcvSetReal2D(poi, 2, 0, y3);\r\n\t\t\t\t\tvPOI_temp.push_back(poi);\r\n\t\t\t\t\tvvWeight.push_back(vWeight_temp);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbool isIn = false;\r\n\t\t\t\t\tfor (int iPoi = 0; iPoi < vPOI_temp.size(); iPoi++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdouble c1 = cvGetReal2D(vPOI_temp[iPoi], 0, 0) - y1;\r\n\t\t\t\t\t\tdouble c2 = cvGetReal2D(vPOI_temp[iPoi], 1, 0) - y2;\r\n\t\t\t\t\t\tdouble c3 = cvGetReal2D(vPOI_temp[iPoi], 2, 0) - y3;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (sqrt(c1*c1+c2*c2+c3*c3) < merging_threshold)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisIn = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!isIn)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCvMat *poi = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 0, 0, y1);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 1, 0, y2);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 2, 0, y3);\r\n\t\t\t\t\t\tvPOI_temp.push_back(poi);\r\n\t\t\t\t\t\tvvWeight.push_back(vWeight_temp);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (int iPOI = 0; iPOI < vPOI_temp.size(); iPOI++)\r\n\t{\r\n\t\tvector<double> v_a, v_b, v_l;\r\n\t\tbool isGood = POICovariance(vP, vV, vBandwidth, vPOI_temp[iPOI], epsilon_cov, nSegments_cov, v_a, v_b, v_l);\r\n\t\tif (!isGood)\r\n\t\t\tcontinue;\r\n\r\n\t\tCvMat *a = cvCreateMat(v_a.size(), 1, CV_32FC1);\r\n\t\tCvMat *b = cvCreateMat(v_b.size(), 1, CV_32FC1);\r\n\t\tCvMat *l = cvCreateMat(v_b.size(), 1, CV_32FC1);\r\n\r\n\t\tfor (int ia = 0; ia < v_a.size(); ia++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(a, ia, 0, v_a[ia]);\r\n\t\t\tcvSetReal2D(b, ia, 0, v_b[ia]);\r\n\t\t\tcvSetReal2D(l, ia, 0, v_l[ia]);\r\n\t\t}\r\n\r\n\t\tv_a_cov.push_back(a);\r\n\t\tv_b_cov.push_back(b);\r\n\t\tv_l_cov.push_back(l);\r\n\r\n\t\tdouble f0 = EvaulateDensityFunction(vP, vV, vBandwidth, vPOI_temp[iPOI]);\r\n\t\tvf.push_back(f0);\r\n\r\n\t\tvPOI.push_back(cvCloneMat(vPOI_temp[iPOI]));\r\n\r\n\r\n\t\t//CvMat *U = cvCreateMat(3,3,CV_32FC1);\r\n\t\t//CvMat *Radius = cvCreateMat(3,1, CV_32FC1);\r\n\t\t//PrintMat(vPOI[iPOI]);\r\n\t\t//POICovariance(vP, vV, vvWeight[iPOI], U, Radius);\r\n\t\t//vU.push_back(U);\r\n\t\t//vRadius.push_back(Radius);\r\n\t}\r\n\tfor (int i = 0; i < vPOI.size(); i++)\r\n\t{\r\n\t\tcvReleaseMat(&vPOI_temp[i]);\r\n\t}\r\n\tvPOI_temp.clear();\r\n}\r\n\r\nvoid DetectPOI(vector<CvMat *> vP, vector<CvMat *> vV, int nSegments, double range, double merging_threshold, vector<double> vBandwidth, vector<CvMat *> &vPOI,\r\n\t\t\t   double epsilon_cov, int nSegments_cov, vector<CvMat *> &v_a_cov, vector<CvMat *> &v_b_cov, vector<CvMat *> &v_l_cov, vector<double> &vf, \r\n\t\t\t   vector<vector<CvMat *> > &vvMeanTrajectory)\r\n{\r\n\r\n\tvector<CvMat *> vPOI_temp;\r\n\tvector<vector<double> > vvWeight;\r\n\tfor (int iP = 0; iP < vP.size(); iP++)\r\n\t{\r\n\t\tfor (int iSeg = 0; iSeg < nSegments; iSeg++)\r\n\t\t{\r\n\t\t\tdouble y1, y2, y3;\r\n\t\t\ty1 = cvGetReal2D(vP[iP], 0, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 0, 0);\r\n\t\t\ty2 = cvGetReal2D(vP[iP], 1, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 1, 0);\r\n\t\t\ty3 = cvGetReal2D(vP[iP], 2, 0)+(range/(double)nSegments)*(iSeg+1)*cvGetReal2D(vV[iP], 2, 0);\r\n\r\n\t\t\tbool isBad = false;\r\n\t\t\tint nIter = 0;\r\n\t\t\tvector<double> vWeight;\r\n\t\t\tvector<double> vWeight_temp;\r\n\r\n\t\t\tvector<double> mean_x;\r\n\t\t\tvector<double> mean_y;\r\n\t\t\tvector<double> mean_z;\r\n\t\t\twhile (1)\r\n\t\t\t{\r\n\t\t\t\tmean_x.push_back(y1);\r\n\t\t\t\tmean_y.push_back(y2);\r\n\t\t\t\tmean_z.push_back(y3);\r\n\t\t\t\tdouble yp1 = y1, yp2 = y2, yp3 = y3;\r\n\t\t\t\tvWeight.clear();\r\n\t\t\t\tMeanShift_Gaussian_Cone(y1, y2, y3, vP, vV, vBandwidth, vWeight);\r\n\t\t\t\tdouble normDiff = sqrt((y1-yp1)*(y1-yp1)+(y2-yp2)*(y2-yp2)+(y3-yp3)*(y3-yp3));\r\n\t\t\t\tif (normDiff < 1e-5)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tnIter++;\r\n\t\t\t\tif (nIter > 2000)\r\n\t\t\t\t{\r\n\t\t\t\t\tisBad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isBad)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tdouble sumw = 0;\r\n\t\t\tfor (int iw = 0; iw < vWeight.size(); iw++)\r\n\t\t\t{\r\n\t\t\t\tsumw += vWeight[iw];\r\n\t\t\t}\r\n\t\t\tfor (int iw = 0; iw < vWeight.size(); iw++)\r\n\t\t\t{\r\n\t\t\t\tvWeight[iw] /= sumw;\r\n\t\t\t}\r\n\r\n\t\t\tvWeight_temp = vWeight;\r\n\r\n\t\t\tsort(vWeight.begin(), vWeight.end());\r\n\t\t\tif (vWeight[vWeight.size()-2]/vWeight[vWeight.size()-1] > 0.1)\r\n\t\t\t{\r\n\t\t\t\tvector<CvMat *> vMean;\r\n\t\t\t\tfor (int ii = 0; ii < mean_x.size(); ii++)\r\n\t\t\t\t{\r\n\t\t\t\t\tCvMat *mm = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\t\tcvSetReal2D(mm, 0, 0, mean_x[ii]);\r\n\t\t\t\t\tcvSetReal2D(mm, 1, 0, mean_y[ii]);\r\n\t\t\t\t\tcvSetReal2D(mm, 2, 0, mean_z[ii]);\r\n\t\t\t\t\tvMean.push_back(mm);\r\n\t\t\t\t}\r\n\t\t\t\tvvMeanTrajectory.push_back(vMean);\r\n\r\n\t\t\t\tif (vPOI_temp.empty())\r\n\t\t\t\t{\r\n\t\t\t\t\tCvMat *poi = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\t\tcvSetReal2D(poi, 0, 0, y1);\r\n\t\t\t\t\tcvSetReal2D(poi, 1, 0, y2);\r\n\t\t\t\t\tcvSetReal2D(poi, 2, 0, y3);\r\n\t\t\t\t\tvPOI_temp.push_back(poi);\r\n\t\t\t\t\tvvWeight.push_back(vWeight_temp);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbool isIn = false;\r\n\t\t\t\t\tfor (int iPoi = 0; iPoi < vPOI_temp.size(); iPoi++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdouble c1 = cvGetReal2D(vPOI_temp[iPoi], 0, 0) - y1;\r\n\t\t\t\t\t\tdouble c2 = cvGetReal2D(vPOI_temp[iPoi], 1, 0) - y2;\r\n\t\t\t\t\t\tdouble c3 = cvGetReal2D(vPOI_temp[iPoi], 2, 0) - y3;\r\n\r\n\t\t\t\t\t\tif (sqrt(c1*c1+c2*c2+c3*c3) < merging_threshold)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisIn = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!isIn)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCvMat *poi = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 0, 0, y1);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 1, 0, y2);\r\n\t\t\t\t\t\tcvSetReal2D(poi, 2, 0, y3);\r\n\t\t\t\t\t\tvPOI_temp.push_back(poi);\r\n\t\t\t\t\t\tvvWeight.push_back(vWeight_temp);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int iPOI = 0; iPOI < vPOI_temp.size(); iPOI++)\r\n\t{\r\n\t\tvector<double> v_a, v_b, v_l;\r\n\t\tbool isGood = POICovariance(vP, vV, vBandwidth, vPOI_temp[iPOI], epsilon_cov, nSegments_cov, v_a, v_b, v_l);\r\n\t\tif (!isGood)\r\n\t\t{\r\n\t\t\tvector<vector<CvMat *> > vvMeanTraj_temp;\r\n\t\t\tfor (int iTraj = 0; iTraj < vvMeanTrajectory.size(); iTraj++)\r\n\t\t\t{\r\n\t\t\t\tdouble traj_x = cvGetReal2D(vvMeanTrajectory[iTraj][vvMeanTrajectory[iTraj].size()-1], 0, 0);\r\n\t\t\t\tdouble traj_y = cvGetReal2D(vvMeanTrajectory[iTraj][vvMeanTrajectory[iTraj].size()-1], 1, 0);\r\n\t\t\t\tdouble traj_z = cvGetReal2D(vvMeanTrajectory[iTraj][vvMeanTrajectory[iTraj].size()-1], 2, 0);\r\n\t\t\t\tdouble error = sqrt((traj_x-cvGetReal2D(vPOI_temp[iPOI], 0, 0))*(traj_x-cvGetReal2D(vPOI_temp[iPOI], 0, 0))+\r\n\t\t\t\t\t\t\t\t\t(traj_y-cvGetReal2D(vPOI_temp[iPOI], 1, 0))*(traj_y-cvGetReal2D(vPOI_temp[iPOI], 1, 0))+\r\n\t\t\t\t\t\t\t\t\t(traj_z-cvGetReal2D(vPOI_temp[iPOI], 2, 0))*(traj_z-cvGetReal2D(vPOI_temp[iPOI], 2, 0)));\r\n\t\t\t\tif (error < 1e-3)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvvMeanTraj_temp.push_back(vvMeanTrajectory[iTraj]);\r\n\t\t\t}\r\n\t\t\tvvMeanTrajectory = vvMeanTraj_temp;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tCvMat *a = cvCreateMat(v_a.size(), 1, CV_32FC1);\r\n\t\tCvMat *b = cvCreateMat(v_b.size(), 1, CV_32FC1);\r\n\t\tCvMat *l = cvCreateMat(v_b.size(), 1, CV_32FC1);\r\n\r\n\t\tfor (int ia = 0; ia < v_a.size(); ia++)\r\n\t\t{\r\n\t\t\tcvSetReal2D(a, ia, 0, v_a[ia]);\r\n\t\t\tcvSetReal2D(b, ia, 0, v_b[ia]);\r\n\t\t\tcvSetReal2D(l, ia, 0, v_l[ia]);\r\n\t\t}\r\n\r\n\t\tv_a_cov.push_back(a);\r\n\t\tv_b_cov.push_back(b);\r\n\t\tv_l_cov.push_back(l);\r\n\r\n\t\tdouble f0 = EvaulateDensityFunction(vP, vV, vBandwidth, vPOI_temp[iPOI]);\r\n\t\tvf.push_back(f0);\r\n\r\n\t\tvPOI.push_back(cvCloneMat(vPOI_temp[iPOI]));\r\n\r\n\r\n\t\t//CvMat *U = cvCreateMat(3,3,CV_32FC1);\r\n\t\t//CvMat *Radius = cvCreateMat(3,1, CV_32FC1);\r\n\t\t//PrintMat(vPOI[iPOI]);\r\n\t\t//POICovariance(vP, vV, vvWeight[iPOI], U, Radius);\r\n\t\t//vU.push_back(U);\r\n\t\t//vRadius.push_back(Radius);\r\n\t}\r\n\tfor (int i = 0; i < vPOI.size(); i++)\r\n\t{\r\n\t\tcvReleaseMat(&vPOI_temp[i]);\r\n\t}\r\n\tvPOI_temp.clear();\r\n}\r\n\r\n\r\nbool POICovariance(vector<CvMat *> vP, vector<CvMat *> vV, vector<double> vBandwidth, CvMat *poi, double epsilon, int nSegments, vector<double> &v_a, vector<double> &v_b, vector<double> &v_l)\r\n{\r\n\tdouble f0 = EvaulateDensityFunction(vP, vV, vBandwidth, poi);\r\n\tdouble phi_step = 2*PI/nSegments;\r\n\tdouble theta_step = PI/(nSegments/2);\r\n\r\n\tbool isGood = true;\r\n\r\n\tfor (int iphi = 0; iphi < nSegments; iphi++)\r\n\t{\r\n\t\tfor (int itheta = 0; itheta < nSegments/2+1; itheta++)\r\n\t\t{\r\n\t\t\tCvMat *v = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tcvSetReal2D(v, 0, 0, cos(iphi*phi_step)*sin(itheta*theta_step));\r\n\t\t\tcvSetReal2D(v, 1, 0, sin(iphi*phi_step)*sin(itheta*theta_step));\r\n\t\t\tcvSetReal2D(v, 2, 0, cos(itheta*theta_step));\r\n\t\t\tCvMat *v_temp = cvCreateMat(3,1,CV_32FC1);\r\n\r\n\t\t\tCvMat *x = cvCreateMat(3,1,CV_32FC1);\r\n\t\t\tScalarMul(v, epsilon, v_temp);\r\n\t\t\tcvAdd(poi, v_temp, x);\r\n\t\t\tdouble f = EvaulateDensityFunction(vP, vV, vBandwidth, x);\r\n\t\t\tif ((f0-f)/(-epsilon) > -5e-2)\r\n\t\t\t{\r\n\t\t\t\tisGood = false;\r\n\t\t\t\tv_a.push_back(-5e-2);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tv_a.push_back((f0-f)/(-epsilon));\r\n\t\t\tv_b.push_back(f0);\r\n\r\n\t\t\tdouble alpha = 0;\r\n\t\t\twhile (1)\r\n\t\t\t{\r\n\t\t\t\talpha = alpha + 0.1;\r\n\t\t\t\tScalarMul(v, epsilon+alpha, v_temp);\r\n\t\t\t\tcvAdd(poi, v_temp, x);\r\n\t\t\t\tf = EvaulateDensityFunction(vP, vV, vBandwidth, x);\r\n\t\t\t\tdouble y = (f0-f)/(-epsilon) * (epsilon+alpha) + f0;\r\n\t\t\t\tif (abs(f-y) > 1e+0)\r\n\t\t\t\t{\r\n\t\t\t\t\tv_l.push_back(alpha+epsilon);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcvReleaseMat(&v);\r\n\t\t\tcvReleaseMat(&x);\r\n\t\t}\r\n\t}\r\n\treturn isGood;\r\n}\r\n\r\ndouble EvaulateDensityFunction(vector<CvMat *> vP, vector<CvMat *> vV, vector<double> vBandwidth, CvMat *x)\r\n{\r\n\tdouble f = 0;\r\n\tfor (int ip = 0; ip < vP.size(); ip++)\r\n\t{\r\n\t\tdouble norm_v = sqrt(cvGetReal2D(vV[ip], 0, 0)*cvGetReal2D(vV[ip], 0, 0)+cvGetReal2D(vV[ip], 1, 0)*cvGetReal2D(vV[ip], 1, 0)+cvGetReal2D(vV[ip], 2, 0)*cvGetReal2D(vV[ip], 2, 0));\r\n\t\tScalarMul(vV[ip], 1/norm_v, vV[ip]);\r\n\t\tCvMat *xmp = cvCreateMat(3,1,CV_32FC1);\r\n\t\tcvSub(x, vP[ip], xmp);\r\n\t\tCvMat *dot_product = cvCreateMat(1,1,CV_32FC1);\r\n\t\tCvMat *v_t = cvCreateMat(1,3,CV_32FC1);\r\n\t\tcvTranspose(vV[ip], v_t);\r\n\t\tcvMatMul(v_t, xmp, dot_product);\r\n\t\tCvMat *dx = cvCreateMat(3,1,CV_32FC1);\r\n\t\tCvMat *dot_ray = cvCreateMat(3,1,CV_32FC1);\r\n\t\tScalarMul(vV[ip], cvGetReal2D(dot_product, 0, 0), dot_ray);\r\n\t\tcvSub(xmp, dot_ray, dx);\r\n\t\tif (cvGetReal2D(dot_product, 0, 0) > 0)\r\n\t\t{\r\n\t\t\tdouble dist1 = sqrt(cvGetReal2D(dx, 0, 0)*cvGetReal2D(dx, 0, 0)+cvGetReal2D(dx, 1, 0)*cvGetReal2D(dx, 1, 0)+cvGetReal2D(dx, 2, 0)*cvGetReal2D(dx, 2, 0));\r\n\t\t\tdouble dist2 = cvGetReal2D(dot_product, 0, 0);\r\n\r\n\t\t\tf+= 1/vBandwidth[ip] * exp(-(dist1/dist2)*(dist1/dist2)/2/vBandwidth[ip]/vBandwidth[ip]);\r\n\t\t}\r\n\r\n\t\tcvReleaseMat(&xmp);\r\n\t\tcvReleaseMat(&dot_product);\r\n\t\tcvReleaseMat(&v_t);\r\n\t\tcvReleaseMat(&dx);\r\n\t\tcvReleaseMat(&dot_ray);\r\n\t}\r\n\tf /= vP.size();\r\n\treturn f;\r\n}\r\n\r\nvoid POICovariance(vector<CvMat *> vP, vector<CvMat *> vV, vector<double> vWeight, CvMat *U, CvMat *Radius)\r\n{\r\n\tCvMat *A = cvCreateMat(3*vP.size(), 3, CV_32FC1);\r\n\tCvMat *b = cvCreateMat(3*vP.size(), 1, CV_32FC1);\r\n\r\n\tfor (int iCamera = 0; iCamera < vP.size(); iCamera++)\r\n\t{\r\n\t\tCvMat *Ai = cvCreateMat(3,3, CV_32FC1);\r\n\t\tCvMat *bi = cvCreateMat(3,1, CV_32FC1);\r\n\r\n\t\tVec2Skew(vV[iCamera], Ai);\r\n\t\tScalarMul(Ai, vWeight[iCamera], Ai);\r\n\t\tcvMatMul(Ai, vP[iCamera], bi);\r\n\r\n\t\tSetSubMat(A, 3*iCamera, 0, Ai);\r\n\t\tSetSubMat(b, 3*iCamera, 0, bi);\r\n\r\n\t\tcvReleaseMat(&Ai);\r\n\t\tcvReleaseMat(&bi);\r\n\t}\r\n\r\n\tdouble meanb = 0;\r\n\tfor (int ib = 0; ib < b->rows; ib++)\r\n\t{\r\n\t\tmeanb += cvGetReal2D(b, ib, 0);\r\n\t}\r\n\tmeanb /= b->rows;\r\n\r\n\tdouble varianceb = 0;\r\n\tfor (int ib = 0; ib < b->rows; ib++)\r\n\t{\r\n\t\tvarianceb += (cvGetReal2D(b, ib, 0)-meanb)*(cvGetReal2D(b, ib, 0)-meanb);\r\n\t}\r\n\tvarianceb /= b->rows;\r\n\r\n\tCvMat *At = cvCreateMat(A->cols, A->rows, CV_32FC1);\r\n\tcvTranspose(A, At);\r\n\tCvMat *Q = cvCreateMat(3,3,CV_32FC1);\r\n\tcvMatMul(At, A, Q);\r\n\tcvInvert(Q, Q);\r\n\tScalarMul(Q, varianceb, Q);\r\n\r\n\tCvMat *D = cvCreateMat(3,3,CV_32FC1);\r\n\tCvMat *V = cvCreateMat(3,3,CV_32FC1);\r\n\r\n\tcvSVD(Q, D, U, V);\r\n\tcvSetReal2D(Radius, 0, 0, sqrt(cvGetReal2D(D, 0, 0)));\r\n\tcvSetReal2D(Radius, 1, 0, sqrt(cvGetReal2D(D, 1, 1)));\r\n\tcvSetReal2D(Radius, 2, 0, sqrt(cvGetReal2D(D, 2, 2)));\r\n\r\n\r\n\tcvReleaseMat(&D);\r\n\tcvReleaseMat(&V);\r\n\tcvReleaseMat(&Q);\r\n\tcvReleaseMat(&A);\r\n\tcvReleaseMat(&At);\r\n\tcvReleaseMat(&b);\r\n}\r\n\r\nvoid MeanShift_Gaussian_Cone(double &y1, double &y2, double &y3, vector<CvMat *> vP, vector<CvMat *> vV, vector<double> vBandwidth, vector<double> &vWeight)\r\n{\r\n\tdouble sum1 = 0, sum2 = 0, sum3 = 0;\r\n\tdouble normalization = 0;\r\n\r\n\tfor (int iP = 0; iP < vP.size(); iP++)\r\n\t{\r\n\t\tdouble dist, gradient1, gradient2, gradient3;\r\n\t\tDistanceBetweenConeAndPoint(cvGetReal2D(vP[iP], 0, 0), cvGetReal2D(vP[iP], 1, 0), cvGetReal2D(vP[iP], 2, 0), \r\n\t\t\tcvGetReal2D(vV[iP], 0, 0), cvGetReal2D(vV[iP], 1, 0), cvGetReal2D(vV[iP], 2, 0),\t\r\n\t\t\ty1, y2, y3, dist);\r\n\r\n\t\tdouble xmp1 = y1-cvGetReal2D(vP[iP], 0, 0);\r\n\t\tdouble xmp2 = y2-cvGetReal2D(vP[iP], 1, 0);\r\n\t\tdouble xmp3 = y3-cvGetReal2D(vP[iP], 2, 0);\r\n\t\tdouble v1 = cvGetReal2D(vV[iP], 0, 0);\r\n\t\tdouble v2 = cvGetReal2D(vV[iP], 1, 0);\r\n\t\tdouble v3 = cvGetReal2D(vV[iP], 2, 0);\r\n\t\tdouble v_norm = sqrt(v1*v1+v2*v2+v3*v3);\r\n\t\t\r\n\t\tv1 /= v_norm;\r\n\t\tv2 /= v_norm;\r\n\t\tv3 /= v_norm;\r\n\r\n\t\tdouble vxmp1 = v1*xmp1;\r\n\t\tdouble vxmp2 = v2*xmp2;\r\n\t\tdouble vxmp3 = v3*xmp3;\r\n\r\n\t\tdouble vxmp = vxmp1+vxmp2+vxmp3;\r\n\t\tdouble x_tilde1 = cvGetReal2D(vP[iP], 0, 0) + (vxmp + dist*dist*vxmp)*v1;\r\n\t\tdouble x_tilde2 = cvGetReal2D(vP[iP], 1, 0) + (vxmp + dist*dist*vxmp)*v2;\r\n\t\tdouble x_tilde3 = cvGetReal2D(vP[iP], 2, 0) + (vxmp + dist*dist*vxmp)*v3;\r\n\r\n\t\tdouble weight = exp(-dist*dist/vBandwidth[iP]/vBandwidth[iP]/2)/(vBandwidth[iP]*vBandwidth[iP]*vBandwidth[iP]*vxmp*vxmp);\r\n\t\tsum1 += weight * x_tilde1;\r\n\t\tsum2 += weight * x_tilde2;\r\n\t\tsum3 += weight * x_tilde3;\r\n\t\tnormalization += weight;\r\n\t\tvWeight.push_back(weight);\r\n\t}\r\n\r\n\ty1 = sum1/normalization;\r\n\ty2 = sum2/normalization;\r\n\ty3 = sum3/normalization;\r\n}\r\n\r\nvoid MeanShift_Gaussian_Ray(double &y1, double &y2, double &y3, vector<CvMat *> vP, vector<CvMat *> vV, double bandwidth, vector<double> &vWeight)\r\n{\r\n\tdouble sum1 = 0, sum2 = 0, sum3 = 0;\r\n\tdouble normalization = 0;\r\n\r\n\tfor (int iP = 0; iP < vP.size(); iP++)\r\n\t{\r\n\t\tdouble dist, gradient1, gradient2, gradient3;\r\n\t\tDistanceBetweenRayAndPoint(cvGetReal2D(vP[iP], 0, 0), cvGetReal2D(vP[iP], 1, 0), cvGetReal2D(vP[iP], 2, 0), \r\n\t\t\t\t\t\t\t\t   cvGetReal2D(vV[iP], 0, 0), cvGetReal2D(vV[iP], 1, 0), cvGetReal2D(vV[iP], 2, 0),\t\r\n\t\t\t\t\t\t\t\t   y1, y2, y3, dist, gradient1, gradient2, gradient3);\r\n\t\tdouble dir1, dir2, dir3;\r\n\t\tdir1 = y1-cvGetReal2D(vP[iP], 0, 0);\r\n\t\tdir2 = y2-cvGetReal2D(vP[iP], 1, 0);\r\n\t\tdir3 = y3-cvGetReal2D(vP[iP], 2, 0);\r\n\r\n\t\tdouble dot_product = dir1*cvGetReal2D(vV[iP], 0, 0)+dir2*cvGetReal2D(vV[iP], 1, 0)+dir3*cvGetReal2D(vV[iP], 2, 0);\r\n\r\n\t\tif (dot_product < 0)\r\n\t\t{\r\n\t\t\tdist = 1e+6;\r\n\t\t}\r\n\t\t\r\n\t\tsum1 += gradient1*exp(-dist*dist/bandwidth/bandwidth);\r\n\t\tsum2 += gradient2*exp(-dist*dist/bandwidth/bandwidth);\r\n\t\tsum3 += gradient3*exp(-dist*dist/bandwidth/bandwidth);\t\r\n\r\n\t\tnormalization += exp(-dist*dist/bandwidth/bandwidth);\t\r\n\t\tvWeight.push_back(exp(-dist*dist/bandwidth/bandwidth));\r\n\t}\r\n\r\n\ty1 = sum1/normalization;\r\n\ty2 = sum2/normalization;\r\n\ty3 = sum3/normalization;\r\n}\r\n\r\nvoid DistanceBetweenRayAndPoint(double p1, double p2, double p3, double v1, double v2, double v3, double x1, double x2, double x3,\r\n\t\t\t\t\t\t\t\tdouble &d, double &g1, double &g2, double &g3)\r\n{\r\n\tdouble v_norm = sqrt(v1*v1+v2*v2+v3*v3);\r\n\tv1 /= v_norm;\r\n\tv2 /= v_norm;\r\n\tv3 /= v_norm;\r\n\tdouble xmp1 = x1-p1;\r\n\tdouble xmp2 = x2-p2;\r\n\tdouble xmp3 = x3-p3;\r\n\r\n\tdouble xmp_dot_v1 = xmp1*v1;\r\n\tdouble xmp_dot_v2 = xmp1*v2;\r\n\tdouble xmp_dot_v3 = xmp1*v3;\r\n\r\n\tdouble d1 = xmp1-xmp_dot_v1*v1;\r\n\tdouble d2 = xmp2-xmp_dot_v2*v2;\r\n\tdouble d3 = xmp3-xmp_dot_v3*v3;\r\n\r\n\td = sqrt(d1*d1+d2*d2+d3*d3);\r\n\t\r\n\tg1 = p1 + xmp_dot_v1*v1;\r\n\tg2 = p2 + xmp_dot_v2*v2;\r\n\tg3 = p3 + xmp_dot_v3*v3;\r\n}\r\n\r\nvoid DistanceBetweenConeAndPoint(double p1, double p2, double p3, double v1, double v2, double v3, double x1, double x2, double x3,\r\n\t\t\t\t\t\t\t\tdouble &d)\r\n{\r\n\tdouble v_norm = sqrt(v1*v1+v2*v2+v3*v3);\r\n\tv1 /= v_norm;\r\n\tv2 /= v_norm;\r\n\tv3 /= v_norm;\r\n\tdouble xmp1 = x1-p1;\r\n\tdouble xmp2 = x2-p2;\r\n\tdouble xmp3 = x3-p3;\r\n\r\n\tdouble xmp_dot_v1 = xmp1*v1;\r\n\tdouble xmp_dot_v2 = xmp2*v2;\r\n\tdouble xmp_dot_v3 = xmp3*v3;\r\n\r\n\tdouble direction = xmp_dot_v1+xmp_dot_v2+xmp_dot_v3;\r\n\r\n\tif (direction > 0)\r\n\t{\r\n\t\tdouble upper1 = xmp1 - direction*v1;\r\n\t\tdouble upper2 = xmp2 - direction*v2;\r\n\t\tdouble upper3 = xmp3 - direction*v3;\r\n\r\n\t\td = sqrt(upper1*upper1+upper2*upper2+upper3*upper3)/direction;\r\n\t}\r\n\telse\r\n\t{\r\n\t\td = 1e+6;\r\n\t}\r\n}\r\n",
        "blame_info": {
            "francis9012@gmail.com": [
                [
                    1,
                    10299
                ]
            ]
        }
    },
    {
        "blob_id": "483636595ef27a032fb65294e55c02e76cef77eb",
        "directory_id": "89421a99baeeb9a368104340ad4efa5f68e2268b",
        "path": "/cpp/Fem1d/Fem1d.cpp",
        "content_id": "1795d3ce24e60bc2e100e31feb3145252abc3cbc",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "mtsodf/ppgi_elem",
        "snapshot_id": "c16c510c3f78c1e0eb363a36178f79be60818c0a",
        "revision_id": "910155619cb94423eb47dfe793f64be01e750c5a",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-09-06 07:20:18",
        "revision_date": "2018-02-03 18:24:21",
        "committer_date": "2018-02-03 18:24:21",
        "github_id": 105206139,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 9068,
        "extension": "cpp",
        "content": "#include \"Fem1d.h\"\n#include \"../definitions.h\"\n#include <stdlib.h>\n#include \"../LinearAlgebra/Jacobi.h\"\n#include \"../LinearAlgebra/Operations.h\"\n#include <cmath>\n#include \"../Utils/Utils.h\"\n\n\nusing namespace std;\n\nclass UndefinedFuncForm: public exception\n{\n  virtual const char* what() const throw()\n  {\n    return \"Undefined func form\";\n  }\n};\n\nreal FuncForm(real qsi, char func){\n    if(func == 0) return (1.0 - qsi)/2.0;\n    if(func == 1) return (1.0 + qsi)/2.0;\n    UndefinedFuncForm ex;\n    throw ex;\n}\n\nreal DFuncForm(real qsi, char func){\n    if(func == 0) return -1.0/2.0;\n    if(func == 1) return  1.0/2.0;\n    UndefinedFuncForm ex;\n    throw ex;\n}\n\nvoid LocalMatrix(real alpha, real beta, real he, real* lm){\n\n    real w;\n\n    w = sqrt(3.0)/3.0;\n\n    for (size_t i = 0; i < 2; i++)\n    {\n        for (size_t j = 0; j < 2; j++)\n        {\n            lm[2*i+j]  = (he/2)*beta*(FuncForm(-w,i)*FuncForm(-w,j)) + (2/he)*alpha*(DFuncForm(-w,i)*DFuncForm(-w,j));\n            lm[2*i+j] += (he/2)*beta*(FuncForm( w,i)*FuncForm( w,j)) + (2/he)*alpha*(DFuncForm( w,i)*DFuncForm( w,j));\n        }\n    }\n}\n\nvoid GlobalMatrix(int n, real alpha, real beta, real *K, int boundary){\n    real * hs;\n\n    real h = 1.0/n;\n    hs = (real*) malloc(sizeof(real)*n);\n\n    for (size_t i = 0; i < n; i++)\n    {\n        hs[i] = h;\n    }\n\n    GlobalMatrix(n, alpha, beta, hs, K, boundary);\n}\n\nvoid GlobalMatrix(int n, real alpha, real beta, real* hs, real *K, int boundary){\n\n    real lm[4];\n    int ndofs = n + 1;\n    for (size_t i = 0; i < n; i++)\n    {\n        LocalMatrix(alpha, beta, hs[i], lm);\n        K[DIM(i,i,ndofs)] += lm[0];\n        K[DIM(i,i+1,ndofs)] += lm[1];\n        K[DIM(i+1,i,ndofs)] += lm[2];\n        K[DIM(i+1,i+1,ndofs)] += lm[3];\n        \n    }\n\n    if(boundary == DIRICHLET || boundary == DIRICHLET_NEUMANN){\n        K[DIM(0,0,ndofs)] = 1.0;\n        K[DIM(0,1,ndofs)] = 0.0;\n        K[DIM(1,0,ndofs)] = 0.0;\n    }\n\n    if(boundary == DIRICHLET || boundary == NEUMANN_DIRICHLET){\n        K[DIM(ndofs-1,ndofs-2,ndofs)] = 0.0;\n        K[DIM(ndofs-2,ndofs-1,ndofs)] = 0.0;\n        K[DIM(ndofs-1,ndofs-1,ndofs)] = 1.0;\n    }\n\n}\n\n\nvoid RhsLocal(real he, real f1, real f2, real *Fe){\n\n    real w = sqrt(3)/3.0;\n    Fe[0]  = f1*(he/2)*(FuncForm(-w,0) * FuncForm(-w,0) + FuncForm(w,0) * FuncForm(w,0));\n    Fe[0] += f2*(he/2)*(FuncForm(-w,0) * FuncForm(-w,1) + FuncForm(w,0) * FuncForm(w,1));\n\n\n    Fe[1]  = f1*(he/2)*(FuncForm(-w,1) * FuncForm(-w,0) + FuncForm(w,1) * FuncForm(w,0));\n    Fe[1] += f2*(he/2)*(FuncForm(-w,1) * FuncForm(-w,1) + FuncForm(w,1) * FuncForm(w,1));\n}\n\nvoid RhsGlobal(int n, real h, real *fs, real *F, real p, real q, real alpha, real beta, int boundary){\n    real *hs = (real*) malloc(n*sizeof(real));\n\n    for (size_t i = 0; i < n; i++)\n    {\n        hs[i] = h;\n    }\n\n    RhsGlobal(n, hs, fs, F, p, q, alpha, beta, boundary);\n\n    free(hs);\n}\n\nvoid RhsGlobal(int n, real *hs, real *fs, real *F, real p, real q, real alpha, real beta, int boundary){\n    int ndofs = n + 1;\n\n    for (size_t i = 0; i < ndofs; i++)\n    {\n        F[i] = 0.0;\n    }\n\n    real Fe[2];\n    \n    for (size_t i = 0; i < n; i++)\n    {\n\n        RhsLocal(hs[i], fs[i], fs[i+1], Fe);\n\n        F[i]    += Fe[0];\n        F[i+1]  += Fe[1];\n\n    }\n\n    if(boundary == DIRICHLET || boundary == DIRICHLET_NEUMANN){\n        F[0] = p;\n        real w = sqrt(3)/3.0; real he = hs[0];\n        F[1] -= p*((he/2)*beta*(FuncForm(-w,0)*FuncForm(-w,1)) + (2/he)*alpha*(DFuncForm(-w,0)*DFuncForm(-w,1)));\n        F[1] -= p*((he/2)*beta*(FuncForm( w,0)*FuncForm( w,1)) + (2/he)*alpha*(DFuncForm( w,0)*DFuncForm( w,1)));\n        \n    }\n\n    if(boundary == DIRICHLET || boundary == NEUMANN_DIRICHLET){\n        real w = sqrt(3)/3.0; real he = hs[n-1];\n        F[ndofs - 1] = q;\n        F[ndofs-2] -= q*((he/2)*beta*(FuncForm(-w,0)*FuncForm(-w,1)) + (2/he)*alpha*(DFuncForm(-w,0)*DFuncForm(-w,1)));\n        F[ndofs-2] -= q*((he/2)*beta*(FuncForm( w,0)*FuncForm( w,1)) + (2/he)*alpha*(DFuncForm( w,0)*DFuncForm( w,1)));\n    }\n\n    if(boundary == NEUMANN || boundary == NEUMANN_DIRICHLET){\n        F[0] -= alpha*p;\n    }\n\n    if(boundary == NEUMANN || boundary == DIRICHLET_NEUMANN){\n        F[ndofs-1] += alpha*q;\n    }\n}\n\n\n\nextern \"C\"{\n\n    real * Fem1dTest(int n, int entrada){\n\n            real *x, *F, *fs, *sol;\n            real *K;\n            real alpha, beta, p, q;\n            int boundary;\n\n            int unknowns = n + 1;\n\n            real h = 1.0/n;\n\n            zero(unknowns, &x);\n            zero(unknowns, &F);\n            zero(unknowns, &fs);\n            zero(unknowns, &sol);\n            zero(unknowns*unknowns, &K);\n\n            x[0] = 0.0;\n            \n            for (size_t i = 1; i < unknowns; i++)\n            {\n                x[i] = x[i-1] + h;\n            }\n\n            /*\n            ######################################################################\n            # Selecao da entrada\n            ######################################################################\n            */\n\n            for (size_t i = 0; i < unknowns; i++)\n            {\n                switch (entrada)\n                {\n                    case 0:\n                        alpha = 1.0;\n                        beta = 1.0;\n                        fs[i] = 4*M_PI*M_PI*sin(2*M_PI*x[i]) + sin(2*M_PI*x[i]);\n                        sol[i] = sin(2*M_PI*x[i]);\n                        boundary = DIRICHLET;\n                        p = 0.0;\n                        q = 0.0;\n                        break;\n                    case 1:\n                        alpha = 1.0;\n                        beta = 0.0;\n                        fs[i] = 2*alpha;\n                        boundary = DIRICHLET;\n                        p = 0.0;\n                        q = 0.0;\n                        break;\n                    case 2:\n                        alpha = 1.0;\n                        beta = 0.5;\n                        boundary = DIRICHLET;\n                        fs[i] = 0.5*x[i];\n                        p = 0.0;\n                        q = 1.0;\n                        break;\n                    case 3:\n                        alpha = 0.0;\n                        beta = 1.0;\n                        boundary = DIRICHLET;\n                        fs[i] = beta*x[i]*(1-x[i]);\n                        p = 0.0;\n                        q = 0.0;\n                        break;\n                    case 4:\n                        alpha = 2.0;\n                        beta = 1.0;\n                        boundary = DIRICHLET;\n                        fs[i] = -7*exp(2*x[i]);\n                        p = 1.0;\n                        q = exp(2.0);\n                        break;\n                    case 5:\n                        alpha = 2.0;\n                        beta = 1.0;\n                        boundary = NEUMANN;\n                        fs[i] = -7*exp(2*x[i]);\n                        p = 2.0;\n                        q = 2*exp(2.0);\n                        break;\n                    case 6:\n                        alpha = 2.0;\n                        beta = 1.0;\n                        boundary = NEUMANN_DIRICHLET;\n                        fs[i] = -7*exp(2*x[i]);\n                        p = 2.0;\n                        q = exp(2.0);\n                        break;\n                    case 7:\n                        alpha = 2.0;\n                        beta = 1.0;\n                        boundary = DIRICHLET_NEUMANN;\n                        fs[i] = -7*exp(2*x[i]);\n                        p = 1.0;\n                        q = 2*exp(2.0);\n                        break;\n                    case 8:\n                        alpha = 1.0;\n                        beta = 1.0;\n                        boundary = NEUMANN;\n                        fs[i] = 4*M_PI*M_PI*sin(2*M_PI*x[i]) + sin(2*M_PI*x[i]);\n                        p =  2*M_PI;\n                        q =  2*M_PI;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            \n            /*\n            ######################################################################\n            # Criando Matriz Global\n            ######################################################################\n            */\n\n            GlobalMatrix(n, alpha, beta, K, boundary);\n\n            /*\n            ######################################################################\n            # Criando Lado Direito\n            ######################################################################\n            */\n            RhsGlobal(n, h, fs, F, p, q, alpha, beta, boundary);\n\n\n            /*\n            ######################################################################\n            # Solucao do Sistema Linear\n            ######################################################################\n            */            \n            real * calc;\n            zero(unknowns, &calc);\n            cg(unknowns, K, F, calc);\n\n            free(x);\n            free(F);\n            free(fs);\n            free(sol);\n            free(K);\n\n            return calc;\n    }\n\n}\n",
        "blame_info": {
            "mtsodf@gmail.com": [
                [
                    1,
                    311
                ]
            ]
        }
    },
    {
        "blob_id": "1232a46da9a5b85d3695ca1a7c3b93c5b37fc11d",
        "directory_id": "171b27ba265922de7836df0ac14db9ac1377153a",
        "path": "/test/doc/diff/stirling.cpp",
        "content_id": "875116731f3ae6bb89c2579c42e3222f850e5811",
        "detected_licenses": [
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "JPenuchot/eve",
        "snapshot_id": "30bb84af4bfb4763910fab96f117931343beb12b",
        "revision_id": "aeb09001cd6b7d288914635cb7bae66a98687972",
        "branch_name": "refs/heads/main",
        "visit_date": "2023-08-21 21:03:07",
        "revision_date": "2021-10-16 19:36:50",
        "committer_date": "2021-10-16 19:36:50",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 561,
        "extension": "cpp",
        "content": "#include <eve/function/diff/stirling.hpp>\n#include <eve/wide.hpp>\n#include <iostream>\n\nusing wide_ft = eve::wide <float, eve::fixed<4>>;\n\nint main()\n{\n  wide_ft pf = { 0.0f, 1.0f, -1.0f, -0.5f};\n\n  std::cout\n    << \"---- simd\" << '\\n'\n    << \"<- pf                   = \" << pf << '\\n'\n    << \"-> diff(stirling)(pf) = \" << eve::diff(eve::stirling)(pf) << '\\n';\n\n  float xf = 1.0f;\n\n  std::cout\n    << \"---- scalar\"  << '\\n'\n    << \"<- xf                   = \" << xf << '\\n'\n    << \"-> diff(stirling)(xf) = \" << eve::diff(eve::stirling)(xf) << '\\n'\n  return 0;\n}\n",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    23
                ]
            ]
        }
    },
    {
        "blob_id": "cf94e7e7f6a5aa06a4c6a7230f8e8a546b0206a4",
        "directory_id": "607829232b9ec8d6733fb67be85e8555d19e1ee0",
        "path": "/libs/core/include/fcppt/math/vector/ceil_div_signed.hpp",
        "content_id": "6ebdffb5f1f010dcdee214d5164fac81c3a66cd8",
        "detected_licenses": [
            "BSL-1.0"
        ],
        "license_type": "permissive",
        "repo_name": "cnsuhao/fcppt",
        "snapshot_id": "3b917196d5faf477d769b8f04e0001361a857776",
        "revision_id": "104c035118a04011c5fd9574cc78b2889550ea65",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-13 06:30:29",
        "revision_date": "2016-11-05 13:33:41",
        "committer_date": "2016-11-05 13:33:41",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1306,
        "extension": "hpp",
        "content": "//          Copyright Carl Philipp Reh 2009 - 2016.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\n\n#ifndef FCPPT_MATH_VECTOR_CEIL_DIV_SIGNED_HPP_INCLUDED\n#define FCPPT_MATH_VECTOR_CEIL_DIV_SIGNED_HPP_INCLUDED\n\n#include <fcppt/math/ceil_div_signed.hpp>\n#include <fcppt/math/map.hpp>\n#include <fcppt/math/size_type.hpp>\n#include <fcppt/math/vector/object_impl.hpp>\n#include <fcppt/math/vector/static.hpp>\n#include <fcppt/config/external_begin.hpp>\n#include <type_traits>\n#include <fcppt/config/external_end.hpp>\n\n\nnamespace fcppt\n{\nnamespace math\n{\nnamespace vector\n{\n\n/**\n\\brief Division rounded up for signed vectors\n\n\\ingroup fcpptmathvector\n*/\ntemplate<\n\ttypename T,\n\tfcppt::math::size_type N,\n\ttypename S\n>\nfcppt::math::vector::static_<\n\tT,\n\tN\n>\nceil_div_signed(\n\tfcppt::math::vector::object<\n\t\tT,\n\t\tN,\n\t\tS\n\t> const _vector,\n\tT const _factor\n)\n{\n\tstatic_assert(\n\t\tstd::is_signed<\n\t\t\tT\n\t\t>::value,\n\t\t\"T must be signed\"\n\t);\n\n\treturn\n\t\tfcppt::math::map<\n\t\t\tfcppt::math::vector::static_<\n\t\t\t\tT,\n\t\t\t\tN\n\t\t\t>\n\t\t>(\n\t\t\t_vector,\n\t\t\t[\n\t\t\t\t_factor\n\t\t\t](\n\t\t\t\tT const _value\n\t\t\t)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t\t\tfcppt::math::ceil_div_signed(\n\t\t\t\t\t\t_value,\n\t\t\t\t\t\t_factor\n\t\t\t\t\t);\n\t\t\t}\n\t\t);\n}\n\n}\n}\n}\n\n#endif\n",
        "blame_info": {
            "carlphilippreh@gmail.com": [
                [
                    1,
                    1
                ],
                [
                    12,
                    12
                ],
                [
                    14,
                    14
                ],
                [
                    27,
                    31
                ],
                [
                    34,
                    34
                ],
                [
                    37,
                    37
                ],
                [
                    39,
                    40
                ],
                [
                    59,
                    59
                ],
                [
                    61,
                    61
                ]
            ],
            "sefi@s-e-f-i.de": [
                [
                    2,
                    11
                ],
                [
                    13,
                    13
                ],
                [
                    15,
                    26
                ],
                [
                    32,
                    33
                ],
                [
                    35,
                    36
                ],
                [
                    38,
                    38
                ],
                [
                    41,
                    58
                ],
                [
                    60,
                    60
                ],
                [
                    62,
                    84
                ]
            ]
        }
    },
    {
        "blob_id": "a4107844dad660b1e38707bc33b03c52f16b4cbd",
        "directory_id": "61442c0297fef23453b7bc43ab5bbd6a52c95fa7",
        "path": "/grappletation/Source/Grappletation/Gem.cpp",
        "content_id": "44c2698bb81fe1bfc4a986a9d39c8944aae59d65",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "AshleyThew/GameProgramming",
        "snapshot_id": "c9cf634ef81dd7e1753b3ef45d56a6ee38b9a072",
        "revision_id": "22032cf7b141222d498c083527e81a854864e694",
        "branch_name": "refs/heads/main",
        "visit_date": "2023-08-23 15:51:59",
        "revision_date": "2021-10-25 10:01:57",
        "committer_date": "2021-10-25 10:01:57",
        "github_id": 420814528,
        "star_events_count": 1,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 778,
        "extension": "cpp",
        "content": "#include \"Gem.h\"\n#include \"Entity.h\"\n#include \"Renderer.h\"\n#include \"Sprite.h\"\n\nGem::Gem(int x, int y)\n{\n\tid.x = x;\n\tid.y = y;\n}\n\nGem::~Gem()\n{\n}\n\nbool \nGem::Initialise(Renderer& renderer, const char* gemType, float scale)\n{\n\tm_pSprite = renderer.CreateSprite(gemType);\n\tm_pSprite->SetScale(scale);\n\tm_position.x = (scale * 8) + (id.x * scale * 16);\n\tm_position.y = (scale * 8) + (id.y * scale * 16);\n\n\tReset();\n\treturn false;\n}\n\nvoid \nGem::Process(float deltaTime)\n{\n\tEntity::Process(deltaTime);\n}\n\nvoid\nGem::Draw(Renderer& renderer)\n{\n\tEntity::Draw(renderer);\n}\n\nbool\nGem::GetCollected()\n{\n\treturn collected;\n}\n\nvoid\nGem::SetCollected()\n{\n\tcollected = true;\n\tSetDead(true);\n}\n\nvoid\nGem::Reset()\n{\n\tcollected = false;\n\tSetDead(false);\n}\n\n\nVector2 \nGem::GetID()\n{\n\treturn id;\n}\n",
        "blame_info": {
            "ashl.e.thew@gmail.com": [
                [
                    1,
                    65
                ]
            ]
        }
    },
    {
        "blob_id": "a702a5d40a3a672624e691115d63b4a004c979d0",
        "directory_id": "7aa189c718f8a63c256685a435d027ace3833f6b",
        "path": "/include/ogonek/error.h++",
        "content_id": "ca7ff1f2bc1d6ac11fcbdaacee61fbdef1c7430d",
        "detected_licenses": [
            "CC0-1.0"
        ],
        "license_type": "permissive",
        "repo_name": "rmartinho/ogonek",
        "snapshot_id": "d5523145108de1255298a17c1c25065beb19b82c",
        "revision_id": "0042f30c6c674effd21d379c53658c88054c58b9",
        "branch_name": "refs/heads/devel",
        "visit_date": "2020-05-21 15:17:39",
        "revision_date": "2019-09-29 10:58:31",
        "committer_date": "2019-09-29 10:58:31",
        "github_id": 8255019,
        "star_events_count": 16,
        "fork_events_count": 3,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 4549,
        "extension": "",
        "content": "// Ogonek\n//\n// Written in 2017 by Martinho Fernandes <ogonek@rmf.io>\n//\n// To the extent possible under law, the author(s) have dedicated all copyright and related\n// and neighboring rights to this software to the public domain worldwide. This software is\n// distributed without any warranty.\n//\n// You should have received a copy of the CC0 Public Domain Dedication along with this software.\n// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n\n/**\n * Error handling\n * ==============\n */\n\n#ifndef OGONEK_ERROR_HPP\n#define OGONEK_ERROR_HPP\n\n#include <ogonek/error_fwd.h++>\n\n#include <ogonek/concepts.h++>\n#include <ogonek/types.h++>\n#include <ogonek/encoding.h++>\n\n#include <range/v3/range_concepts.hpp>\n#include <range/v3/range_traits.hpp>\n\n#include <stdexcept>\n\nnamespace ogonek {\n\n    /**\n     * .. class:: unicode_error\n     *\n     *     The base class for all Unicode-related errors.\n     */\n    struct unicode_error\n    : virtual std::exception {\n        char const* what() const noexcept override {\n            return u8\"Unicode error\";\n        }\n    };\n\n    /**\n     * .. class:: template <EncodingForm Encoding>\\\n     *            encode_error : virtual unicode_error\n     *\n     *     :thrown: when an error occurs during an encoding operation.\n     */\n    template <typename Encoding>\n    struct encode_error\n    : virtual unicode_error {\n        CONCEPT_ASSERT(EncodingForm<Encoding>());\n\n        char const* what() const noexcept override {\n            return u8\"encoding failed \";\n        }\n    };\n\n    /**\n     * .. class:: template <EncodingForm Encoding>\\\n     *            decode_error : virtual unicode_error\n     *\n     *     :thrown: when an error occurs during a decoding operation.\n     */\n    template <typename Encoding>\n    struct decode_error\n    : virtual unicode_error {\n        CONCEPT_ASSERT(EncodingForm<Encoding>());\n\n        char const* what() const noexcept override {\n            return u8\"decoding failed\";\n        }\n    };\n\n    /**\n     * .. var:: auto assume_valid\n     *\n     *     A tag used to request that encoding/decoding functions assume the\n     *     input has been validated before.\n     *\n     *     .. warning::\n     *\n     *         Using this tag with input that isn't actually valid yields\n     *         undefined behavior.\n     */\n    struct assume_valid_t {} constexpr assume_valid {};\n\n    /**\n     * .. var:: auto discard_errors\n     *\n     *     An error handler for encoding/decoding functions that simply\n     *     discards the portions of the input that have errors.\n     */\n    struct discard_errors_t {\n        template <typename E>\n        optional<code_point> operator()(E) const {\n            return {};\n        }\n    } constexpr discard_errors {};\n\n    CONCEPT_ASSERT(EncodeErrorHandler<discard_errors_t, archetypes::EncodingForm>());\n    CONCEPT_ASSERT(DecodeErrorHandler<discard_errors_t, archetypes::EncodingForm>());\n\n    /**\n     * .. var:: auto replace_errors\n     *\n     *     An error handler for encoding/decoding functions that replaces\n     *     portions of the input that have errors with a replacement character.\n     *     When decoding, this is |u-fffd|, but when encoding and the target\n     *     doesn't support it, some encoding-specific character is used\n     *     instead.\n     */\n    struct replace_errors_t {\n        template <typename Encoding,\n                  CONCEPT_REQUIRES_(EncodingForm<Encoding>())>\n        optional<code_point> operator()(encode_error<Encoding>) const {\n            return replacement_character_v<Encoding>;\n        }\n        template <typename Encoding,\n                  CONCEPT_REQUIRES_(EncodingForm<Encoding>())>\n        optional<code_point> operator()(decode_error<Encoding>) const {\n            return { U'\\uFFFD' };\n        }\n    } constexpr replace_errors {};\n\n    CONCEPT_ASSERT(EncodeErrorHandler<replace_errors_t, archetypes::EncodingForm>());\n    CONCEPT_ASSERT(DecodeErrorHandler<replace_errors_t, archetypes::EncodingForm>());\n\n    /**\n     * .. var:: auto throw_error\n     *\n     *     An error handler for encoding/decoding functions that throws when an\n     *     error is found in the input.\n     */\n    struct throw_error_t {\n        template <typename E>\n        optional<code_point> operator()(E e) const {\n            throw e;\n        }\n    } constexpr throw_error {};\n\n    CONCEPT_ASSERT(EncodeErrorHandler<throw_error_t, archetypes::EncodingForm>());\n    CONCEPT_ASSERT(DecodeErrorHandler<throw_error_t, archetypes::EncodingForm>());\n} // namespace ogonek\n\n#endif // OGONEK_ERROR_HPP\n",
        "blame_info": {
            "rmf@rmf.io": [
                [
                    1,
                    148
                ]
            ]
        }
    },
    {
        "blob_id": "fa606684822edaeb65a3facbab4e69b8044c96ef",
        "directory_id": "6aeccfb60568a360d2d143e0271f0def40747d73",
        "path": "/sandbox/SOC/2011/simd/boost/simd/toolbox/constant/include/constants/minexponent.hpp",
        "content_id": "0fd6c857f2cef5aa7fcc1f22aca4daf4a5f7a9c3",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "ttyang/sandbox",
        "snapshot_id": "1066b324a13813cb1113beca75cdaf518e952276",
        "revision_id": "e1d6fde18ced644bb63e231829b2fe0664e51fac",
        "branch_name": "refs/heads/trunk",
        "visit_date": "2021-01-19 17:17:47",
        "revision_date": "2013-06-07 14:19:55",
        "committer_date": "2013-06-07 14:19:55",
        "github_id": 13488698,
        "star_events_count": 1,
        "fork_events_count": 3,
        "gha_license_id": null,
        "gha_event_created_at": "2023-03-20 11:52:19",
        "gha_created_at": "2013-10-11 03:08:51",
        "gha_language": "C++",
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 232,
        "extension": "hpp",
        "content": "#ifndef BOOST_SIMD_TOOLBOX_CONSTANT_INCLUDE_CONSTANTS_MINEXPONENT_HPP_INCLUDED\n#define BOOST_SIMD_TOOLBOX_CONSTANT_INCLUDE_CONSTANTS_MINEXPONENT_HPP_INCLUDED\n\n#include <boost/simd/toolbox/constant/constants/minexponent.hpp>\n\n#endif\n",
        "blame_info": {
            "loufoque@gmail.com": [
                [
                    1,
                    6
                ]
            ]
        }
    },
    {
        "blob_id": "4ff557683a174bc39aea59e06a19b563d55927d6",
        "directory_id": "cde943952b79d67f4972d180d20b97fc823db548",
        "path": "/preprocesser/preprocesser/self2.hpp",
        "content_id": "0892b2563bae695f02d2254829e81a6cb84c630e",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "yourgracee/preprocesser",
        "snapshot_id": "e66a0b0c9680442717652185e9ed2dc5172f7771",
        "revision_id": "349453d4092ffe7927b0c1067d3cefc8bf2bdfff",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-04-09 10:52:16",
        "revision_date": "2018-12-04 02:46:03",
        "committer_date": "2018-12-04 02:46:03",
        "github_id": 160285495,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 10701,
        "extension": "hpp",
        "content": "#ifdef LIMIT_2\r\n    #include \"tuple.hpp\"\r\n    #define START_2 TUPLE(0, LIMIT_2)\r\n    #define FINISH_2 TUPLE(1, LIMIT_2)\r\n    #undef DEPTH\r\n    #define DEPTH 2\r\n\r\n    #    if START_2 <= 0 && FINISH_2 >= 0\r\n    #        define ITERATION_2 0\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 1 && FINISH_2 >= 1\r\n    #        define ITERATION_2 1\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 2 && FINISH_2 >= 2\r\n    #        define ITERATION_2 2\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 3 && FINISH_2 >= 3\r\n    #        define ITERATION_2 3\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 4 && FINISH_2 >= 4\r\n    #        define ITERATION_2 4\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 5 && FINISH_2 >= 5\r\n    #        define ITERATION_2 5\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 6 && FINISH_2 >= 6\r\n    #        define ITERATION_2 6\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 7 && FINISH_2 >= 7\r\n    #        define ITERATION_2 7\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 8 && FINISH_2 >= 8\r\n    #        define ITERATION_2 8\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 9 && FINISH_2 >= 9\r\n    #        define ITERATION_2 9\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 10 && FINISH_2 >= 10\r\n    #        define ITERATION_2 10\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 11 && FINISH_2 >= 11\r\n    #        define ITERATION_2 11\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 12 && FINISH_2 >= 12\r\n    #        define ITERATION_2 12\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 13 && FINISH_2 >= 13\r\n    #        define ITERATION_2 13\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 14 && FINISH_2 >= 14\r\n    #        define ITERATION_2 14\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 15 && FINISH_2 >= 15\r\n    #        define ITERATION_2 15\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 16 && FINISH_2 >= 16\r\n    #        define ITERATION_2 16\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 17 && FINISH_2 >= 17\r\n    #        define ITERATION_2 17\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 18 && FINISH_2 >= 18\r\n    #        define ITERATION_2 18\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 19 && FINISH_2 >= 19\r\n    #        define ITERATION_2 19\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 20 && FINISH_2 >= 20\r\n    #        define ITERATION_2 20\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 21 && FINISH_2 >= 21\r\n    #        define ITERATION_2 21\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 22 && FINISH_2 >= 22\r\n    #        define ITERATION_2 22\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 23 && FINISH_2 >= 23\r\n    #        define ITERATION_2 23\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 24 && FINISH_2 >= 24\r\n    #        define ITERATION_2 24\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 25 && FINISH_2 >= 25\r\n    #        define ITERATION_2 25\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 26 && FINISH_2 >= 26\r\n    #        define ITERATION_2 26\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 27 && FINISH_2 >= 27\r\n    #        define ITERATION_2 27\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 28 && FINISH_2 >= 28\r\n    #        define ITERATION_2 28\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 29 && FINISH_2 >= 29\r\n    #        define ITERATION_2 29\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 30 && FINISH_2 >= 30\r\n    #        define ITERATION_2 30\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 31 && FINISH_2 >= 31\r\n    #        define ITERATION_2 31\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 32 && FINISH_2 >= 32\r\n    #        define ITERATION_2 32\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 33 && FINISH_2 >= 33\r\n    #        define ITERATION_2 33\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 34 && FINISH_2 >= 34\r\n    #        define ITERATION_2 34\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 35 && FINISH_2 >= 35\r\n    #        define ITERATION_2 35\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 36 && FINISH_2 >= 36\r\n    #        define ITERATION_2 36\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 37 && FINISH_2 >= 37\r\n    #        define ITERATION_2 37\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 38 && FINISH_2 >= 38\r\n    #        define ITERATION_2 38\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 39 && FINISH_2 >= 39\r\n    #        define ITERATION_2 39\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 40 && FINISH_2 >= 40\r\n    #        define ITERATION_2 40\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 41 && FINISH_2 >= 41\r\n    #        define ITERATION_2 41\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 42 && FINISH_2 >= 42\r\n    #        define ITERATION_2 42\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 43 && FINISH_2 >= 43\r\n    #        define ITERATION_2 43\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 44 && FINISH_2 >= 44\r\n    #        define ITERATION_2 44\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 45 && FINISH_2 >= 45\r\n    #        define ITERATION_2 45\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 46 && FINISH_2 >= 46\r\n    #        define ITERATION_2 46\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 47 && FINISH_2 >= 47\r\n    #        define ITERATION_2 47\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 48 && FINISH_2 >= 48\r\n    #        define ITERATION_2 48\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 49 && FINISH_2 >= 49\r\n    #        define ITERATION_2 49\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 50 && FINISH_2 >= 50\r\n    #        define ITERATION_2 50\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 51 && FINISH_2 >= 51\r\n    #        define ITERATION_2 51\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 52 && FINISH_2 >= 52\r\n    #        define ITERATION_2 52\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 53 && FINISH_2 >= 53\r\n    #        define ITERATION_2 53\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 54 && FINISH_2 >= 54\r\n    #        define ITERATION_2 54\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 55 && FINISH_2 >= 55\r\n    #        define ITERATION_2 55\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 56 && FINISH_2 >= 56\r\n    #        define ITERATION_2 56\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 57 && FINISH_2 >= 57\r\n    #        define ITERATION_2 57\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 58 && FINISH_2 >= 58\r\n    #        define ITERATION_2 58\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 59 && FINISH_2 >= 59\r\n    #        define ITERATION_2 59\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 60 && FINISH_2 >= 60\r\n    #        define ITERATION_2 60\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 61 && FINISH_2 >= 61\r\n    #        define ITERATION_2 61\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 62 && FINISH_2 >= 62\r\n    #        define ITERATION_2 62\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 63 && FINISH_2 >= 63\r\n    #        define ITERATION_2 63\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n    #    if START_2 <= 64 && FINISH_2 >= 64\r\n    #        define ITERATION_2 64\r\n    #        include FILENAME_2\r\n    #        undef ITERATION_2\r\n    #    endif\r\n\r\n#undef DEPTH\r\n#define DEPTH 1\r\n#endif",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    336
                ]
            ]
        }
    },
    {
        "blob_id": "b13420aa4004b14e74a53305e3368b5f4ee9dc92",
        "directory_id": "72d1b579366934a24af7aff13ebf9b8cdaf58d8c",
        "path": "/ReadImages.cpp",
        "content_id": "a8f247f3d5b7fd89ce0c49662b42f6ef479207a1",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "hgpvision/Keypoint-Matcher",
        "snapshot_id": "48496a59dbaffefe6e89e8e14efabdb9883848bb",
        "revision_id": "bf265aba62b325fab300aba2bad357ff7321ba4a",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-15 15:05:50",
        "revision_date": "2017-08-08 14:45:53",
        "committer_date": "2017-08-08 14:45:53",
        "github_id": 99702359,
        "star_events_count": 0,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "GB18030",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1454,
        "extension": "cpp",
        "content": "/*\n* \u6587\u4ef6\u540d\u79f0\uff1aReadImages.cpp\n* \u6458 \u8981\uff1a\u8bfb\u53d6\u56fe\u7247\u7c7b\uff0c\u56fe\u7247\u5e8f\u5217\u653e\u5165\u5230\u4e00\u4e2a\u6587\u4ef6\u5939\u4e2d\uff0c\u5982\"C:\\\\imgFile\"\uff0c\u6309\u4e00\u5b9a\u683c\u5f0f\u547d\u540d\uff0c\u6bd4\u5982\"0001.jpg\",\"00010.jpg\",\"1.jpg\"\n* \u4f7f\u7528\u5b9e\u4f8b\uff1a\n* \u5305\u542b\u5934\u6587\u4ef6\uff1a\t\t\t#include \"ReadImages.h\"\n* \u5148\u58f0\u660e\u8981\u7ed9\u8bfb\u5165\u56fe\u7247\u7c7b\uff1aReadImages imageReader(\"C:\\\\imgFile\", \"\", \".jpg\");\n* \u8bfb\u5165\u56fe\u7247\uff1a\t\t\tMat prev = imageReader.loadImage(1,0); //\u5c06\u8bfb\u5165\"1.jpg\"\u56fe\u7247\uff0c\u7070\u5ea6\u683c\u5f0f\n* 2016.05.23\n*/\n\n#include \"ReadImages.h\"\n#pragma once\n\nReadImages::ReadImages(std::string basepath, const std::string imagename, const std::string suffix)\n{\n\t//\u5c06\u8def\u5f84\u4e2d\u7684\u6587\u4ef6\u5939\u5206\u9694\u7b26\u7edf\u4e00\u4e3a'/'\uff08\u53ef\u4ee5\u4e0d\u9700\u8981\u8fd9\u4e2afor\u5faa\u73af\uff0c\u4f1a\u81ea\u52a8\u7edf\u4e00\uff0c\u8be5\u8bed\u53e5\u4f7f\u7528\u7684\u547d\u4ee4\u53c2\u8003C++ Primer\uff09\n\tfor (auto &c : basepath)\n\t{\n\t\tif (c == '\\\\')\n\t\t{\n\t\t\tc = '/';\n\t\t}\n\t}\n\n\t_imgSource._basepath = basepath + \"/\";\t//\u8fd9\u91cc\u91c7\u7528'/'\uff0c\u800c\u4e0d\u662f'\\\\'\n\t_imgSource._imagename = imagename;\t\t//\u56fe\u7247\u540d\uff08\u4e0d\u542b\u7f16\u53f7\uff09\n\t_imgSource._suffix = suffix;\t\t\t\t//\u56fe\u50cf\u6269\u5c55\u540d\n\n}\n\n//\u8bfb\u5165\u5355\u5f20\u56fe\u7247\n//\u8f93\u5165\uff1aimgId\uff0c\u4e00\u822c\u8981\u8bfb\u5165\u5e8f\u5217\u56fe\u7247\uff0c\u56fe\u7247\u90fd\u6709\u4e2a\u7f16\u53f7\ncv::Mat ReadImages::loadImage(int imgId, int imgType)\n{\t\n\t//\u5c06\u56fe\u7247\u7f16\u53f7\u8f6c\u597d\u5b57\u7b26\u4e32\n\tstd::stringstream ss;\n\tstd::string imgNum;\n\tss << imgId;\n\tss >> imgNum;\n\n\t//\u5f97\u5230\u56fe\u7247\u7684\u5b8c\u6574\u7edd\u5bf9\u8def\u5f84\n\tstd::string path = _imgSource._basepath + _imgSource._imagename + imgNum + _imgSource._suffix;\n\t\n\tcv::Mat img = cv::imread(path,imgType);\n\n\treturn img;\n}",
        "blame_info": {
            "keepsmiling.hgp@outlook.com": [
                [
                    1,
                    47
                ]
            ]
        }
    },
    {
        "blob_id": "b7c78a511904d321aa74ab25ce20a44c3a3f0a0e",
        "directory_id": "d51d72f1b6e834d89c8551bb07487bed84cdaa31",
        "path": "/src/output/osg/customCode/osg/AnimationPath_pmoc.cpp",
        "content_id": "dc66ae9496a4b899d13c9038f85bec5d8cc50019",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "wangfeilong321/osg4noob",
        "snapshot_id": "221204aa15efa18f1f049548ad076ef27371ecad",
        "revision_id": "99a15c3fd2523c4bd537fa3afb0b47e15c8f335a",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-12 20:00:43",
        "revision_date": "2015-11-06 15:37:01",
        "committer_date": "2015-11-06 15:37:01",
        "github_id": 48840543,
        "star_events_count": 0,
        "fork_events_count": 1,
        "gha_license_id": null,
        "gha_event_created_at": "2015-12-31 07:56:31",
        "gha_created_at": "2015-12-31 07:56:31",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1778,
        "extension": "cpp",
        "content": "#include <osg/AnimationPath>\n//includes\n#include <MetaQQuickLibraryRegistry.h>\n#include <customCode/osg/AnimationPath_pmoc.hpp>\nusing namespace pmoc;\nosg::QMLAnimationPath::QMLAnimationPath(pmoc::Instance *i,QObject* parent):QReflect_AnimationPath(i,parent){\n//custom initializations\n}\nQQuickItem* osg::QMLAnimationPath::connect2View(QQuickItem*i){\n\tthis->_view=QReflect_AnimationPath::connect2View(i);\n///connect this's signals/slot to its qml component////////////////////////////////////////////////////////////////\n\t///CustomiZE here\n\n\n\nreturn this->_view;\n}\nvoid  osg::QMLAnimationPath::updateModel(){\n\t  QReflect_AnimationPath::updateModel();\n///update this according to state of _model when it has been changed via pmoc/////////////////////////////////////////////\n\t///CustomiZE here\n\n\n}\n#ifndef AUTOMOCCPP\n#define AUTOMOCCPP 1\n#include \"moc_AnimationPath_pmoc.cpp\"\n#endif\n#include <MetaQQuickLibraryRegistry.h>\n#include <customCode/osg/AnimationPath_pmoc.hpp>\nusing namespace pmoc;\nosg::QMLAnimationPathCallback::QMLAnimationPathCallback(pmoc::Instance *i,QObject* parent):QReflect_AnimationPathCallback(i,parent){\n//custom initializations\n}\nQQuickItem* osg::QMLAnimationPathCallback::connect2View(QQuickItem*i){\n\tthis->_view=QReflect_AnimationPathCallback::connect2View(i);\n///connect this's signals/slot to its qml component////////////////////////////////////////////////////////////////\n\t///CustomiZE here\n\n\n\nreturn this->_view;\n}\nvoid  osg::QMLAnimationPathCallback::updateModel(){\n\t  QReflect_AnimationPathCallback::updateModel();\n///update this according to state of _model when it has been changed via pmoc/////////////////////////////////////////////\n\t///CustomiZE here\n\n\n}\n#ifndef AUTOMOCCPP\n#define AUTOMOCCPP 1\n#include \"moc_AnimationPath_pmoc.cpp\"\n#endif\n\n\n",
        "blame_info": {
            "mp3butcher@gmail.com": [
                [
                    1,
                    56
                ]
            ]
        }
    },
    {
        "blob_id": "e701e032706c6d0b6712cbf46f97a1491037c069",
        "directory_id": "509ed385d3faa95ed92957f0f691fc3fe1d6816a",
        "path": "/src/Workers/Worker.h",
        "content_id": "db1536697c5f967497dfa8fe487e786329ac19ec",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "xrenoder/Node-InfrastructureTorrent",
        "snapshot_id": "d6540c725cb9239bcf421a7891e7ebbeb6505701",
        "revision_id": "21c3eb739d0b41cb6858d747cd108708bbfdb73d",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-08-29 01:02:15",
        "revision_date": "2021-09-20 10:03:30",
        "committer_date": "2021-09-20 10:03:30",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 504,
        "extension": "h",
        "content": "#ifndef WORKER_H_\n#define WORKER_H_\n\n#include <memory>\n#include <optional>\n\n#include \"OopUtils.h\"\n\nnamespace torrent_node_lib {\n\nstruct BlockInfo;\n    \nclass Worker: public common::no_copyable, common::no_moveable{\npublic:\n    \n    virtual void start() = 0;\n    \n    virtual void process(std::shared_ptr<BlockInfo> bi, std::shared_ptr<std::string> dump) = 0;\n    \n    virtual std::optional<size_t> getInitBlockNumber() const = 0;\n    \n    virtual ~Worker() = default;\n    \n};\n    \n}\n\n#endif // WORKER_H_\n",
        "blame_info": {
            "sv_91@inbox.ru": [
                [
                    1,
                    28
                ]
            ]
        }
    },
    {
        "blob_id": "cb50f617109e0944e114883af3fc3af8be9a6b7e",
        "directory_id": "9030ce2789a58888904d0c50c21591632eddffd7",
        "path": "/SDK/ARKSurvivalEvolved_Buff_PreventDismount_functions.cpp",
        "content_id": "7e18c4f1010b3ae0b9f98e0ea4d779d40e1340ba",
        "detected_licenses": [
            "MIT"
        ],
        "license_type": "permissive",
        "repo_name": "2bite/ARK-SDK",
        "snapshot_id": "8ce93f504b2e3bd4f8e7ced184980b13f127b7bf",
        "revision_id": "ce1f4906ccf82ed38518558c0163c4f92f5f7b14",
        "branch_name": "refs/heads/master",
        "visit_date": "2022-09-19 06:28:20",
        "revision_date": "2022-09-03 17:21:00",
        "committer_date": "2022-09-03 17:21:00",
        "github_id": 232411353,
        "star_events_count": 14,
        "fork_events_count": 5,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1490,
        "extension": "cpp",
        "content": "// ARKSurvivalEvolved (332.8) SDK\n\n#ifdef _MSC_VER\n\t#pragma pack(push, 0x8)\n#endif\n\n#include \"ARKSurvivalEvolved_Buff_PreventDismount_parameters.hpp\"\n\nnamespace sdk\n{\n//---------------------------------------------------------------------------\n//Functions\n//---------------------------------------------------------------------------\n\n// Function Buff_PreventDismount.Buff_PreventDismount_C.UserConstructionScript\n// ()\n\nvoid ABuff_PreventDismount_C::UserConstructionScript()\n{\n\tstatic auto fn = UObject::FindObject<UFunction>(\"Function Buff_PreventDismount.Buff_PreventDismount_C.UserConstructionScript\");\n\n\tABuff_PreventDismount_C_UserConstructionScript_Params params;\n\n\tauto flags = fn->FunctionFlags;\n\n\tUObject::ProcessEvent(fn, &params);\n\n\tfn->FunctionFlags = flags;\n}\n\n\n// Function Buff_PreventDismount.Buff_PreventDismount_C.ExecuteUbergraph_Buff_PreventDismount\n// ()\n// Parameters:\n// int                            EntryPoint                     (Parm, ZeroConstructor, IsPlainOldData)\n\nvoid ABuff_PreventDismount_C::ExecuteUbergraph_Buff_PreventDismount(int EntryPoint)\n{\n\tstatic auto fn = UObject::FindObject<UFunction>(\"Function Buff_PreventDismount.Buff_PreventDismount_C.ExecuteUbergraph_Buff_PreventDismount\");\n\n\tABuff_PreventDismount_C_ExecuteUbergraph_Buff_PreventDismount_Params params;\n\tparams.EntryPoint = EntryPoint;\n\n\tauto flags = fn->FunctionFlags;\n\n\tUObject::ProcessEvent(fn, &params);\n\n\tfn->FunctionFlags = flags;\n}\n\n\n}\n\n#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n",
        "blame_info": {
            "sergey.2bite@gmail.com": [
                [
                    1,
                    56
                ]
            ]
        }
    },
    {
        "blob_id": "bcee12c3aa60f8c1d8f0802c1bfdfe7600a1e3ef",
        "directory_id": "067b197860f7712e3f92564d0f8d88b0cf34f9d7",
        "path": "/ext/hera/wasserstein/include/dnn/parallel/tbb.h",
        "content_id": "64c59e0ee985223027151daa201d626258eb299b",
        "detected_licenses": [
            "BSD-3-Clause",
            "LicenseRef-scancode-unknown-license-reference"
        ],
        "license_type": "permissive",
        "repo_name": "tgebhart/dionysus_tensorflow",
        "snapshot_id": "be8757369beb4997b12246c5c7d3cbdbb2fd84bb",
        "revision_id": "344769bb6d5446c8fd43462b1dfd6a08d35631a8",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-09-28 10:03:56",
        "revision_date": "2018-11-16 17:15:34",
        "committer_date": "2018-11-16 17:15:34",
        "github_id": 112226756,
        "star_events_count": 2,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 7126,
        "extension": "h",
        "content": "#ifndef PARALLEL_H\n#define PARALLEL_H\n\n//#include <iostream>\n#include <vector>\n\n#include <boost/range.hpp>\n#include <boost/bind.hpp>\n#include <boost/foreach.hpp>\n\n#ifdef TBB\n\n#include <tbb/tbb.h>\n#include <tbb/concurrent_hash_map.h>\n#include <tbb/scalable_allocator.h>\n\n#include <boost/serialization/split_free.hpp>\n#include <boost/serialization/collections_load_imp.hpp>\n#include <boost/serialization/collections_save_imp.hpp>\n\nnamespace dnn\n{\n    using tbb::mutex;\n    using tbb::task_scheduler_init;\n    using tbb::task_group;\n    using tbb::task;\n\n    template<class T>\n    struct vector\n    {\n        typedef         tbb::concurrent_vector<T>               type;\n    };\n\n    template<class T>\n    struct atomic\n    {\n        typedef         tbb::atomic<T>                          type;\n        static T        compare_and_swap(type& v, T n, T o)     { return v.compare_and_swap(n,o); }\n    };\n\n    template<class Iterator, class F>\n    void                do_foreach(Iterator begin, Iterator end, const F& f)            { tbb::parallel_do(begin, end, f); }\n\n    template<class Range, class F>\n    void                for_each_range_(const Range& r, const F& f)\n    {\n        for (typename Range::iterator cur = r.begin(); cur != r.end(); ++cur)\n            f(*cur);\n    }\n\n    template<class F>\n    void                for_each_range(size_t from, size_t to, const F& f)\n    {\n        //static tbb::affinity_partitioner ap;\n        //tbb::parallel_for(c.range(), boost::bind(&for_each_range_<typename Container::range_type, F>, _1, f), ap);\n        tbb::parallel_for(from, to, f);\n    }\n\n    template<class Container, class F>\n    void                for_each_range(const Container& c, const F& f)\n    {\n        //static tbb::affinity_partitioner ap;\n        //tbb::parallel_for(c.range(), boost::bind(&for_each_range_<typename Container::range_type, F>, _1, f), ap);\n        tbb::parallel_for(c.range(), boost::bind(&for_each_range_<typename Container::const_range_type, F>, _1, f));\n    }\n\n    template<class Container, class F>\n    void                for_each_range(Container& c, const F& f)\n    {\n        //static tbb::affinity_partitioner ap;\n        //tbb::parallel_for(c.range(), boost::bind(&for_each_range_<typename Container::range_type, F>, _1, f), ap);\n        tbb::parallel_for(c.range(), boost::bind(&for_each_range_<typename Container::range_type, F>, _1, f));\n    }\n\n    template<class ID, class NodePointer, class IDTraits, class Allocator>\n    struct map_traits\n    {\n        typedef         tbb::concurrent_hash_map<ID, NodePointer, IDTraits, Allocator>              type;\n        typedef         typename type::range_type                                                   range;\n    };\n\n    struct progress_timer\n    {\n                        progress_timer(): start(tbb::tick_count::now())                 {}\n                        ~progress_timer()\n                        { std::cout << (tbb::tick_count::now() - start).seconds() << \" s\" << std::endl; }\n\n        tbb::tick_count start;\n    };\n}\n\n// Serialization for tbb::concurrent_vector<...>\nnamespace boost\n{\n    namespace serialization\n    {\n        template<class Archive, class T, class A>\n        void save(Archive& ar, const tbb::concurrent_vector<T,A>& v, const unsigned int file_version)\n        { stl::save_collection(ar, v); }\n\n        template<class Archive, class T, class A>\n        void load(Archive& ar, tbb::concurrent_vector<T,A>& v, const unsigned int file_version)\n        {\n            stl::load_collection<Archive,\n                                 tbb::concurrent_vector<T,A>,\n                                 stl::archive_input_seq< Archive, tbb::concurrent_vector<T,A> >,\n                                 stl::reserve_imp< tbb::concurrent_vector<T,A> >\n                                >(ar, v);\n        }\n\n        template<class Archive, class T, class A>\n        void serialize(Archive& ar, tbb::concurrent_vector<T,A>& v, const unsigned int file_version)\n        { split_free(ar, v, file_version); }\n\n        template<class Archive, class T>\n        void save(Archive& ar, const tbb::atomic<T>& v, const unsigned int file_version)\n        { T v_ = v; ar << v_; }\n\n        template<class Archive, class T>\n        void load(Archive& ar, tbb::atomic<T>& v, const unsigned int file_version)\n        { T v_; ar >> v_; v = v_; }\n\n        template<class Archive, class T>\n        void serialize(Archive& ar, tbb::atomic<T>& v, const unsigned int file_version)\n        { split_free(ar, v, file_version); }\n    }\n}\n\n#else\n\n#include <algorithm>\n#include <map>\n#include <boost/progress.hpp>\n\nnamespace dnn\n{\n    template<class T>\n    struct vector\n    {\n        typedef         ::std::vector<T>                        type;\n    };\n\n    template<class T>\n    struct atomic\n    {\n        typedef         T                                       type;\n        static T        compare_and_swap(type& v, T n, T o)     { if (v != o) return v; v = n; return o; }\n    };\n\n    template<class Iterator, class F>\n    void                do_foreach(Iterator begin, Iterator end, const F& f)    { std::for_each(begin, end, f); }\n\n    template<class F>\n    void                for_each_range(size_t from, size_t to, const F& f)\n    {\n        for (size_t i = from; i < to; ++i)\n            f(i);\n    }\n\n    template<class Container, class F>\n    void                for_each_range(Container& c, const F& f)\n    {\n        BOOST_FOREACH(const typename Container::value_type& i, c)\n            f(i);\n    }\n\n    template<class Container, class F>\n    void                for_each_range(const Container& c, const F& f)\n    {\n        BOOST_FOREACH(const typename Container::value_type& i, c)\n            f(i);\n    }\n\n    struct mutex\n    {\n        struct scoped_lock\n        {\n                        scoped_lock()                   {}\n                        scoped_lock(mutex& )            {}\n            void        acquire(mutex& ) const          {}\n            void        release() const                 {}\n        };\n    };\n\n    struct task_scheduler_init\n    {\n                        task_scheduler_init(unsigned)   {}\n        void            initialize(unsigned)            {}\n        static const unsigned automatic = 0;\n        static const unsigned deferred  = 0;\n    };\n\n    struct task_group\n    {\n        template<class Functor>\n        void    run(const Functor& f) const             { f(); }\n        void    wait() const                            {}\n    };\n\n    template<class ID, class NodePointer, class IDTraits, class Allocator>\n    struct map_traits\n    {\n        typedef         std::map<ID, NodePointer,\n                                 typename IDTraits::Comparison,\n                                 Allocator>                                             type;\n        typedef         type                                                            range;\n    };\n\n    using boost::progress_timer;\n}\n\n#endif // TBB\n\nnamespace dnn\n{\n    template<class Range, class F>\n    void                do_foreach(const Range& range, const F& f)                      { do_foreach(boost::begin(range), boost::end(range), f); }\n}\n\n#endif\n",
        "blame_info": {
            "gebharttom8@gmail.com": [
                [
                    1,
                    220
                ]
            ]
        }
    },
    {
        "blob_id": "e583e7116773107273d5fb8024b730ef48f23333",
        "directory_id": "88ae8695987ada722184307301e221e1ba3cc2fa",
        "path": "/third_party/pdfium/xfa/fxfa/parser/cxfa_solid.cpp",
        "content_id": "da8de3f6aca0fae9e6ba41523e382edcb9d6be21",
        "detected_licenses": [
            "BSD-3-Clause",
            "Apache-2.0",
            "LGPL-2.0-or-later",
            "MIT",
            "GPL-1.0-or-later"
        ],
        "license_type": "permissive",
        "repo_name": "iridium-browser/iridium-browser",
        "snapshot_id": "71d9c5ff76e014e6900b825f67389ab0ccd01329",
        "revision_id": "5ee297f53dc7f8e70183031cff62f37b0f19d25f",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-08-03 16:44:16",
        "revision_date": "2023-07-20 15:17:00",
        "committer_date": "2023-07-23 16:09:30",
        "github_id": 220016632,
        "star_events_count": 341,
        "fork_events_count": 40,
        "gha_license_id": "BSD-3-Clause",
        "gha_event_created_at": "2021-08-13 13:54:45",
        "gha_created_at": "2019-11-06 14:32:31",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1216,
        "extension": "cpp",
        "content": "// Copyright 2017 The PDFium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Original code copyright 2014 Foxit Software Inc. http://www.foxitsoftware.com\n\n#include \"xfa/fxfa/parser/cxfa_solid.h\"\n\n#include \"fxjs/xfa/cjx_node.h\"\n#include \"xfa/fxfa/parser/cxfa_document.h\"\n\nnamespace {\n\nconst CXFA_Node::PropertyData kSolidPropertyData[] = {\n    {XFA_Element::Extras, 1, {}},\n};\n\nconst CXFA_Node::AttributeData kSolidAttributeData[] = {\n    {XFA_Attribute::Id, XFA_AttributeType::CData, nullptr},\n    {XFA_Attribute::Use, XFA_AttributeType::CData, nullptr},\n    {XFA_Attribute::Usehref, XFA_AttributeType::CData, nullptr},\n};\n\n}  // namespace\n\nCXFA_Solid::CXFA_Solid(CXFA_Document* doc, XFA_PacketType packet)\n    : CXFA_Node(doc,\n                packet,\n                {XFA_XDPPACKET::kTemplate, XFA_XDPPACKET::kForm},\n                XFA_ObjectType::Node,\n                XFA_Element::Solid,\n                kSolidPropertyData,\n                kSolidAttributeData,\n                cppgc::MakeGarbageCollected<CJX_Node>(\n                    doc->GetHeap()->GetAllocationHandle(),\n                    this)) {}\n\nCXFA_Solid::~CXFA_Solid() = default;\n",
        "blame_info": {
            "jengelh@inai.de": [
                [
                    1,
                    38
                ]
            ]
        }
    },
    {
        "blob_id": "80e9638e9a9955c45831c86dc3497224eea00c9c",
        "directory_id": "4f2f4ca1cb010ab79ad3933e73dce6671f012054",
        "path": "/SK-Lib/test_sk_header.cpp",
        "content_id": "2491fbed63d9441372bd23eb682d72c41f371115",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "sksavigit/CPP-Progs",
        "snapshot_id": "f95cfbea5a3caa40baca8637d55e9c1d5a000670",
        "revision_id": "178a414d3c424a18cfe8cf6f9c3df697dffe2993",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-02-17 15:01:02",
        "revision_date": "2021-01-16 13:09:01",
        "committer_date": "2021-01-16 13:09:01",
        "github_id": 328104206,
        "star_events_count": 1,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 485,
        "extension": "cpp",
        "content": "#include<iostream>\n#include \"sklib_numbers.h\"\n#include \"sklib_iostream.h\"\nusing namespace std;\n\nint main(){\n    char n1[]=\"0000000000000000000000000001\";\n    char n2[]=\"1111123424324243234234234324\";\n    cout << \"\\n Num1:\" <<n1;\n    cout << \"\\n Num2:\" <<n2;\n    cout << \"\\n Outp:\";\n    int n1Size=sizeof(n1)/sizeof(n1[0]);\n    int n2Size=sizeof(n2)/sizeof(n2[0]);\n    char res[n1Size>n2Size ? n1Size:n2Size];\n    sum_two_big_numbers(n1,n2,res);\n    cout << res<< \"\\n\";\n    return 0;\n}\n",
        "blame_info": {
            "sksavi@yahoo.com": [
                [
                    1,
                    18
                ]
            ]
        }
    },
    {
        "blob_id": "849e17e440d0e9523fb0dd1a5f7f9d2bf5e1f416",
        "directory_id": "6b2a8dd202fdce77c971c412717e305e1caaac51",
        "path": "/solutions_5686313294495744_0/C++/vidhan13j07/test.cpp",
        "content_id": "5edfd10037fb916f2f5fbdef7cf9305b0b29d5b9",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "alexandraback/datacollection",
        "snapshot_id": "0bc67a9ace00abbc843f4912562f3a064992e0e9",
        "revision_id": "076a7bc7693f3abf07bfdbdac838cb4ef65ccfcf",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-24 18:27:24",
        "revision_date": "2017-05-23 09:23:38",
        "committer_date": "2017-05-23 09:23:38",
        "github_id": 84313442,
        "star_events_count": 2,
        "fork_events_count": 4,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 2489,
        "extension": "cpp",
        "content": "#include<bits/stdc++.h>\n#define sc(v) v.size()\n#define eb push_back\n#define pb pop_back\n#define f(i,a,b) for(int i=a;i<b;i++)\n#define TC() int t;cin>>t;while(t--)\n#define all(x) x.begin(),x.end()\n#define mk make_pair\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define eps 1e-9\n#define pw(x) (1ll<<(x))\n#define trace1(x)                cout <<#x<<\": \"<<x<<endl;\n#define trace2(x, y)             cout <<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<< endl;\n#define trace3(x, y, z)          cout <<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<<\" | \"<<#z<<\": \"<<z<<endl;\n#define trace4(a, b, c, d)       cout <<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<endl;\n#define trace5(a, b, c, d, e)    cout <<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<<\": \"<<e<<endl;\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<string,string> pi;\ntypedef pair<ll,ll> pll;\n\ninline bool EQ(double a,double b) { return fabs(a - b) < 1e-9; }\ninline void set_bit(int & n, int b) { n |= pw(b); }\ninline void unset_bit(int & n, int b) { n &= ~pw(b); }\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n        //freopen(\"input.txt\",\"r\",stdin);\n        //freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    clock_t tStart = clock();\n    int tc = 1;\n    int n;\n    map< pi,int > mp;\n    vector< pi > v;\n    set< pi > vv;\n    vector<string> f,rr;\n    string x,y;\n    set<string> a,b;\n    TC()\n    {\n        printf(\"Case #%d: \", tc++);\n        mp.clear();\n        v.clear();\n        a.clear();\n        b.clear();\n        scanf(\"%d\",&n);\n        f(i,0,n)\n        {\n            cin>>x>>y;\n            v.eb(mk(x,y));\n            mp[mk(x,y)] = 1;\n        }\n        int ans = 0;\n        f(i,0,1 << n)\n        {\n            f.clear();\n            rr.clear();\n            vv.clear();\n            int c = 0;\n            f(j,0,n)\n                if(i&(1 << j))\n                {\n                    f.eb(v[j].fi);\n                    rr.eb(v[j].se);\n                    vv.insert(v[j]);\n                }\n            f(j,0,sc(f))\n                f(k,0,sc(rr))\n                {\n                    if(vv.find(mk(f[j],rr[k])) != vv.end())\n                        continue;\n                    if(mp[mk(f[j],rr[k])])\n                        c++;\n                }\n            ans = max(ans,c);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n    return 0;\n}\n\n\n",
        "blame_info": {
            "alexandra1.back@gmail.com": [
                [
                    1,
                    90
                ]
            ]
        }
    },
    {
        "blob_id": "efee5b91d30e90f44f56ca962bc4d6b383191c2d",
        "directory_id": "e86c079391367e0e401482eb43a850685ac54056",
        "path": "/ex05/Human.cpp",
        "content_id": "f99f1bbfa2e2506c59f393e4c073e71ef72e65d8",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "atronk/cpp-01",
        "snapshot_id": "c85155abd9cf83b5de370ed1c033ba831f4207b8",
        "revision_id": "533a01c039235b436d461df8169169d70c8b97b9",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-05-25 17:51:51",
        "revision_date": "2021-05-22 17:14:38",
        "committer_date": "2021-05-22 17:14:38",
        "github_id": null,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 312,
        "extension": "cpp",
        "content": "#include \"Human.hpp\"\n\nHuman::Human() {\n\tstd::cout << \"A Human is created!\" << std::endl;\n}\nHuman::~Human() {\n\tstd::cout << \"A Human is destroyed\" << std::endl;\n}\n\nconst Brain& Human::getBrain() const {\n\treturn (this->_brain);\n}\nconst std::string& Human::identify() const {\n\treturn(this->getBrain().identify());\n}",
        "blame_info": {
            "idcdtokms@gmail.com": [
                [
                    1,
                    15
                ]
            ]
        }
    },
    {
        "blob_id": "fb2b6fce1f3a5910d5291c675a6eb7f894f065a6",
        "directory_id": "5009ee81abc75dfd651a16c4ded48d91f6ef7a07",
        "path": "/mediapipe/java/com/google/mediapipe/framework/jni/graph.cc",
        "content_id": "f02cb83d0339dab28ea2943ae502b5f357cedda4",
        "detected_licenses": [
            "Apache-2.0"
        ],
        "license_type": "permissive",
        "repo_name": "sakibguy/mediapipe",
        "snapshot_id": "6dee276ddd31d0abd9d87f40ca7750848ecd9dd2",
        "revision_id": "d9ae4fdd5e7d4529a7cbeb5e45397f2e746a7e9c",
        "branch_name": "refs/heads/master",
        "visit_date": "2023-08-28 08:52:07",
        "revision_date": "2021-10-22 18:51:12",
        "committer_date": "2021-10-22 18:51:12",
        "github_id": 402824514,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": "Apache-2.0",
        "gha_event_created_at": "2021-09-20 05:12:05",
        "gha_created_at": "2021-09-03 15:58:30",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 23189,
        "extension": "cc",
        "content": "// Copyright 2019 The MediaPipe Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"mediapipe/java/com/google/mediapipe/framework/jni/graph.h\"\n\n#include <pthread.h>\n\n#include <vector>\n\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_format.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"mediapipe/framework/calculator_framework.h\"\n#include \"mediapipe/framework/port/canonical_errors.h\"\n#include \"mediapipe/framework/port/logging.h\"\n#include \"mediapipe/framework/port/proto_ns.h\"\n#include \"mediapipe/framework/port/status.h\"\n#include \"mediapipe/framework/port/threadpool.h\"\n#include \"mediapipe/framework/tool/executor_util.h\"\n#include \"mediapipe/framework/tool/name_util.h\"\n#include \"mediapipe/gpu/gpu_shared_data_internal.h\"\n#include \"mediapipe/gpu/graph_support.h\"\n#include \"mediapipe/java/com/google/mediapipe/framework/jni/class_registry.h\"\n#include \"mediapipe/java/com/google/mediapipe/framework/jni/jni_util.h\"\n#include \"mediapipe/java/com/google/mediapipe/framework/jni/packet_context_jni.h\"\n#ifdef __ANDROID__\n#include \"mediapipe/util/android/file/base/helpers.h\"\n#else\n#include \"mediapipe/framework/port/file_helpers.h\"\n#endif  // __ANDROID__\n#if !MEDIAPIPE_DISABLE_GPU\n#include \"mediapipe/gpu/egl_surface_holder.h\"\n#endif  // !MEDIAPIPE_DISABLE_GPU\n\nnamespace mediapipe {\nnamespace android {\n\nnamespace internal {\n// PacketWithContext is the native counterpart of the Java Packet.\nclass PacketWithContext {\n public:\n  PacketWithContext(Graph* context, const Packet& packet)\n      : context_(context), packet_(packet) {}\n\n  ~PacketWithContext() {}\n\n  Graph* GetContext() { return context_; }\n\n  Packet& packet() { return packet_; }\n\n private:\n  Graph* context_;\n  Packet packet_;\n};\n\n// A callback handler that wraps the java callback, and submits it for\n// execution through Graph.\nclass CallbackHandler {\n public:\n  CallbackHandler(Graph* context, jobject callback)\n      : context_(context), java_callback_(callback) {}\n\n  ~CallbackHandler() {\n    // The jobject global reference is managed by the Graph directly.\n    // So no-op here.\n    if (java_callback_) {\n      LOG(ERROR) << \"Java callback global reference is not released.\";\n    }\n  }\n\n  void PacketCallback(const Packet& packet) {\n    context_->CallbackToJava(mediapipe::java::GetJNIEnv(), java_callback_,\n                             packet);\n  }\n\n  void PacketWithHeaderCallback(const Packet& packet, const Packet& header) {\n    context_->CallbackToJava(mediapipe::java::GetJNIEnv(), java_callback_,\n                             packet, header);\n  }\n\n  void PacketListCallback(const std::vector<Packet>& packets) {\n    context_->CallbackToJava(mediapipe::java::GetJNIEnv(), java_callback_,\n                             packets);\n  }\n\n  std::function<void(const Packet&)> CreateCallback() {\n    return std::bind(&CallbackHandler::PacketCallback, this,\n                     std::placeholders::_1);\n  }\n\n  std::function<void(const std::vector<Packet>&)> CreatePacketListCallback() {\n    return std::bind(&CallbackHandler::PacketListCallback, this,\n                     std::placeholders::_1);\n  }\n\n  std::function<void(const Packet&, const Packet&)> CreateCallbackWithHeader() {\n    return std::bind(&CallbackHandler::PacketWithHeaderCallback, this,\n                     std::placeholders::_1, std::placeholders::_2);\n  }\n\n  // Releases the global reference to the java callback object.\n  // This is called by the Graph, since releasing of a jni object\n  // requires JNIEnv object that we can not keep a copy of.\n  void ReleaseCallback(JNIEnv* env) {\n    env->DeleteGlobalRef(java_callback_);\n    java_callback_ = nullptr;\n  }\n\n private:\n  Graph* context_;\n  // java callback object\n  jobject java_callback_;\n};\n}  // namespace internal\n\nGraph::Graph()\n    : executor_stack_size_increased_(false), global_java_packet_cls_(nullptr) {}\n\nGraph::~Graph() {\n  if (running_graph_) {\n    running_graph_->Cancel();\n    running_graph_->WaitUntilDone().IgnoreError();\n  }\n  // Cleans up the jni objects.\n  JNIEnv* env = mediapipe::java::GetJNIEnv();\n  if (env == nullptr) {\n    LOG(ERROR) << \"Can't attach to java thread, no jni clean up performed.\";\n    return;\n  }\n  for (const auto& handler : callback_handlers_) {\n    handler->ReleaseCallback(env);\n  }\n  if (global_java_packet_cls_) {\n    env->DeleteGlobalRef(global_java_packet_cls_);\n    global_java_packet_cls_ = nullptr;\n  }\n}\n\nint64_t Graph::WrapPacketIntoContext(const Packet& packet) {\n  absl::MutexLock lock(&all_packets_mutex_);\n  auto packet_context = new internal::PacketWithContext(this, packet);\n  // Since the value of the all_packets_ map is a unique_ptr, resets it with the\n  // new allocated object.\n  all_packets_[packet_context].reset(packet_context);\n  VLOG(2) << \"Graph packet reference buffer size: \" << all_packets_.size();\n  return reinterpret_cast<int64_t>(packet_context);\n}\n\n// static\nPacket Graph::GetPacketFromHandle(int64_t packet_handle) {\n  internal::PacketWithContext* packet_with_context =\n      reinterpret_cast<internal::PacketWithContext*>(packet_handle);\n  return packet_with_context->packet();\n}\n\n// static\nGraph* Graph::GetContextFromHandle(int64_t packet_handle) {\n  internal::PacketWithContext* packet_with_context =\n      reinterpret_cast<internal::PacketWithContext*>(packet_handle);\n  return packet_with_context->GetContext();\n}\n\n// static\nbool Graph::RemovePacket(int64_t packet_handle) {\n  internal::PacketWithContext* packet_with_context =\n      reinterpret_cast<internal::PacketWithContext*>(packet_handle);\n  Graph* context = packet_with_context->GetContext();\n  absl::MutexLock lock(&(context->all_packets_mutex_));\n  return context->all_packets_.erase(packet_with_context) != 0;\n}\n\nvoid Graph::EnsureMinimumExecutorStackSizeForJava() {}\n\nabsl::Status Graph::AddCallbackHandler(std::string output_stream_name,\n                                       jobject java_callback) {\n  if (!graph_config()) {\n    return absl::InternalError(\"Graph is not loaded!\");\n  }\n  std::unique_ptr<internal::CallbackHandler> handler(\n      new internal::CallbackHandler(this, java_callback));\n  std::string side_packet_name;\n  tool::AddCallbackCalculator(output_stream_name, graph_config(),\n                              &side_packet_name,\n                              /* use_std_function = */ true);\n  EnsureMinimumExecutorStackSizeForJava();\n  side_packets_callbacks_.emplace(\n      side_packet_name, MakePacket<std::function<void(const Packet&)>>(\n                            handler->CreateCallback()));\n  callback_handlers_.emplace_back(std::move(handler));\n  return absl::OkStatus();\n}\n\nabsl::Status Graph::AddMultiStreamCallbackHandler(\n    std::vector<std::string> output_stream_names, jobject java_callback,\n    bool observe_timestamp_bounds) {\n  if (!graph_config()) {\n    return absl::InternalError(\"Graph is not loaded!\");\n  }\n  auto handler =\n      absl::make_unique<internal::CallbackHandler>(this, java_callback);\n  tool::AddMultiStreamCallback(\n      output_stream_names, handler->CreatePacketListCallback(), graph_config(),\n      &side_packets_, observe_timestamp_bounds);\n  EnsureMinimumExecutorStackSizeForJava();\n  callback_handlers_.emplace_back(std::move(handler));\n  return absl::OkStatus();\n}\n\nint64_t Graph::AddSurfaceOutput(const std::string& output_stream_name) {\n  if (!graph_config()) {\n    LOG(ERROR) << \"Graph is not loaded!\";\n    return 0;\n  }\n\n#if MEDIAPIPE_DISABLE_GPU\n  LOG(FATAL) << \"GPU support has been disabled in this build!\";\n#else\n  CalculatorGraphConfig::Node* sink_node = graph_config()->add_node();\n  sink_node->set_name(mediapipe::tool::GetUnusedNodeName(\n      *graph_config(), absl::StrCat(\"egl_surface_sink_\", output_stream_name)));\n  sink_node->set_calculator(\"GlSurfaceSinkCalculator\");\n  sink_node->add_input_stream(output_stream_name);\n  sink_node->add_input_side_packet(\n      absl::StrCat(kGpuSharedTagName, \":\", kGpuSharedSidePacketName));\n\n  const std::string input_side_packet_name =\n      mediapipe::tool::GetUnusedSidePacketName(\n          *graph_config(), absl::StrCat(output_stream_name, \"_surface\"));\n  sink_node->add_input_side_packet(\n      absl::StrCat(\"SURFACE:\", input_side_packet_name));\n\n  auto it_inserted = output_surface_side_packets_.emplace(\n      input_side_packet_name,\n      AdoptAsUniquePtr(new mediapipe::EglSurfaceHolder()));\n\n  return WrapPacketIntoContext(it_inserted.first->second);\n#endif  // MEDIAPIPE_DISABLE_GPU\n}\n\nabsl::Status Graph::LoadBinaryGraph(std::string path_to_graph) {\n  std::string graph_config_string;\n  absl::Status status =\n      mediapipe::file::GetContents(path_to_graph, &graph_config_string);\n  if (!status.ok()) {\n    return status;\n  }\n  return LoadBinaryGraph(graph_config_string.c_str(),\n                         graph_config_string.length());\n}\n\nabsl::Status Graph::LoadBinaryGraph(const char* data, int size) {\n  CalculatorGraphConfig graph_config;\n  if (!graph_config.ParseFromArray(data, size)) {\n    return absl::InvalidArgumentError(\"Failed to parse the graph\");\n  }\n  graph_configs_.push_back(graph_config);\n  return absl::OkStatus();\n}\n\nabsl::Status Graph::LoadBinaryGraphTemplate(const char* data, int size) {\n  CalculatorGraphTemplate graph_template;\n  if (!graph_template.ParseFromArray(data, size)) {\n    return absl::InvalidArgumentError(\"Failed to parse the graph\");\n  }\n  graph_templates_.push_back(graph_template);\n  return absl::OkStatus();\n}\n\nabsl::Status Graph::SetGraphType(std::string graph_type) {\n  graph_type_ = graph_type;\n  return absl::OkStatus();\n}\n\nabsl::Status Graph::SetGraphOptions(const char* data, int size) {\n  if (!graph_options_.ParseFromArray(data, size)) {\n    return absl::InvalidArgumentError(\"Failed to parse the graph\");\n  }\n  return absl::OkStatus();\n}\n\nCalculatorGraphConfig Graph::GetCalculatorGraphConfig() {\n  CalculatorGraph temp_graph;\n  absl::Status status = InitializeGraph(&temp_graph);\n  if (!status.ok()) {\n    LOG(ERROR) << \"GetCalculatorGraphConfig failed:\\n\" << status.message();\n  }\n  return temp_graph.Config();\n}\n\nvoid Graph::CallbackToJava(JNIEnv* env, jobject java_callback_obj,\n                           const Packet& packet) {\n  jclass callback_cls = env->GetObjectClass(java_callback_obj);\n\n  auto& class_registry = mediapipe::android::ClassRegistry::GetInstance();\n  std::string packet_class_name = class_registry.GetClassName(\n      mediapipe::android::ClassRegistry::kPacketClassName);\n  std::string process_method_name = class_registry.GetMethodName(\n      mediapipe::android::ClassRegistry::kPacketCallbackClassName, \"process\");\n\n  jmethodID processMethod =\n      env->GetMethodID(callback_cls, process_method_name.c_str(),\n                       absl::StrFormat(\"(L%s;)V\", packet_class_name).c_str());\n\n  int64_t packet_handle = WrapPacketIntoContext(packet);\n  // Creates a Java Packet.\n  VLOG(2) << \"Creating java packet preparing for callback to java.\";\n  jobject java_packet =\n      CreateJavaPacket(env, global_java_packet_cls_, packet_handle);\n  VLOG(2) << \"Calling java callback.\";\n  env->CallVoidMethod(java_callback_obj, processMethod, java_packet);\n  // release the packet after callback.\n  RemovePacket(packet_handle);\n  env->DeleteLocalRef(callback_cls);\n  env->DeleteLocalRef(java_packet);\n  VLOG(2) << \"Returned from java callback.\";\n}\n\nvoid Graph::CallbackToJava(JNIEnv* env, jobject java_callback_obj,\n                           const Packet& packet, const Packet& header_packet) {\n  jclass callback_cls = env->GetObjectClass(java_callback_obj);\n\n  auto& class_registry = mediapipe::android::ClassRegistry::GetInstance();\n  std::string packet_class_name = class_registry.GetClassName(\n      mediapipe::android::ClassRegistry::kPacketClassName);\n  std::string process_method_name = class_registry.GetMethodName(\n      mediapipe::android::ClassRegistry::kPacketWithHeaderCallbackClassName,\n      \"process\");\n\n  jmethodID processMethod = env->GetMethodID(\n      callback_cls, process_method_name.c_str(),\n      absl::StrFormat(\"(L%s;L%s;)V\", packet_class_name, packet_class_name)\n          .c_str());\n\n  int64_t packet_handle = WrapPacketIntoContext(packet);\n  int64_t header_packet_handle = WrapPacketIntoContext(header_packet);\n  // Creates a Java Packet.\n  jobject java_packet =\n      CreateJavaPacket(env, global_java_packet_cls_, packet_handle);\n  jobject java_header_packet =\n      CreateJavaPacket(env, global_java_packet_cls_, header_packet_handle);\n  env->CallVoidMethod(java_callback_obj, processMethod, java_packet,\n                      java_header_packet);\n  // release the packet after callback.\n  RemovePacket(packet_handle);\n  RemovePacket(header_packet_handle);\n  env->DeleteLocalRef(callback_cls);\n  env->DeleteLocalRef(java_packet);\n  env->DeleteLocalRef(java_header_packet);\n}\n\nvoid Graph::CallbackToJava(JNIEnv* env, jobject java_callback_obj,\n                           const std::vector<Packet>& packets) {\n  jclass callback_cls = env->GetObjectClass(java_callback_obj);\n\n  auto& class_registry = mediapipe::android::ClassRegistry::GetInstance();\n  const std::string process_method_name = class_registry.GetMethodName(\n      mediapipe::android::ClassRegistry::kPacketListCallbackClassName,\n      \"process\");\n  jmethodID processMethod = env->GetMethodID(\n      callback_cls, process_method_name.c_str(), \"(Ljava/util/List;)V\");\n\n  jclass list_cls = env->FindClass(\"java/util/ArrayList\");\n  jobject java_list =\n      env->NewObject(list_cls, env->GetMethodID(list_cls, \"<init>\", \"()V\"));\n  jmethodID add_method =\n      env->GetMethodID(list_cls, \"add\", \"(Ljava/lang/Object;)Z\");\n  std::vector<int64_t> packet_handles;\n  for (const Packet& packet : packets) {\n    int64_t packet_handle = WrapPacketIntoContext(packet);\n    packet_handles.push_back(packet_handle);\n    jobject java_packet =\n        CreateJavaPacket(env, global_java_packet_cls_, packet_handle);\n    env->CallBooleanMethod(java_list, add_method, java_packet);\n    env->DeleteLocalRef(java_packet);\n  }\n\n  VLOG(2) << \"Calling java callback.\";\n  env->CallVoidMethod(java_callback_obj, processMethod, java_list);\n  // release the packet after callback.\n  for (int64_t packet_handle : packet_handles) {\n    RemovePacket(packet_handle);\n  }\n  env->DeleteLocalRef(callback_cls);\n  env->DeleteLocalRef(java_list);\n  VLOG(2) << \"Returned from java callback.\";\n}\n\nvoid Graph::SetPacketJavaClass(JNIEnv* env) {\n  if (global_java_packet_cls_ == nullptr) {\n    auto& class_registry = ClassRegistry::GetInstance();\n    std::string packet_class_name = class_registry.GetClassName(\n        mediapipe::android::ClassRegistry::kPacketClassName);\n    jclass packet_cls = env->FindClass(packet_class_name.c_str());\n    global_java_packet_cls_ =\n        reinterpret_cast<jclass>(env->NewGlobalRef(packet_cls));\n  }\n}\n\nabsl::Status Graph::RunGraphUntilClose(JNIEnv* env) {\n  // Get a global reference to the packet class, so it can be used in other\n  // native thread for call back.\n  SetPacketJavaClass(env);\n  // Running as a synchronized mode, the same Java thread is available through\n  // out the run.\n  CalculatorGraph calculator_graph;\n  absl::Status status = InitializeGraph(&calculator_graph);\n  if (!status.ok()) {\n    LOG(ERROR) << status.message();\n    running_graph_.reset(nullptr);\n    return status;\n  }\n  // TODO: gpu & services set up!\n  status = calculator_graph.Run(CreateCombinedSidePackets());\n  LOG(INFO) << \"Graph run finished.\";\n\n  return status;\n}\n\nabsl::Status Graph::StartRunningGraph(JNIEnv* env) {\n  if (running_graph_) {\n    return absl::InternalError(\"Graph is already running.\");\n  }\n  // Get a global reference to the packet class, so it can be used in other\n  // native thread for call back.\n  SetPacketJavaClass(env);\n  // Running as a synchronized mode, the same Java thread is available\n  // throughout the run.\n  running_graph_.reset(new CalculatorGraph());\n  // Set the mode for adding packets to graph input streams.\n  running_graph_->SetGraphInputStreamAddMode(graph_input_stream_add_mode_);\n  if (VLOG_IS_ON(2)) {\n    LOG(INFO) << \"input packet streams:\";\n    for (auto& name : graph_config()->input_stream()) {\n      LOG(INFO) << name;\n    }\n  }\n  absl::Status status;\n#if !MEDIAPIPE_DISABLE_GPU\n  status = running_graph_->SetGpuResources(gpu_resources_);\n  if (!status.ok()) {\n    LOG(ERROR) << status.message();\n    running_graph_.reset(nullptr);\n    return status;\n  }\n#endif  // !MEDIAPIPE_DISABLE_GPU\n\n  for (const auto& service_packet : service_packets_) {\n    status = running_graph_->SetServicePacket(*service_packet.first,\n                                              service_packet.second);\n    if (!status.ok()) {\n      LOG(ERROR) << status.message();\n      running_graph_.reset(nullptr);\n      return status;\n    }\n  }\n\n  status = InitializeGraph(running_graph_.get());\n  if (!status.ok()) {\n    LOG(ERROR) << status.message();\n    running_graph_.reset(nullptr);\n    return status;\n  }\n  LOG(INFO) << \"Start running the graph, waiting for inputs.\";\n  status =\n      running_graph_->StartRun(CreateCombinedSidePackets(), stream_headers_);\n  if (!status.ok()) {\n    LOG(ERROR) << status;\n    running_graph_.reset(nullptr);\n    return status;\n  }\n  return absl::OkStatus();\n}\n\nabsl::Status Graph::SetTimestampAndMovePacketToInputStream(\n    const std::string& stream_name, int64_t packet_handle, int64_t timestamp) {\n  internal::PacketWithContext* packet_with_context =\n      reinterpret_cast<internal::PacketWithContext*>(packet_handle);\n  Packet& packet = packet_with_context->packet();\n\n  // Set the timestamp of the packet in-place by calling the rvalue-reference\n  // version of At here.\n  packet = std::move(packet).At(Timestamp::CreateNoErrorChecking(timestamp));\n\n  // Then std::move it into the input stream.\n  return AddPacketToInputStream(stream_name, std::move(packet));\n}\n\nabsl::Status Graph::AddPacketToInputStream(const std::string& stream_name,\n                                           const Packet& packet) {\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n\n  return running_graph_->AddPacketToInputStream(stream_name, packet);\n}\n\nabsl::Status Graph::AddPacketToInputStream(const std::string& stream_name,\n                                           Packet&& packet) {\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n\n  return running_graph_->AddPacketToInputStream(stream_name, std::move(packet));\n}\n\nabsl::Status Graph::CloseInputStream(std::string stream_name) {\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n  LOG(INFO) << \"Close input stream: \" << stream_name;\n  return running_graph_->CloseInputStream(stream_name);\n}\n\nabsl::Status Graph::CloseAllInputStreams() {\n  LOG(INFO) << \"Close all input streams.\";\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n  return running_graph_->CloseAllInputStreams();\n}\n\nabsl::Status Graph::CloseAllPacketSources() {\n  LOG(INFO) << \"Close all input streams.\";\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n  return running_graph_->CloseAllPacketSources();\n}\n\nabsl::Status Graph::WaitUntilDone(JNIEnv* env) {\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n  absl::Status status = running_graph_->WaitUntilDone();\n  running_graph_.reset(nullptr);\n  return status;\n}\n\nabsl::Status Graph::WaitUntilIdle(JNIEnv* env) {\n  if (!running_graph_) {\n    return absl::FailedPreconditionError(\"Graph must be running.\");\n  }\n  return running_graph_->WaitUntilIdle();\n}\n\nvoid Graph::SetInputSidePacket(const std::string& stream_name,\n                               const Packet& packet) {\n  side_packets_[stream_name] = packet;\n}\n\nvoid Graph::SetStreamHeader(const std::string& stream_name,\n                            const Packet& packet) {\n  stream_headers_[stream_name] = packet;\n  LOG(INFO) << stream_name << \" stream header being set.\";\n}\n\nvoid Graph::SetGraphInputStreamAddMode(\n    CalculatorGraph::GraphInputStreamAddMode mode) {\n  graph_input_stream_add_mode_ = mode;\n}\n\nmediapipe::GpuResources* Graph::GetGpuResources() const {\n  return gpu_resources_.get();\n}\n\nabsl::Status Graph::SetParentGlContext(int64 java_gl_context) {\n  if (gpu_resources_) {\n    return absl::AlreadyExistsError(\n        \"trying to set the parent GL context, but the gpu shared \"\n        \"data has already been set up.\");\n  }\n#if MEDIAPIPE_DISABLE_GPU\n  LOG(FATAL) << \"GPU support has been disabled in this build!\";\n#else\n  ASSIGN_OR_RETURN(gpu_resources_,\n                   mediapipe::GpuResources::Create(\n                       reinterpret_cast<EGLContext>(java_gl_context)));\n#endif  // MEDIAPIPE_DISABLE_GPU\n  return absl::OkStatus();\n}\n\nvoid Graph::SetServicePacket(const GraphServiceBase& service, Packet packet) {\n  service_packets_[&service] = std::move(packet);\n}\n\nvoid Graph::CancelGraph() {\n  if (running_graph_) {\n    running_graph_->Cancel();\n  }\n}\n\nstd::map<std::string, Packet> Graph::CreateCombinedSidePackets() {\n  std::map<std::string, Packet> combined_side_packets = side_packets_callbacks_;\n  combined_side_packets.insert(side_packets_.begin(), side_packets_.end());\n  combined_side_packets.insert(output_surface_side_packets_.begin(),\n                               output_surface_side_packets_.end());\n  return combined_side_packets;\n}\n\nProfilingContext* Graph::GetProfilingContext() {\n  if (running_graph_) {\n    return running_graph_->profiler();\n  }\n  return nullptr;\n}\n\nCalculatorGraphConfig* Graph::graph_config() {\n  // Return the last specified graph config with the required graph_type.\n  for (auto it = graph_configs_.rbegin(); it != graph_configs_.rend(); ++it) {\n    if (it->type() == graph_type()) {\n      return &*it;\n    }\n  }\n  for (auto it = graph_templates_.rbegin(); it != graph_templates_.rend();\n       ++it) {\n    if (it->mutable_config()->type() == graph_type()) {\n      return it->mutable_config();\n    }\n  }\n  return nullptr;\n}\n\nstd::string Graph::graph_type() {\n  // If a graph-type is specified, that type is used.  Otherwise the\n  // graph-type of the last specified graph config is used.\n  if (graph_type_ != \"<none>\") {\n    return graph_type_;\n  }\n  if (!graph_configs_.empty()) {\n    return graph_configs_.back().type();\n  }\n  if (!graph_templates_.empty()) {\n    return graph_templates_.back().config().type();\n  }\n  return \"\";\n}\n\nabsl::Status Graph::InitializeGraph(CalculatorGraph* graph) {\n  if (graph_configs_.size() == 1 && graph_templates_.empty()) {\n    return graph->Initialize(*graph_config());\n  } else {\n    return graph->Initialize(graph_configs_, graph_templates_, {}, graph_type(),\n                             &graph_options_);\n  }\n}\n\n}  // namespace android\n}  // namespace mediapipe\n",
        "blame_info": {
            "jqtang@google.com": [
                [
                    1,
                    41
                ],
                [
                    43,
                    43
                ],
                [
                    45,
                    91
                ],
                [
                    97,
                    101
                ],
                [
                    107,
                    184
                ],
                [
                    187,
                    187
                ],
                [
                    189,
                    200
                ],
                [
                    202,
                    203
                ],
                [
                    220,
                    225
                ],
                [
                    227,
                    229
                ],
                [
                    231,
                    237
                ],
                [
                    239,
                    247
                ],
                [
                    249,
                    250
                ],
                [
                    252,
                    252
                ],
                [
                    254,
                    261
                ],
                [
                    263,
                    264
                ],
                [
                    266,
                    267
                ],
                [
                    269,
                    270
                ],
                [
                    272,
                    273
                ],
                [
                    275,
                    276
                ],
                [
                    278,
                    279
                ],
                [
                    281,
                    281
                ],
                [
                    283,
                    284
                ],
                [
                    286,
                    286
                ],
                [
                    288,
                    288
                ],
                [
                    290,
                    293
                ],
                [
                    295,
                    361
                ],
                [
                    399,
                    409
                ],
                [
                    411,
                    416
                ],
                [
                    418,
                    429
                ],
                [
                    431,
                    431
                ],
                [
                    433,
                    447
                ],
                [
                    450,
                    455
                ],
                [
                    457,
                    481
                ],
                [
                    483,
                    484
                ],
                [
                    486,
                    492
                ],
                [
                    494,
                    498
                ],
                [
                    501,
                    501
                ],
                [
                    503,
                    507
                ],
                [
                    510,
                    510
                ],
                [
                    512,
                    516
                ],
                [
                    518,
                    518
                ],
                [
                    520,
                    524
                ],
                [
                    526,
                    527
                ],
                [
                    529,
                    532
                ],
                [
                    534,
                    535
                ],
                [
                    537,
                    540
                ],
                [
                    542,
                    542
                ],
                [
                    544,
                    544
                ],
                [
                    546,
                    549
                ],
                [
                    551,
                    551
                ],
                [
                    553,
                    576
                ],
                [
                    578,
                    578
                ],
                [
                    580,
                    582
                ],
                [
                    584,
                    585
                ],
                [
                    591,
                    648
                ],
                [
                    650,
                    659
                ]
            ],
            "chuoling@google.com": [
                [
                    42,
                    42
                ],
                [
                    44,
                    44
                ],
                [
                    92,
                    96
                ],
                [
                    102,
                    106
                ],
                [
                    185,
                    186
                ],
                [
                    188,
                    188
                ],
                [
                    201,
                    201
                ],
                [
                    204,
                    219
                ],
                [
                    226,
                    226
                ],
                [
                    230,
                    230
                ],
                [
                    238,
                    238
                ],
                [
                    248,
                    248
                ],
                [
                    251,
                    251
                ],
                [
                    253,
                    253
                ],
                [
                    262,
                    262
                ],
                [
                    265,
                    265
                ],
                [
                    268,
                    268
                ],
                [
                    271,
                    271
                ],
                [
                    274,
                    274
                ],
                [
                    277,
                    277
                ],
                [
                    280,
                    280
                ],
                [
                    282,
                    282
                ],
                [
                    285,
                    285
                ],
                [
                    287,
                    287
                ],
                [
                    289,
                    289
                ],
                [
                    294,
                    294
                ],
                [
                    362,
                    398
                ],
                [
                    410,
                    410
                ],
                [
                    417,
                    417
                ],
                [
                    430,
                    430
                ],
                [
                    432,
                    432
                ],
                [
                    448,
                    449
                ],
                [
                    456,
                    456
                ],
                [
                    482,
                    482
                ],
                [
                    485,
                    485
                ],
                [
                    499,
                    500
                ],
                [
                    502,
                    502
                ],
                [
                    508,
                    509
                ],
                [
                    511,
                    511
                ],
                [
                    517,
                    517
                ],
                [
                    519,
                    519
                ],
                [
                    525,
                    525
                ],
                [
                    528,
                    528
                ],
                [
                    533,
                    533
                ],
                [
                    536,
                    536
                ],
                [
                    541,
                    541
                ],
                [
                    543,
                    543
                ],
                [
                    545,
                    545
                ],
                [
                    550,
                    550
                ],
                [
                    552,
                    552
                ],
                [
                    577,
                    577
                ],
                [
                    579,
                    579
                ],
                [
                    583,
                    583
                ],
                [
                    586,
                    590
                ],
                [
                    649,
                    649
                ]
            ],
            "cmcclanahan@google.com": [
                [
                    493,
                    493
                ]
            ]
        }
    },
    {
        "blob_id": "8bfe178d65efb2f52470e306b87737b39f700ce6",
        "directory_id": "f80d267d410b784458e61e4c4603605de368de9b",
        "path": "/TESTONE/exampleios/usr/local/include/fit_developer_field_description.hpp",
        "content_id": "a5af5c51d16055664f81433af69b821385dd83c5",
        "detected_licenses": [],
        "license_type": "no_license",
        "repo_name": "bleeckerj/Xcode-FIT-TEST",
        "snapshot_id": "84bdb9e1969a93a6380a9c64dce0a0e715d81fe8",
        "revision_id": "37490e3b1e913dc3dfabdae39b48bddea24f1023",
        "branch_name": "refs/heads/master",
        "visit_date": "2021-01-20 14:39:53",
        "revision_date": "2017-02-22 05:59:28",
        "committer_date": "2017-02-22 05:59:28",
        "github_id": 82766547,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": null,
        "gha_event_created_at": null,
        "gha_created_at": null,
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 1772,
        "extension": "hpp",
        "content": "////////////////////////////////////////////////////////////////////////////////\n// The following FIT Protocol software provided may be used with FIT protocol\n// devices only and remains the copyrighted property of Dynastream Innovations Inc.\n// The software is being provided on an \"as-is\" basis and as an accommodation,\n// and therefore all warranties, representations, or guarantees of any kind\n// (whether express, implied or statutory) including, without limitation,\n// warranties of merchantability, non-infringement, or fitness for a particular\n// purpose, are specifically disclaimed.\n//\n// Copyright 2017 Dynastream Innovations Inc.\n////////////////////////////////////////////////////////////////////////////////\n// ****WARNING****  This file is auto-generated!  Do NOT edit this file.\n// Profile Version = 20.24Release\n// Tag = production/akw/20.24.01-0-g5fa480b\n////////////////////////////////////////////////////////////////////////////////\n\n\n#if !defined(FIT_DEVELOPER_FIELD_DESCRIPTION_HPP)\n#define FIT_DEVELOPER_FIELD_DESCRIPTION_HPP\n\n#include \"fit_field_description_mesg.hpp\"\n#include \"fit_developer_data_id_mesg.hpp\"\n#include <vector>\n\nnamespace fit\n{\nclass DeveloperFieldDescription\n{\npublic:\n    DeveloperFieldDescription() = delete;\n    DeveloperFieldDescription(const DeveloperFieldDescription& other);\n    DeveloperFieldDescription(const FieldDescriptionMesg& desc, const DeveloperDataIdMesg& developer);\n    virtual ~DeveloperFieldDescription();\n\n    FIT_UINT32 GetApplicationVersion() const;\n    FIT_UINT8 GetFieldDefinitionNumber() const;\n    std::vector<FIT_UINT8> GetApplicationId() const;\n\nprivate:\n    FieldDescriptionMesg* description;\n    DeveloperDataIdMesg* developer;\n};\n\n} // namespace fit\n\n#endif // defined(FIT_FIELD_DEFINITION_HPP)\n",
        "blame_info": {
            "julian@omata.com": [
                [
                    1,
                    46
                ]
            ]
        }
    },
    {
        "blob_id": "ce7178eb6e44ec165080f975b26d3222d3e26392",
        "directory_id": "f95975d9454984803586de7f0600f3ecf9918f60",
        "path": "/algorithms/kernel/logitboost/inner/logitboost_predict_batch_v1.cpp",
        "content_id": "c277522b8482939cffb3d04a3c2d70dd2e4fc924",
        "detected_licenses": [
            "Intel",
            "Apache-2.0"
        ],
        "license_type": "permissive",
        "repo_name": "jjuribe/daal",
        "snapshot_id": "f4e05656ca5f01e56debdbd2de51eeb2f506ca3d",
        "revision_id": "242d358db584dd4c9c65826b345fe63313ff8f2a",
        "branch_name": "refs/heads/master",
        "visit_date": "2020-09-15 01:33:34",
        "revision_date": "2019-11-21 08:27:26",
        "committer_date": "2019-11-21 08:27:26",
        "github_id": 223316648,
        "star_events_count": 0,
        "fork_events_count": 0,
        "gha_license_id": "Apache-2.0",
        "gha_event_created_at": "2019-11-22 03:33:41",
        "gha_created_at": "2019-11-22 03:33:39",
        "gha_language": null,
        "src_encoding": "UTF-8",
        "language": "C++",
        "is_vendor": false,
        "is_generated": false,
        "length_bytes": 3373,
        "extension": "cpp",
        "content": "/* file: logitboost_predict_batch_v1.cpp */\n/*******************************************************************************\n* Copyright 2014-2019 Intel Corporation\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\n/*\n//++\n//  Implementation of the interface for LogitBoost model-based prediction\n//--\n*/\n\n#include \"algorithms/boosting/logitboost_predict_types.h\"\n\nusing namespace daal::data_management;\nusing namespace daal::services;\n\nnamespace daal\n{\nnamespace algorithms\n{\nnamespace logitboost\n{\nnamespace prediction\n{\nnamespace interface1\n{\n\n/**\n * Returns the input Numeric Table object in the prediction stage of the classification algorithm\n * \\param[in] id    Identifier of the input NumericTable object\n * \\return          %Input object that corresponds to the given identifier\n */\nNumericTablePtr Input::get(classifier::prediction::NumericTableInputId id) const\n{\n    return staticPointerCast<NumericTable, SerializationIface>(Argument::get(id));\n}\n\n/**\n * Returns the input Model object in the prediction stage of the LogitBoost algorithm\n * \\param[in] id    Identifier of the input Model object\n * \\return          %Input object that corresponds to the given identifier\n */\nlogitboost::interface1::ModelPtr Input::get(classifier::prediction::ModelInputId id) const\n{\n    return staticPointerCast<logitboost::interface1::Model, SerializationIface>(Argument::get(id));\n}\n\n/**\n * Sets the input NumericTable object in the prediction stage of the classification algorithm\n * \\param[in] id    Identifier of the input object\n * \\param[in] ptr   Pointer to the input object\n */\nvoid Input::set(classifier::prediction::NumericTableInputId id, const NumericTablePtr &ptr)\n{\n    Argument::set(id, ptr);\n}\n\n/**\n * Sets the input Model object in the prediction stage of the LogitBoost algorithm\n * \\param[in] id    Identifier of the input object\n * \\param[in] ptr   Pointer to the input object\n */\nvoid Input::set(classifier::prediction::ModelInputId id, const logitboost::interface1::ModelPtr &ptr)\n{\n    Argument::set(id, ptr);\n}\n\n/**\n * Checks the correctness of the input object\n * \\param[in] parameter Pointer to the structure of the algorithm parameters\n * \\param[in] method    Computation method\n */\nservices::Status Input::check(const daal::algorithms::Parameter *parameter, int method) const\n{\n    services::Status s = classifier::prediction::interface1::Input::check(parameter, method);\n    if(!s) return s;\n\n    logitboost::interface1::ModelPtr m =\n        staticPointerCast<logitboost::interface1::Model, classifier::Model>(get(classifier::prediction::model));\n    DAAL_CHECK(m->getNumberOfWeakLearners() > 0, ErrorModelNotFullInitialized);\n    return s;\n}\n} // namespace interface1\n\n} // namespace prediction\n} // namespace logitboost\n} // namespace algorithms\n} // namespace daal\n",
        "blame_info": {
            "noreply@github.com": [
                [
                    1,
                    1
                ],
                [
                    20,
                    20
                ],
                [
                    24,
                    24
                ],
                [
                    33,
                    33
                ],
                [
                    45,
                    45
                ],
                [
                    47,
                    47
                ],
                [
                    51,
                    51
                ],
                [
                    55,
                    55
                ],
                [
                    57,
                    57
                ],
                [
                    65,
                    65
                ],
                [
                    71,
                    71
                ],
                [
                    75,
                    75
                ],
                [
                    87,
                    88
                ],
                [
                    90,
                    93
                ],
                [
                    95,
                    95
                ],
                [
                    97,
                    100
                ]
            ],
            "nikolay.a.petrov@intel.com": [
                [
                    2,
                    19
                ],
                [
                    21,
                    23
                ],
                [
                    25,
                    32
                ],
                [
                    34,
                    44
                ],
                [
                    46,
                    46
                ],
                [
                    48,
                    50
                ],
                [
                    52,
                    54
                ],
                [
                    56,
                    56
                ],
                [
                    58,
                    64
                ],
                [
                    66,
                    70
                ],
                [
                    72,
                    74
                ],
                [
                    76,
                    86
                ],
                [
                    89,
                    89
                ],
                [
                    94,
                    94
                ],
                [
                    96,
                    96
                ]
            ]
        }
    }
]